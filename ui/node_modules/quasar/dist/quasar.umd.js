/*!
 * Quasar Framework v2.0.0-beta.19
 * (c) 2015-present Razvan Stoenescu
 * Released under the MIT License.
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('vue')) :
  typeof define === 'function' && define.amd ? define(['vue'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Quasar = factory(global.Vue));
}(this, (function (vue) { 'use strict';

  /* eslint-disable no-useless-escape */

  /**
   * __ QUASAR_SSR __            -> runs on SSR on client or server
   * __ QUASAR_SSR_SERVER __     -> runs on SSR on server
   * __ QUASAR_SSR_CLIENT __     -> runs on SSR on client
   * __ QUASAR_SSR_PWA __        -> built with SSR+PWA; may run on SSR on client or on PWA client
   *                              (needs runtime detection)
   */

  let isRuntimeSsrPreHydration = vue.ref(
    (
      false 
    )
  );

  let iosEmulated = false;
  let iosCorrection;

  function getMatch (userAgent, platformMatch) {
    const match = /(edge|edga|edgios)\/([\w.]+)/.exec(userAgent)
      || /(opr)[\/]([\w.]+)/.exec(userAgent)
      || /(vivaldi)[\/]([\w.]+)/.exec(userAgent)
      || /(chrome|crios)[\/]([\w.]+)/.exec(userAgent)
      || /(iemobile)[\/]([\w.]+)/.exec(userAgent)
      || /(version)(applewebkit)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(userAgent)
      || /(webkit)[\/]([\w.]+).*(version)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(userAgent)
      || /(firefox|fxios)[\/]([\w.]+)/.exec(userAgent)
      || /(webkit)[\/]([\w.]+)/.exec(userAgent)
      || /(opera)(?:.*version|)[\/]([\w.]+)/.exec(userAgent)
      || /(msie) ([\w.]+)/.exec(userAgent)
      || (userAgent.indexOf('trident') >= 0 && /(rv)(?::| )([\w.]+)/.exec(userAgent))
      || (userAgent.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(userAgent))
      || [];

    return {
      browser: match[ 5 ] || match[ 3 ] || match[ 1 ] || '',
      version: match[ 2 ] || match[ 4 ] || '0',
      versionNumber: match[ 4 ] || match[ 2 ] || '0',
      platform: platformMatch[ 0 ] || ''
    }
  }

  function getPlatformMatch (userAgent) {
    return /(ipad)/.exec(userAgent)
      || /(ipod)/.exec(userAgent)
      || /(windows phone)/.exec(userAgent)
      || /(iphone)/.exec(userAgent)
      || /(kindle)/.exec(userAgent)
      || /(silk)/.exec(userAgent)
      || /(android)/.exec(userAgent)
      || /(win)/.exec(userAgent)
      || /(mac)/.exec(userAgent)
      || /(linux)/.exec(userAgent)
      || /(cros)/.exec(userAgent)
      || /(playbook)/.exec(userAgent)
      || /(bb)/.exec(userAgent)
      || /(blackberry)/.exec(userAgent)
      || []
  }

  const hasTouch = 'ontouchstart' in window || window.navigator.maxTouchPoints > 0;

  function applyIosCorrection (is) {
    iosCorrection = { is: { ...is } };

    delete is.mac;
    delete is.desktop;

    const platform = Math.min(window.innerHeight, window.innerWidth) > 414
      ? 'ipad'
      : 'iphone';

    Object.assign(is, {
      mobile: true,
      ios: true,
      platform,
      [ platform ]: true
    });
  }

  function getPlatform (UA) {
    const
      userAgent = UA.toLowerCase(),
      platformMatch = getPlatformMatch(userAgent),
      matched = getMatch(userAgent, platformMatch),
      browser = {};

    if (matched.browser) {
      browser[ matched.browser ] = true;
      browser.version = matched.version;
      browser.versionNumber = parseInt(matched.versionNumber, 10);
    }

    if (matched.platform) {
      browser[ matched.platform ] = true;
    }

    const knownMobiles = browser.android
      || browser.ios
      || browser.bb
      || browser.blackberry
      || browser.ipad
      || browser.iphone
      || browser.ipod
      || browser.kindle
      || browser.playbook
      || browser.silk
      || browser[ 'windows phone' ];

    // These are all considered mobile platforms, meaning they run a mobile browser
    if (knownMobiles === true || userAgent.indexOf('mobile') > -1) {
      browser.mobile = true;

      if (browser.edga || browser.edgios) {
        browser.edge = true;
        matched.browser = 'edge';
      }
      else if (browser.crios) {
        browser.chrome = true;
        matched.browser = 'chrome';
      }
      else if (browser.fxios) {
        browser.firefox = true;
        matched.browser = 'firefox';
      }
    }
    // If it's not mobile we should consider it's desktop platform, meaning it runs a desktop browser
    // It's a workaround for anonymized user agents
    // (browser.cros || browser.mac || browser.linux || browser.win)
    else {
      browser.desktop = true;
    }

    // Set iOS if on iPod, iPad or iPhone
    if (browser.ipod || browser.ipad || browser.iphone) {
      browser.ios = true;
    }

    if (browser[ 'windows phone' ]) {
      browser.winphone = true;
      delete browser[ 'windows phone' ];
    }

    // Chrome, Opera 15+, Vivaldi and Safari are webkit based browsers
    if (
      browser.chrome
      || browser.opr
      || browser.safari
      || browser.vivaldi
      // we expect unknown, non iOS mobile browsers to be webkit based
      || (
        browser.mobile === true
        && browser.ios !== true
        && knownMobiles !== true
      )
    ) {
      browser.webkit = true;
    }

    // Blackberry browsers are marked as Safari on BlackBerry
    if (browser.safari && browser.blackberry || browser.bb) {
      matched.browser = 'blackberry';
      browser.blackberry = true;
    }

    // Playbook browsers are marked as Safari on Playbook
    if (browser.safari && browser.playbook) {
      matched.browser = 'playbook';
      browser.playbook = true;
    }

    // Opera 15+ are identified as opr
    if (browser.opr) {
      matched.browser = 'opera';
      browser.opera = true;
    }

    // Stock Android browsers are marked as Safari on Android.
    if (browser.safari && browser.android) {
      matched.browser = 'android';
      browser.android = true;
    }

    // Kindle browsers are marked as Safari on Kindle
    if (browser.safari && browser.kindle) {
      matched.browser = 'kindle';
      browser.kindle = true;
    }

    // Kindle Silk browsers are marked as Safari on Kindle
    if (browser.safari && browser.silk) {
      matched.browser = 'silk';
      browser.silk = true;
    }

    if (browser.vivaldi) {
      matched.browser = 'vivaldi';
      browser.vivaldi = true;
    }

    // Assign the name and platform variable
    browser.name = matched.browser;
    browser.platform = matched.platform;

    {
      if (userAgent.indexOf('electron') > -1) {
        browser.electron = true;
      }
      else if (document.location.href.indexOf('-extension://') > -1) {
        browser.bex = true;
      }
      else {
        if (window.Capacitor !== void 0) {
          browser.capacitor = true;
          browser.nativeMobile = true;
          browser.nativeMobileWrapper = 'capacitor';
        }
        else if (window._cordovaNative !== void 0 || window.cordova !== void 0) {
          browser.cordova = true;
          browser.nativeMobile = true;
          browser.nativeMobileWrapper = 'cordova';
        }

        if (
          hasTouch === true
          && browser.mac === true
          && (
            (browser.desktop === true && browser.safari === true)
            || (
              browser.nativeMobile === true
              && browser.android !== true
              && browser.ios !== true
              && browser.ipad !== true
            )
          )
        ) {
          /*
          * Correction needed for iOS since the default
          * setting on iPad is to request desktop view; if we have
          * touch support and the user agent says it's a
          * desktop, we infer that it's an iPhone/iPad with desktop view
          * so we must fix the false positives
          */
          applyIosCorrection(browser);
        }
      }
    }

    return browser
  }

  const userAgent = navigator.userAgent || navigator.vendor || window.opera;

  const ssrClient = {
    has: {
      touch: false,
      webStorage: false
    },
    within: { iframe: false }
  };

  // We export "client" for hydration error-free parts,
  // like touch directives who do not (and must NOT) wait
  // for the client takeover;
  // Do NOT import this directly in your app, unless you really know
  // what you are doing.
  const client = {
        userAgent,
        is: getPlatform(userAgent),
        has: {
          touch: hasTouch,
          webStorage: (() => {
            try {
              if (window.localStorage) {
                return true
              }
            }
            catch (e) {}
            return false
          })()
        },
        within: {
          iframe: window.self !== window.top
        }
      };

  const Platform = {
    install (opts) {
      const { $q } = opts;

      if (isRuntimeSsrPreHydration.value === true) {
        // takeover should increase accuracy for
        // the rest of the props; we also avoid
        // hydration errors
        opts.onSSRHydrated.push(() => {
          isRuntimeSsrPreHydration.value = false;
          Object.assign($q.platform, client);
          iosCorrection = void 0;
        });

        // we need to make platform reactive
        // for the takeover phase
        $q.platform = vue.reactive(this);
      }
      else {
        $q.platform = this;
      }
    }
  };

  {
    iosEmulated = client.is.ios === true
      && window.navigator.vendor.toLowerCase().indexOf('apple') === -1;

    if (isRuntimeSsrPreHydration.value === true) {
      // must match with server-side before
      // client taking over in order to prevent
      // hydration errors
      Object.assign(Platform, client, iosCorrection, ssrClient);
    }
    else {
      Object.assign(Platform, client);
    }
  }

  var defineReactivePlugin = (state, plugin) => {
        const props = {};
        const reactiveState = vue.reactive(state);

        Object.keys(state).forEach(name => {
          props[ name ] = {
            get: () => reactiveState[ name ],
            set: val => { reactiveState[ name ] = val; }
          };
        });

        Object.defineProperties(plugin, props);
        return plugin
      };

  const listenOpts = {
    hasPassive: false,
    passiveCapture: true,
    notPassiveCapture: true
  };

  try {
    const opts = Object.defineProperty({}, 'passive', {
      get () {
        Object.assign(listenOpts, {
          hasPassive: true,
          passive: { passive: true },
          notPassive: { passive: false },
          passiveCapture: { passive: true, capture: true },
          notPassiveCapture: { passive: false, capture: true }
        });
      }
    });
    window.addEventListener('qtest', null, opts);
    window.removeEventListener('qtest', null, opts);
  }
  catch (e) {}

  function noop () {}

  function leftClick (e) {
    return e.button === 0
  }

  function middleClick (e) {
    return e.button === 1
  }

  function rightClick (e) {
    return e.button === 2
  }

  function position (e) {
    if (e.touches && e.touches[ 0 ]) {
      e = e.touches[ 0 ];
    }
    else if (e.changedTouches && e.changedTouches[ 0 ]) {
      e = e.changedTouches[ 0 ];
    }
    else if (e.targetTouches && e.targetTouches[ 0 ]) {
      e = e.targetTouches[ 0 ];
    }

    return {
      top: e.clientY,
      left: e.clientX
    }
  }

  function getEventPath (e) {
    if (e.path) {
      return e.path
    }
    if (e.composedPath) {
      return e.composedPath()
    }

    const path = [];
    let el = e.target;

    while (el) {
      path.push(el);

      if (el.tagName === 'HTML') {
        path.push(document);
        path.push(window);
        return path
      }

      el = el.parentElement;
    }
  }

  // Reasonable defaults
  const
    LINE_HEIGHT = 40,
    PAGE_HEIGHT = 800;

  function getMouseWheelDistance (e) {
    let x = e.deltaX, y = e.deltaY;

    if ((x || y) && e.deltaMode) {
      const multiplier = e.deltaMode === 1 ? LINE_HEIGHT : PAGE_HEIGHT;
      x *= multiplier;
      y *= multiplier;
    }

    if (e.shiftKey && !x) {
      [ y, x ] = [ x, y ];
    }

    return { x, y }
  }

  function stop (e) {
    e.stopPropagation();
  }

  function prevent (e) {
    e.cancelable !== false && e.preventDefault();
  }

  function stopAndPrevent (e) {
    e.cancelable !== false && e.preventDefault();
    e.stopPropagation();
  }

  function preventDraggable (el, status) {
    if (el === void 0 || (status === true && el.__dragPrevented === true)) {
      return
    }

    const fn = status === true
      ? el => {
          el.__dragPrevented = true;
          el.addEventListener('dragstart', prevent, listenOpts.notPassiveCapture);
        }
      : el => {
        delete el.__dragPrevented;
        el.removeEventListener('dragstart', prevent, listenOpts.notPassiveCapture);
      };

    el.querySelectorAll('a, img').forEach(fn);
  }

  function addEvt (ctx, targetName, events) {
    const name = `__q_${ targetName }_evt`;

    ctx[ name ] = ctx[ name ] !== void 0
      ? ctx[ name ].concat(events)
      : events;

    events.forEach(evt => {
      evt[ 0 ].addEventListener(evt[ 1 ], ctx[ evt[ 2 ] ], listenOpts[ evt[ 3 ] ]);
    });
  }

  function cleanEvt (ctx, targetName) {
    const name = `__q_${ targetName }_evt`;

    if (ctx[ name ] !== void 0) {
      ctx[ name ].forEach(evt => {
        evt[ 0 ].removeEventListener(evt[ 1 ], ctx[ evt[ 2 ] ], listenOpts[ evt[ 3 ] ]);
      });
      ctx[ name ] = void 0;
    }
  }

  /*
   * also update /types/utils/event.d.ts
   */

  var event = {
    listenOpts,
    leftClick,
    middleClick,
    rightClick,
    position,
    getEventPath,
    getMouseWheelDistance,
    stop,
    prevent,
    stopAndPrevent,
    preventDraggable
  };

  function debounce (fn, wait = 250, immediate) {
    let timeout;

    function debounced (/* ...args */) {
      const args = arguments;

      const later = () => {
        timeout = void 0;
        if (immediate !== true) {
          fn.apply(this, args);
        }
      };

      clearTimeout(timeout);
      if (immediate === true && timeout === void 0) {
        fn.apply(this, args);
      }
      timeout = setTimeout(later, wait);
    }

    debounced.cancel = () => {
      clearTimeout(timeout);
    };

    return debounced
  }

  const SIZE_LIST = [ 'sm', 'md', 'lg', 'xl' ];
  const { passive: passive$3 } = listenOpts;

  var Screen = defineReactivePlugin({
    width: 0,
    height: 0,
    name: 'xs',

    sizes: {
      sm: 600,
      md: 1024,
      lg: 1440,
      xl: 1920
    },

    lt: {
      sm: true,
      md: true,
      lg: true,
      xl: true
    },
    gt: {
      xs: false,
      sm: false,
      md: false,
      lg: false
    },

    xs: true,
    sm: false,
    md: false,
    lg: false,
    xl: false
  }, {
    setSizes: noop,
    setDebounce: noop,

    install ({ $q, onSSRHydrated }) {
      $q.screen = this;

      if (this.__installed === true) {
        if ($q.config.screen !== void 0) {
          if ($q.config.screen.bodyClasses === false) {
            document.body.classList.remove(`screen--${ this.name }`);
          }
          else {
            this.__update(true);
          }
        }
        return
      }

      const classes = $q.config.screen !== void 0 && $q.config.screen.bodyClasses === true;

      this.__update = force => {
        const
          w = window.innerWidth,
          h = window.innerHeight;

        if (h !== this.height) {
          this.height = h;
        }

        if (w !== this.width) {
          this.width = w;
        }
        else if (force !== true) {
          return
        }

        let s = this.sizes;

        this.gt.xs = w >= s.sm;
        this.gt.sm = w >= s.md;
        this.gt.md = w >= s.lg;
        this.gt.lg = w >= s.xl;
        this.lt.sm = w < s.sm;
        this.lt.md = w < s.md;
        this.lt.lg = w < s.lg;
        this.lt.xl = w < s.xl;
        this.xs = this.lt.sm;
        this.sm = this.gt.xs === true && this.lt.md === true;
        this.md = this.gt.sm === true && this.lt.lg === true;
        this.lg = this.gt.md === true && this.lt.xl === true;
        this.xl = this.gt.lg;

        s = (this.xs === true && 'xs')
          || (this.sm === true && 'sm')
          || (this.md === true && 'md')
          || (this.lg === true && 'lg')
          || 'xl';

        if (s !== this.name) {
          if (classes === true) {
            document.body.classList.remove(`screen--${ this.name }`);
            document.body.classList.add(`screen--${ s }`);
          }
          this.name = s;
        }
      };

      let updateEvt, updateSizes = {}, updateDebounce = 16;

      this.setSizes = sizes => {
        SIZE_LIST.forEach(name => {
          if (sizes[ name ] !== void 0) {
            updateSizes[ name ] = sizes[ name ];
          }
        });
      };
      this.setDebounce = deb => {
        updateDebounce = deb;
      };

      const start = () => {
        const
          style = getComputedStyle(document.body),
          target = window.visualViewport !== void 0
            ? window.visualViewport
            : window;

        // if css props available
        if (style.getPropertyValue('--q-size-sm')) {
          SIZE_LIST.forEach(name => {
            this.sizes[ name ] = parseInt(style.getPropertyValue(`--q-size-${ name }`), 10);
          });
        }

        this.setSizes = sizes => {
          SIZE_LIST.forEach(name => {
            if (sizes[ name ]) {
              this.sizes[ name ] = sizes[ name ];
            }
          });
          this.__update(true);
        };

        this.setDebounce = delay => {
          updateEvt !== void 0 && target.removeEventListener('resize', updateEvt, passive$3);
          updateEvt = delay > 0
            ? debounce(this.__update, delay)
            : this.__update;
          target.addEventListener('resize', updateEvt, passive$3);
        };

        this.setDebounce(updateDebounce);

        if (Object.keys(updateSizes).length > 0) {
          this.setSizes(updateSizes);
          updateSizes = void 0; // free up memory
        }
        else {
          this.__update();
        }

        // due to optimizations, this would be left out otherwise
        classes === true && this.name === 'xs'
          && document.body.classList.add('screen--xs');
      };

      if (isRuntimeSsrPreHydration.value === true) {
        onSSRHydrated.push(start);
      }
      else {
        start();
      }
    }
  });

  const Plugin$8 = defineReactivePlugin({
    isActive: false,
    mode: false
  }, {
    __media: void 0,

    set (val) {

      Plugin$8.mode = val;

      if (val === 'auto') {
        if (Plugin$8.__media === void 0) {
          Plugin$8.__media = window.matchMedia('(prefers-color-scheme: dark)');
          Plugin$8.__updateMedia = () => { Plugin$8.set('auto'); };
          Plugin$8.__media.addListener(Plugin$8.__updateMedia);
        }

        val = Plugin$8.__media.matches;
      }
      else if (Plugin$8.__media !== void 0) {
        Plugin$8.__media.removeListener(Plugin$8.__updateMedia);
        Plugin$8.__media = void 0;
      }

      Plugin$8.isActive = val === true;

      document.body.classList.remove(`body--${ val === true ? 'light' : 'dark' }`);
      document.body.classList.add(`body--${ val === true ? 'dark' : 'light' }`);
    },

    toggle () {
      {
        Plugin$8.set(Plugin$8.isActive === false);
      }
    },

    install ({ $q, onSSRHydrated, ssrContext }) {
      const { dark } = $q.config;

      $q.dark = this;

      if (this.__installed === true && dark === void 0) {
        return
      }

      this.isActive = dark === true;

      const initialVal = dark !== void 0 ? dark : false;

      if (isRuntimeSsrPreHydration.value === true) {
        const ssrSet = val => {
          this.__fromSSR = val;
        };

        const originalSet = this.set;

        this.set = ssrSet;
        ssrSet(initialVal);

        onSSRHydrated.push(() => {
          this.set = originalSet;
          this.set(this.__fromSSR);
        });
      }
      else {
        this.set(initialVal);
      }
    }
  });

  const getTrue = () => true;

  function filterInvalidPath (path) {
    return typeof path === 'string'
      && path !== ''
      && path !== '/'
      && path !== '#/'
  }

  function normalizeExitPath (path) {
    path.startsWith('#') === true && (path = path.substr(1));
    path.startsWith('/') === false && (path = '/' + path);
    path.endsWith('/') === true && (path = path.substr(0, path.length - 1));
    return '#' + path
  }

  function getShouldExitFn (cfg) {
    if (cfg.backButtonExit === false) {
      return () => false
    }

    if (cfg.backButtonExit === '*') {
      return getTrue
    }

    // Add default root path
    const exitPaths = [ '#/' ];

    // Add custom exit paths
    Array.isArray(cfg.backButtonExit) === true && exitPaths.push(
      ...cfg.backButtonExit.filter(filterInvalidPath).map(normalizeExitPath)
    );

    return () => exitPaths.includes(window.location.hash)
  }

  var History = {
    __history: [],
    add: noop,
    remove: noop,

    install ({ $q }) {
      if (this.__installed === true) { return }

      const { cordova, capacitor } = client.is;

      if (cordova !== true && capacitor !== true) {
        return
      }

      const qConf = $q.config[ cordova === true ? 'cordova' : 'capacitor' ];

      if (qConf !== void 0 && qConf.backButton === false) {
        return
      }

      // if the '@capacitor/app' plugin is not installed
      // then we got nothing to do
      if (
        // if we're on Capacitor mode
        capacitor === true
        // and it's also not in Capacitor's main instance
        && (window.Capacitor === void 0 || window.Capacitor.Plugins.App === void 0)
      ) {
        return
      }

      this.add = entry => {
        if (entry.condition === void 0) {
          entry.condition = getTrue;
        }
        this.__history.push(entry);
      };

      this.remove = entry => {
        const index = this.__history.indexOf(entry);
        if (index >= 0) {
          this.__history.splice(index, 1);
        }
      };

      const shouldExit = getShouldExitFn(
        Object.assign(
          { backButtonExit: true },
          qConf
        )
      );

      const backHandler = () => {
        if (this.__history.length) {
          const entry = this.__history[ this.__history.length - 1 ];

          if (entry.condition() === true) {
            this.__history.pop();
            entry.handler();
          }
        }
        else if (shouldExit() === true) {
          navigator.app.exitApp();
        }
        else {
          window.history.back();
        }
      };

      if (cordova === true) {
        document.addEventListener('deviceready', () => {
          document.addEventListener('backbutton', backHandler, false);
        });
      }
      else {
        window.Capacitor.Plugins.App.addListener('backButton', backHandler);
      }
    }
  };

  var langEn = {
    isoName: 'en-US',
    nativeName: 'English (US)',
    label: {
      clear: 'Clear',
      ok: 'OK',
      cancel: 'Cancel',
      close: 'Close',
      set: 'Set',
      select: 'Select',
      reset: 'Reset',
      remove: 'Remove',
      update: 'Update',
      create: 'Create',
      search: 'Search',
      filter: 'Filter',
      refresh: 'Refresh'
    },
    date: {
      days: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
      daysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
      months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
      monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
      firstDayOfWeek: 0, // 0-6, 0 - Sunday, 1 Monday, ...
      format24h: false,
      pluralDay: 'days'
    },
    table: {
      noData: 'No data available',
      noResults: 'No matching records found',
      loading: 'Loading...',
      selectedRecords: rows => (
        rows === 1
          ? '1 record selected.'
          : (rows === 0 ? 'No' : rows) + ' records selected.'
      ),
      recordsPerPage: 'Records per page:',
      allRows: 'All',
      pagination: (start, end, total) => start + '-' + end + ' of ' + total,
      columns: 'Columns'
    },
    editor: {
      url: 'URL',
      bold: 'Bold',
      italic: 'Italic',
      strikethrough: 'Strikethrough',
      underline: 'Underline',
      unorderedList: 'Unordered List',
      orderedList: 'Ordered List',
      subscript: 'Subscript',
      superscript: 'Superscript',
      hyperlink: 'Hyperlink',
      toggleFullscreen: 'Toggle Fullscreen',
      quote: 'Quote',
      left: 'Left align',
      center: 'Center align',
      right: 'Right align',
      justify: 'Justify align',
      print: 'Print',
      outdent: 'Decrease indentation',
      indent: 'Increase indentation',
      removeFormat: 'Remove formatting',
      formatting: 'Formatting',
      fontSize: 'Font Size',
      align: 'Align',
      hr: 'Insert Horizontal Rule',
      undo: 'Undo',
      redo: 'Redo',
      heading1: 'Heading 1',
      heading2: 'Heading 2',
      heading3: 'Heading 3',
      heading4: 'Heading 4',
      heading5: 'Heading 5',
      heading6: 'Heading 6',
      paragraph: 'Paragraph',
      code: 'Code',
      size1: 'Very small',
      size2: 'A bit small',
      size3: 'Normal',
      size4: 'Medium-large',
      size5: 'Big',
      size6: 'Very big',
      size7: 'Maximum',
      defaultFont: 'Default Font',
      viewSource: 'View Source'
    },
    tree: {
      noNodes: 'No nodes available',
      noResults: 'No matching nodes found'
    }
  };

  function getLocale () {

    const val = Array.isArray(navigator.languages) === true && navigator.languages.length > 0
      ? navigator.languages[ 0 ]
      : navigator.language;

    if (typeof val === 'string') {
      return val.split(/[-_]/).map((v, i) => (
        i === 0
          ? v.toLowerCase()
          : (
              i > 1 || v.length < 4
                ? v.toUpperCase()
                : (v[ 0 ].toUpperCase() + v.slice(1).toLowerCase())
            )
      )).join('-')
    }
  }

  const Plugin$7 = defineReactivePlugin({
    __langPack: {}
  }, {
    getLocale,

    set (langObject = langEn, ssrContext) {
      const lang = {
        ...langObject,
        rtl: langObject.rtl === true,
        getLocale
      };

      {
        const el = document.documentElement;
        el.setAttribute('dir', lang.rtl === true ? 'rtl' : 'ltr');
        el.setAttribute('lang', lang.isoName);

        lang.set = Plugin$7.set;

        Object.assign(Plugin$7.__langPack, lang);

        Plugin$7.props = lang;
        Plugin$7.isoName = lang.isoName;
        Plugin$7.nativeName = lang.nativeName;
      }
    },

    install ({ $q, lang, ssrContext }) {
      {
        $q.lang = Plugin$7.__langPack;

        if (this.__installed === true) {
          lang !== void 0 && this.set(lang);
        }
        else {
          this.set(lang || langEn);
        }
      }
    }
  });

  function setCssVar (propName, value, element = document.body) {
    if (typeof propName !== 'string') {
      throw new TypeError('Expected a string as propName')
    }
    if (typeof value !== 'string') {
      throw new TypeError('Expected a string as value')
    }
    if (!(element instanceof Element)) {
      throw new TypeError('Expected a DOM element')
    }

    element.style.setProperty(`--q-${ propName }`, value);
  }

  let lastKeyCompositionStatus = false;

  function onKeyDownComposition (evt) {
    lastKeyCompositionStatus = evt.isComposing === true;
  }

  function shouldIgnoreKey (evt) {
    return lastKeyCompositionStatus === true
      || evt !== Object(evt)
      || evt.isComposing === true
      || evt.qKeyEvent === true
  }

  function isKeyCode (evt, keyCodes) {
    return shouldIgnoreKey(evt) === true
      ? false
      : [].concat(keyCodes).includes(evt.keyCode)
  }

  function getMobilePlatform (is) {
    if (is.ios === true) return 'ios'
    if (is.android === true) return 'android'
  }

  function getBodyClasses ({ is, has, within }, cfg) {
    const cls = [
      is.desktop === true ? 'desktop' : 'mobile',
      `${ has.touch === false ? 'no-' : '' }touch`
    ];

    if (is.mobile === true) {
      const mobile = getMobilePlatform(is);
      mobile !== void 0 && cls.push('platform-' + mobile);
    }

    if (is.nativeMobile === true) {
      const type = is.nativeMobileWrapper;

      cls.push(type);
      cls.push('native-mobile');

      if (
        is.ios === true
        && (cfg[ type ] === void 0 || cfg[ type ].iosStatusBarPadding !== false)
      ) {
        cls.push('q-ios-padding');
      }
    }
    else if (is.electron === true) {
      cls.push('electron');
    }
    else if (is.bex === true) {
      cls.push('bex');
    }

    within.iframe === true && cls.push('within-iframe');

    return cls
  }

  function applyClientSsrCorrections () {
    const classes = document.body.className;
    let newCls = classes;

    if (iosCorrection !== void 0) {
      newCls = newCls.replace('desktop', 'platform-ios mobile');
    }

    if (client.has.touch === true) {
      newCls = newCls.replace('no-touch', 'touch');
    }

    if (client.within.iframe === true) {
      newCls += ' within-iframe';
    }

    if (classes !== newCls) {
      document.body.className = newCls;
    }
  }

  function setColors (brand) {
    for (const color in brand) {
      setCssVar(color, brand[ color ]);
    }
  }

  var Body = {
    install (opts) {

      const { $q } = opts;

      $q.config.brand !== void 0 && setColors($q.config.brand);

      if (this.__installed === true) { return }

      if (isRuntimeSsrPreHydration.value === true) {
        applyClientSsrCorrections();
      }
      else {
        const cls = getBodyClasses(client, $q.config);
        document.body.classList.add.apply(document.body.classList, cls);
      }

      if (client.is.ios === true) {
        // needed for iOS button active state
        document.body.addEventListener('touchstart', noop);
      }

      window.addEventListener('keydown', onKeyDownComposition, true);
    }
  };

  var materialIcons = {
    name: 'material-icons',
    type: {
      positive: 'check_circle',
      negative: 'warning',
      info: 'info',
      warning: 'priority_high'
    },
    arrow: {
      up: 'arrow_upward',
      right: 'arrow_forward',
      down: 'arrow_downward',
      left: 'arrow_back',
      dropdown: 'arrow_drop_down'
    },
    chevron: {
      left: 'chevron_left',
      right: 'chevron_right'
    },
    colorPicker: {
      spectrum: 'gradient',
      tune: 'tune',
      palette: 'style'
    },
    pullToRefresh: {
      icon: 'refresh'
    },
    carousel: {
      left: 'chevron_left',
      right: 'chevron_right',
      up: 'keyboard_arrow_up',
      down: 'keyboard_arrow_down',
      navigationIcon: 'lens'
    },
    chip: {
      remove: 'cancel',
      selected: 'check'
    },
    datetime: {
      arrowLeft: 'chevron_left',
      arrowRight: 'chevron_right',
      now: 'access_time',
      today: 'today'
    },
    editor: {
      bold: 'format_bold',
      italic: 'format_italic',
      strikethrough: 'strikethrough_s',
      underline: 'format_underlined',
      unorderedList: 'format_list_bulleted',
      orderedList: 'format_list_numbered',
      subscript: 'vertical_align_bottom',
      superscript: 'vertical_align_top',
      hyperlink: 'link',
      toggleFullscreen: 'fullscreen',
      quote: 'format_quote',
      left: 'format_align_left',
      center: 'format_align_center',
      right: 'format_align_right',
      justify: 'format_align_justify',
      print: 'print',
      outdent: 'format_indent_decrease',
      indent: 'format_indent_increase',
      removeFormat: 'format_clear',
      formatting: 'text_format',
      fontSize: 'format_size',
      align: 'format_align_left',
      hr: 'remove',
      undo: 'undo',
      redo: 'redo',
      heading: 'format_size',
      code: 'code',
      size: 'format_size',
      font: 'font_download',
      viewSource: 'code'
    },
    expansionItem: {
      icon: 'keyboard_arrow_down',
      denseIcon: 'arrow_drop_down'
    },
    fab: {
      icon: 'add',
      activeIcon: 'close'
    },
    field: {
      clear: 'cancel',
      error: 'error'
    },
    pagination: {
      first: 'first_page',
      prev: 'keyboard_arrow_left',
      next: 'keyboard_arrow_right',
      last: 'last_page'
    },
    rating: {
      icon: 'grade'
    },
    stepper: {
      done: 'check',
      active: 'edit',
      error: 'warning'
    },
    tabs: {
      left: 'chevron_left',
      right: 'chevron_right',
      up: 'keyboard_arrow_up',
      down: 'keyboard_arrow_down'
    },
    table: {
      arrowUp: 'arrow_upward',
      warning: 'warning',
      firstPage: 'first_page',
      prevPage: 'chevron_left',
      nextPage: 'chevron_right',
      lastPage: 'last_page'
    },
    tree: {
      icon: 'play_arrow'
    },
    uploader: {
      done: 'done',
      clear: 'clear',
      add: 'add_box',
      upload: 'cloud_upload',
      removeQueue: 'clear_all',
      removeUploaded: 'done_all'
    }
  };

  const Plugin$6 = defineReactivePlugin({
    iconMapFn: null,
    __icons: {}
  }, {
    set (setObject, ssrContext) {
      const def = { ...setObject, rtl: setObject.rtl === true };

      {
        def.set = Plugin$6.set;
        Object.assign(Plugin$6.__icons, def);
      }
    },

    install ({ $q, iconSet, ssrContext }) {
      {
        if ($q.config.iconMapFn !== void 0) {
          this.iconMapFn = $q.config.iconMapFn;
        }

        $q.iconSet = this.__icons;

        Object.defineProperty($q, 'iconMapFn', {
          get: () => this.iconMapFn,
          set: val => { this.iconMapFn = val; }
        });

        if (this.__installed === true) {
          iconSet !== void 0 && this.set(iconSet);
        }
        else {
          this.set(iconSet || materialIcons);
        }
      }
    }
  });

  const quasarKey = '_q_';
  const timelineKey = '_q_t_';
  const stepperKey = '_q_s_';
  const layoutKey = '_q_l_';
  const pageContainerKey = '_q_pc_';
  const fabKey = '_q_f_';
  const formKey = '_q_fo_';
  const tabsKey = '_q_tabs_';
  const uploaderKey = '_q_u_';

  const globalConfig = {};
  let globalConfigIsFrozen = false;

  function freezeGlobalConfig () {
    globalConfigIsFrozen = true;
  }

  const autoInstalledPlugins = [
    Platform,
    Body,
    Plugin$8,
    Screen,
    History,
    Plugin$7,
    Plugin$6
  ];

  function createChildApp (appCfg, parentApp) {
    const app = vue.createApp(appCfg);

    app.config.globalProperties = parentApp.config.globalProperties;

    const { reload, ...appContext } = parentApp._context;
    Object.assign(app._context, appContext);

    return app
  }

  function installPlugins (pluginOpts, pluginList) {
    pluginList.forEach(Plugin => {
      Plugin.install(pluginOpts);
      Plugin.__installed = true;
    });
  }

  function prepareApp (app, uiOpts, pluginOpts) {
    app.config.globalProperties.$q = pluginOpts.$q;
    app.provide(quasarKey, pluginOpts.$q);

    installPlugins(pluginOpts, autoInstalledPlugins);

    uiOpts.components !== void 0 && Object.values(uiOpts.components).forEach(c => {
      if (Object(c) === c && c.name !== void 0) {
        app.component(c.name, c);
      }
    });

    uiOpts.directives !== void 0 && Object.values(uiOpts.directives).forEach(d => {
      if (Object(d) === d && d.name !== void 0) {
        app.directive(d.name, d);
      }
    });

    uiOpts.plugins !== void 0 && installPlugins(
      pluginOpts,
      Object.values(uiOpts.plugins).filter(
        p => typeof p.install === 'function' && autoInstalledPlugins.includes(p) === false
      )
    );

    if (isRuntimeSsrPreHydration.value === true) {
      pluginOpts.$q.onSSRHydrated = () => {
        pluginOpts.onSSRHydrated.forEach(fn => { fn(); });
        pluginOpts.$q.onSSRHydrated = () => {};
      };
    }
  }

  var installQuasar = function (parentApp, opts = {}) {
      const $q = { version: '2.0.0-beta.19' };

      if (globalConfigIsFrozen === false) {
        if (opts.config !== void 0) {
          Object.assign(globalConfig, opts.config);
        }

        $q.config = { ...globalConfig };
        freezeGlobalConfig();
      }
      else {
        $q.config = opts.config || {};
      }

      prepareApp(parentApp, opts, {
        parentApp,
        $q,
        lang: opts.lang,
        iconSet: opts.iconSet,
        onSSRHydrated: []
      });
    };

  const units = [ 'B', 'KB', 'MB', 'GB', 'TB', 'PB' ];

  function humanStorageSize (bytes) {
    let u = 0;

    while (parseInt(bytes, 10) >= 1024 && u < units.length - 1) {
      bytes /= 1024;
      ++u;
    }

    return `${ bytes.toFixed(1) }${ units[ u ] }`
  }

  function capitalize (str) {
    return str.charAt(0).toUpperCase() + str.slice(1)
  }

  function between (v, min, max) {
    return max <= min
      ? min
      : Math.min(max, Math.max(min, v))
  }

  function normalizeToInterval (v, min, max) {
    if (max <= min) {
      return min
    }

    const size = (max - min + 1);

    let index = min + (v - min) % size;
    if (index < min) {
      index = size + index;
    }

    return index === 0 ? 0 : index // fix for (-a % a) => -0
  }

  function pad (v, length = 2, char = '0') {
    if (v === void 0 || v === null) {
      return v
    }

    const val = '' + v;
    return val.length >= length
      ? val
      : new Array(length - val.length + 1).join(char) + val
  }

  var format = {
    humanStorageSize,
    capitalize,
    between,
    normalizeToInterval,
    pad
  };

  const
    xhr = XMLHttpRequest,
    send = xhr.prototype.send,
    stackStart = [],
    stackStop = [];

  let highjackCount = 0;

  function translate ({ p, pos, active, horiz, reverse, dir }) {
    let x = 1, y = 1;

    if (horiz) {
      if (reverse) { x = -1; }
      if (pos === 'bottom') { y = -1; }
      return { transform: `translate3d(${ x * (p - 100) }%,${ active ? 0 : y * -200 }%,0)` }
    }

    if (reverse) { y = -1; }
    if (pos === 'right') { x = -1; }
    return { transform: `translate3d(${ active ? 0 : dir * x * -200 }%,${ y * (p - 100) }%,0)` }
  }

  function inc (p, amount) {
    if (typeof amount !== 'number') {
      if (p < 25) {
        amount = Math.random() * 3 + 3;
      }
      else if (p < 65) {
        amount = Math.random() * 3;
      }
      else if (p < 85) {
        amount = Math.random() * 2;
      }
      else if (p < 99) {
        amount = 0.6;
      }
      else {
        amount = 0;
      }
    }
    return between(p + amount, 0, 100)
  }

  function highjackAjax (start, stop) {
    stackStart.push(start);
    stackStop.push(stop);

    highjackCount++;

    if (highjackCount > 1) { return }

    function endHandler () {
      stackStop.forEach(fn => { fn(); });
    }

    xhr.prototype.send = function (/* ...args */) {
      stackStart.forEach(fn => { fn(); });
      this.addEventListener('loadend', endHandler, false);
      send.apply(this, arguments);
    };
  }

  function restoreAjax (start, stop) {
    stackStart.splice(stackStart.indexOf(start), 1);
    stackStop.splice(stackStop.indexOf(stop), 1);

    highjackCount = Math.max(0, highjackCount - 1);
    if (highjackCount === 0) {
      xhr.prototype.send = send;
    }
  }

  var QAjaxBar = vue.defineComponent({
    name: 'QAjaxBar',

    props: {
      position: {
        type: String,
        default: 'top',
        validator: val => [ 'top', 'right', 'bottom', 'left' ].includes(val)
      },
      size: {
        type: String,
        default: '2px'
      },
      color: String,
      skipHijack: Boolean,
      reverse: Boolean
    },

    emits: [ 'start', 'stop' ],

    setup (props, { emit }) {
      const { proxy } = vue.getCurrentInstance();

      const progress = vue.ref(0);
      const onScreen = vue.ref(false);
      const animate = vue.ref(true);

      let calls = 0, timer, speed;

      const classes = vue.computed(() =>
        `q-loading-bar q-loading-bar--${ props.position }`
        + (props.color !== void 0 ? ` bg-${ props.color }` : '')
        + (animate.value === true ? '' : ' no-transition')
      );

      const horizontal = vue.computed(() => props.position === 'top' || props.position === 'bottom');
      const sizeProp = vue.computed(() => (horizontal.value === true ? 'height' : 'width'));

      const style = vue.computed(() => {
        const active = onScreen.value;

        const obj = translate({
          p: progress.value,
          pos: props.position,
          active,
          horiz: horizontal.value,
          reverse: proxy.$q.lang.rtl === true && [ 'top', 'bottom' ].includes(props.position)
            ? !props.reverse
            : props.reverse,
          dir: proxy.$q.lang.rtl === true ? -1 : 1
        });

        obj[ sizeProp.value ] = props.size;
        obj.opacity = active ? 1 : 0;

        return obj
      });

      const attributes = vue.computed(() => (
        onScreen.value === true
          ? {
              role: 'progressbar',
              'aria-valuemin': 0,
              'aria-valuemax': 100,
              'aria-valuenow': progress.value
            }
          : { 'aria-hidden': 'true' }
      ));

      function start (newSpeed = 300) {
        const oldSpeed = speed;
        speed = Math.max(0, newSpeed) || 0;

        calls++;

        if (calls > 1) {
          if (oldSpeed === 0 && newSpeed > 0) {
            planNextStep();
          }
          else if (oldSpeed > 0 && newSpeed <= 0) {
            clearTimeout(timer);
          }
          return
        }

        clearTimeout(timer);
        emit('start');

        progress.value = 0;

        if (onScreen.value === true) { return }

        onScreen.value = true;
        animate.value = false;
        timer = setTimeout(() => {
          animate.value = true;
          newSpeed > 0 && planNextStep();
        }, 100);
      }

      function increment (amount) {
        if (calls > 0) {
          progress.value = inc(progress.value, amount);
        }
      }

      function stop () {
        calls = Math.max(0, calls - 1);
        if (calls > 0) { return }

        clearTimeout(timer);
        emit('stop');

        const end = () => {
          animate.value = true;
          progress.value = 100;
          timer = setTimeout(() => {
            onScreen.value = false;
          }, 1000);
        };

        if (progress.value === 0) {
          timer = setTimeout(end, 1);
        }
        else {
          end();
        }
      }

      function planNextStep () {
        if (progress.value < 100) {
          timer = setTimeout(() => {
            increment();
            planNextStep();
          }, speed);
        }
      }

      let hijacked;

      vue.onMounted(() => {
        if (props.skipHijack !== true) {
          hijacked = true;
          highjackAjax(start, stop);
        }
      });

      vue.onBeforeUnmount(() => {
        clearTimeout(timer);
        hijacked === true && restoreAjax(start, stop);
      });

      // expose public methods
      Object.assign(proxy, { start, stop, increment });

      return () => vue.h('div', {
        class: classes.value,
        style: style.value,
        ...attributes.value
      })
    }
  });

  const useSizeDefaults = {
    xs: 18,
    sm: 24,
    md: 32,
    lg: 38,
    xl: 46
  };

  const useSizeProps = {
    size: String
  };

  function useSize (props, sizes = useSizeDefaults) {
    // return sizeStyle
    return vue.computed(() => (
      props.size !== void 0
        ? { fontSize: props.size in sizes ? `${ sizes[ props.size ] }px` : props.size }
        : null
    ))
  }

  function hSlot (slot, otherwise) {
    return slot !== void 0
      ? slot()
      : otherwise
  }

  function hUniqueSlot (slot, otherwise) {
    return slot !== void 0
      ? slot().slice()
      : otherwise
  }

  /**
   * Source definitely exists,
   * so it's merged with the possible slot
   */
  function hMergeSlot (slot, source) {
    return slot !== void 0
      ? source.concat(slot())
      : source
  }

  /**
   * Merge with possible slot,
   * even if source might not exist
   */
  function hMergeSlotSafely (slot, source) {
    if (slot === void 0) {
      return source
    }

    return source !== void 0
      ? source.concat(slot())
      : slot()
  }

  /*
   * (String)  key       - unique vnode key
   * (Boolean) condition - should change ONLY when adding/removing directive
   */
  function hDir (
    tag,
    data,
    children,
    key,
    condition,
    getDirsFn
  ) {
    data.key = key + condition;

    const vnode = vue.h(tag, data, children);

    return condition === true
      ? vue.withDirectives(vnode, getDirsFn())
      : vnode
  }

  const sameFn = i => i;
  const ionFn = i => `ionicons ${ i }`;

  const libMap = {
    'icon-': sameFn, // fontawesome equiv
    'bt-': i => `bt ${ i }`,
    'eva-': i => `eva ${ i }`,
    'ion-md': ionFn,
    'ion-ios': ionFn,
    'ion-logo': ionFn,
    'mdi-': i => `mdi ${ i }`,
    'iconfont ': sameFn,
    'ti-': i => `themify-icon ${ i }`,
    'bi-': i => `bootstrap-icons ${ i }`
  };

  const matMap = {
    o_: '-outlined',
    r_: '-round',
    s_: '-sharp'
  };

  const libRE = new RegExp('^(' + Object.keys(libMap).join('|') + ')');
  const matRE = new RegExp('^(' + Object.keys(matMap).join('|') + ')');
  const mRE = /^M/;
  const imgRE = /^img:/;
  const svgUseRE = /^svguse:/;
  const ionRE = /^ion-/;
  const faLaRE = /^[l|f]a[s|r|l|b|d]? /;

  var QIcon = vue.defineComponent({
    name: 'QIcon',

    props: {
      ...useSizeProps,

      tag: {
        type: String,
        default: 'i'
      },

      name: String,
      color: String,
      left: Boolean,
      right: Boolean
    },

    setup (props, { slots }) {
      const { proxy: { $q } } = vue.getCurrentInstance();
      const sizeStyle = useSize(props);

      const classes = vue.computed(() =>
        'q-icon'
        + (props.left === true ? ' on-left' : '')
        + (props.right === true ? ' on-right' : '')
        + (props.color !== void 0 ? ` text-${ props.color }` : '')
      );

      const type = vue.computed(() => {
        let cls;
        let icon = props.name;

        if (!icon) {
          return {
            none: true,
            cls: classes.value
          }
        }

        if ($q.iconMapFn !== null) {
          const res = $q.iconMapFn(icon);
          if (res !== void 0) {
            if (res.icon !== void 0) {
              icon = res.icon;
            }
            else {
              return {
                cls: res.cls + ' ' + classes.value,
                content: res.content !== void 0
                  ? res.content
                  : ' '
              }
            }
          }
        }

        if (mRE.test(icon) === true) {
          const [ def, viewBox ] = icon.split('|');

          return {
            svg: true,
            cls: classes.value,
            nodes: def.split('&&').map(path => {
              const [ d, style, transform ] = path.split('@@');
              return vue.h('path', {
                style,
                d,
                transform
              })
            }),
            viewBox: viewBox !== void 0 ? viewBox : '0 0 24 24'
          }
        }

        if (imgRE.test(icon) === true) {
          return {
            img: true,
            cls: classes.value,
            src: icon.substring(4)
          }
        }

        if (svgUseRE.test(icon) === true) {
          const [ def, viewBox ] = icon.split('|');

          return {
            svguse: true,
            cls: classes.value,
            src: def.substring(7),
            viewBox: viewBox !== void 0 ? viewBox : '0 0 24 24'
          }
        }

        let content = ' ';
        const matches = icon.match(libRE);

        if (matches !== null) {
          cls = libMap[ matches[ 1 ] ](icon);
        }
        else if (faLaRE.test(icon) === true) {
          cls = icon;
        }
        else if (ionRE.test(icon) === true) {
          cls = `ionicons ion-${ $q.platform.is.ios === true ? 'ios' : 'md' }${ icon.substr(3) }`;
        }
        else {
          // "notranslate" class is for Google Translate
          // to avoid tampering with Material Icons ligature font
          //
          // Caution: To be able to add suffix to the class name,
          // keep the 'material-icons' at the end of the string.
          cls = 'notranslate material-icons';

          const matches = icon.match(matRE);
          if (matches !== null) {
            icon = icon.substring(2);
            cls += matMap[ matches[ 1 ] ];
          }

          content = icon;
        }

        return {
          cls: cls + ' ' + classes.value,
          content
        }
      });

      return () => {
        const data = {
          class: type.value.cls,
          style: sizeStyle.value,
          'aria-hidden': 'true',
          role: 'presentation'
        };

        if (type.value.none === true) {
          return vue.h(props.tag, data, hSlot(slots.default))
        }

        if (type.value.img === true) {
          data.src = type.value.src;
          return vue.h('img', data)
        }

        if (type.value.svg === true) {
          data.viewBox = type.value.viewBox;

          return vue.h('svg', data, hMergeSlot(slots.default, type.value.nodes))
        }

        if (type.value.svguse === true) {
          data.viewBox = type.value.viewBox;

          return vue.h(
            'svg',
            data,
            hMergeSlot(slots.default, [ vue.h('use', { 'xlink:href': type.value.src }) ])
          )
        }

        return vue.h(props.tag, data, hMergeSlot(slots.default, [
          type.value.content
        ]))
      }
    }
  });

  var QAvatar = vue.defineComponent({
    name: 'QAvatar',

    props: {
      ...useSizeProps,

      fontSize: String,

      color: String,
      textColor: String,

      icon: String,
      square: Boolean,
      rounded: Boolean
    },

    setup (props, { slots }) {
      const sizeStyle = useSize(props);

      const classes = vue.computed(() =>
        'q-avatar'
        + (props.color ? ` bg-${ props.color }` : '')
        + (props.textColor ? ` text-${ props.textColor } q-chip--colored` : '')
        + (
          props.square === true
            ? ' q-avatar--square'
            : (props.rounded === true ? ' rounded-borders' : '')
        )
      );

      const contentStyle = vue.computed(() => (
        props.fontSize
          ? { fontSize: props.fontSize }
          : null
      ));

      return () => {
        const icon = props.icon !== void 0
          ? [ vue.h(QIcon, { name: props.icon }) ]
          : void 0;

        return vue.h('div', {
          class: classes.value,
          style: sizeStyle.value
        }, [
          vue.h('div', {
            class: 'q-avatar__content row flex-center overflow-hidden',
            style: contentStyle.value
          }, hMergeSlotSafely(slots.default, icon))
        ])
      }
    }
  });

  const alignValues$3 = [ 'top', 'middle', 'bottom' ];

  var QBadge = vue.defineComponent({
    name: 'QBadge',

    props: {
      color: String,
      textColor: String,

      floating: Boolean,
      transparent: Boolean,
      multiLine: Boolean,
      outline: Boolean,
      rounded: Boolean,

      label: [ Number, String ],

      align: {
        type: String,
        validator: v => alignValues$3.includes(v)
      }
    },

    setup (props, { slots }) {
      const style = vue.computed(() => {
        return props.align !== void 0
          ? { verticalAlign: props.align }
          : null
      });

      const classes = vue.computed(() => {
        const text = props.outline === true
          ? props.color || props.textColor
          : props.textColor;

        return 'q-badge flex inline items-center no-wrap'
          + ` q-badge--${ props.multiLine === true ? 'multi' : 'single' }-line`
          + (props.outline === true
            ? ' q-badge--outline'
            : (props.color !== void 0 ? ` bg-${ props.color }` : '')
          )
          + (text !== void 0 ? ` text-${ text }` : '')
          + (props.floating === true ? ' q-badge--floating' : '')
          + (props.rounded === true ? ' q-badge--rounded' : '')
          + (props.transparent === true ? ' q-badge--transparent' : '')
      });

      return () => vue.h('div', {
        class: classes.value,
        style: style.value,
        role: 'alert',
        'aria-label': props.label
      }, props.label !== void 0 ? props.label : hSlot(slots.default))
    }
  });

  const useDarkProps = {
    dark: {
      type: Boolean,
      default: null
    }
  };

  function useDark (props, $q) {
    // return isDark
    return vue.computed(() => (
      props.dark === null
        ? $q.dark.isActive
        : props.dark
    ))
  }

  var QBanner = vue.defineComponent({
    name: 'QBanner',

    props: {
      ...useDarkProps,

      inlineActions: Boolean,
      dense: Boolean,
      rounded: Boolean
    },

    setup (props, { slots }) {
      const vm = vue.getCurrentInstance();
      const isDark = useDark(props, vm.proxy.$q);

      const classes = vue.computed(() =>
        'q-banner row items-center'
        + (props.dense === true ? ' q-banner--dense' : '')
        + (isDark.value === true ? ' q-banner--dark q-dark' : '')
        + (props.rounded === true ? ' rounded-borders' : '')
      );

      const actionClass = vue.computed(() =>
        'q-banner__actions row items-center justify-end'
        + ` col-${ props.inlineActions === true ? 'auto' : 'all' }`
      );

      return () => {
        const child = [
          vue.h('div', {
            class: 'q-banner__avatar col-auto row items-center self-start'
          }, hSlot(slots.avatar)),

          vue.h('div', {
            class: 'q-banner__content col text-body2'
          }, hSlot(slots.default))
        ];

        const actions = hSlot(slots.action);
        actions !== void 0 && child.push(
          vue.h('div', { class: actionClass.value }, actions)
        );

        return vue.h('div', {
          class: classes.value
            + (props.inlineActions === false && actions !== void 0 ? ' q-banner--top-padding' : ''),
          role: 'alert'
        }, child)
      }
    }
  });

  var QBar = vue.defineComponent({
    name: 'QBar',

    props: {
      ...useDarkProps,
      dense: Boolean
    },

    setup (props, { slots }) {
      const vm = vue.getCurrentInstance();
      const isDark = useDark(props, vm.proxy.$q);

      const classes = vue.computed(() =>
        'q-bar row no-wrap items-center'
        + ` q-bar--${ props.dense === true ? 'dense' : 'standard' } `
        + ` q-bar--${ isDark.value === true ? 'dark' : 'light' }`
      );

      return () => vue.h('div', {
        class: classes.value,
        role: 'toolbar'
      }, hSlot(slots.default))
    }
  });

  const alignMap = {
    left: 'start',
    center: 'center',
    right: 'end',
    between: 'between',
    around: 'around',
    evenly: 'evenly',
    stretch: 'stretch'
  };

  const alignValues$2 = Object.keys(alignMap);

  const useAlignProps = {
    align: {
      type: String,
      validator: v => alignValues$2.includes(v)
    }
  };

  function useAlign (props) {
    // return alignClass
    return vue.computed(() => {
      const align = props.align === void 0
        ? props.vertical === true ? 'stretch' : 'left'
        : props.align;

      return `${ props.vertical === true ? 'items' : 'justify' }-${ alignMap[ align ] }`
    })
  }

  // used directly by docs too
  function getParentVm (vm) {
    if (vm.$parent !== void 0 && vm.$parent !== null) {
      return vm.$parent
    }

    vm = vm.$.parent;

    while (vm !== void 0 && vm !== null) {
      if (vm.proxy !== void 0 && vm.proxy !== null) {
        return vm.proxy
      }

      vm = vm.parent;
    }
  }

  // vnodes from rendered in advanced slots
  function getNormalizedVNodes (vnodes) {
    const children = new Set();

    vnodes.forEach(vnode => {
      if (typeof vnode.type === 'symbol' && Array.isArray(vnode.children) === true) {
        vnode.children.forEach(child => {
          children.add(child);
        });
      }
      else {
        children.add(vnode);
      }
    });

    return Array.from(children)
  }

  function vmHasRouter (vm) {
    return vm.appContext.config.globalProperties.$router !== void 0
  }

  var QBreadcrumbs = vue.defineComponent({
    name: 'QBreadcrumbs',

    props: {
      ...useAlignProps,

      separator: {
        type: String,
        default: '/'
      },
      separatorColor: String,

      activeColor: {
        type: String,
        default: 'primary'
      },

      gutter: {
        type: String,
        validator: v => [ 'none', 'xs', 'sm', 'md', 'lg', 'xl' ].includes(v),
        default: 'sm'
      }
    },

    setup (props, { slots }) {
      const alignClass = useAlign(props);

      const classes = vue.computed(() =>
        `flex items-center ${ alignClass.value }${ props.gutter === 'none' ? '' : ` q-gutter-${ props.gutter }` }`
      );

      const sepClass = vue.computed(() => (props.separatorColor ? ` text-${ props.separatorColor }` : ''));
      const activeClass = vue.computed(() => `text-${ props.activeColor }`);

      return () => {
        const vnodes = getNormalizedVNodes(
          hSlot(slots.default)
        );

        if (vnodes === void 0) { return }

        let els = 1;

        const
          child = [],
          len = vnodes.filter(c => c.type !== void 0 && c.type.name === 'QBreadcrumbsEl').length,
          separator = slots.separator !== void 0
            ? slots.separator
            : () => props.separator;

        vnodes.forEach(comp => {
          if (comp.type !== void 0 && comp.type.name === 'QBreadcrumbsEl') {
            const middle = els < len;
            els++;

            child.push(
              vue.h('div', {
                class: 'flex items-center '
                  + (middle === true ? activeClass.value : 'q-breadcrumbs--last')
              }, [ comp ])
            );

            if (middle === true) {
              child.push(
                vue.h('div', {
                  class: 'q-breadcrumbs__separator' + sepClass.value
                }, separator())
              );
            }
          }
          else {
            child.push(comp);
          }
        });

        return vue.h('div', {
          class: 'q-breadcrumbs'
        }, [
          vue.h('div', { class: classes.value }, child)
        ])
      }
    }
  });

  /*
   * Inspired by RouterLink from Vue Router
   *  --> API should match!
   */

  // Get the original path value of a record by following its aliasOf
  function getOriginalPath (record) {
    return record
      ? (
          record.aliasOf
            ? record.aliasOf.path
            : record.path
        ) : ''
  }

  function isSameRouteRecord (a, b) {
    // since the original record has an undefined value for aliasOf
    // but all aliases point to the original record, this will always compare
    // the original record
    return (a.aliasOf || a) === (b.aliasOf || b)
  }

  function includesParams (outer, inner) {
    for (const key in inner) {
      const
        innerValue = inner[ key ],
        outerValue = outer[ key ];

      if (typeof innerValue === 'string') {
        if (innerValue !== outerValue) {
          return false
        }
      }
      else if (
        Array.isArray(outerValue) === false
        || outerValue.length !== innerValue.length
        || innerValue.some((value, i) => value !== outerValue[ i ])
      ) {
        return false
      }
    }

    return true
  }

  const useRouterLinkProps = {
    to: [ String, Object ],
    replace: Boolean,
    exact: Boolean,
    activeClass: {
      type: String,
      default: 'q-router-link--active'
    },
    exactActiveClass: {
      type: String,
      default: 'q-router-link--exact-active'
    },
    disable: Boolean
  };

  function useRouterLink () {
    const vm = vue.getCurrentInstance();
    const { props, attrs, proxy } = vm;

    const hasRouter = vmHasRouter(vm);

    const hasLink = vue.computed(() =>
      hasRouter === true
      && props.disable !== true
      && props.to !== void 0 && props.to !== null && props.to !== ''
    );

    const linkTag = vue.computed(() => (
      hasLink.value === true
        ? 'a'
        : (props.tag || 'div')
    ));

    const linkRoute = vue.computed(() => (
      hasLink.value === true
        ? proxy.$router.resolve(props.to)
        : null
    ));

    const linkActiveIndex = vue.computed(() => {
      if (hasLink.value === false) {
        return null
      }

      const
        { matched } = linkRoute.value,
        { length } = matched,
        routeMatched = matched[ length - 1 ];

      if (routeMatched === void 0) {
        return -1
      }

      const currentMatched = proxy.$route.matched;

      if (currentMatched.length === 0) {
        return -1
      }

      const index = currentMatched.findIndex(
        isSameRouteRecord.bind(null, routeMatched)
      );

      if (index > -1) {
        return index
      }

      // possible parent record
      const parentRecordPath = getOriginalPath(matched[ length - 2 ]);

      return (
        // we are dealing with nested routes
        length > 1
        // if the parent and matched route have the same path, this link is
        // referring to the empty child. Or we currently are on a different
        // child of the same parent
        && getOriginalPath(routeMatched) === parentRecordPath
        // avoid comparing the child with its parent
        && currentMatched[ currentMatched.length - 1 ].path !== parentRecordPath
          ? currentMatched.findIndex(
              isSameRouteRecord.bind(null, matched[ length - 2 ])
            )
          : index
      )
    });

    const linkIsActive = vue.computed(() =>
      hasLink.value === true
      && linkActiveIndex.value > -1
      && includesParams(proxy.$route.params, linkRoute.value.params)
    );

    const linkIsExactActive = vue.computed(() =>
      linkIsActive.value === true
        && linkActiveIndex.value === proxy.$route.matched.length - 1
    );

    const linkClass = vue.computed(() => (
      hasLink.value === true
        ? (
            linkIsExactActive.value === true
              ? ` ${ props.exactActiveClass } ${ props.activeClass }`
              : (
                  props.exact === true
                    ? ''
                    : (linkIsActive.value === true ? ` ${ props.activeClass }` : '')
                )
          )
        : ''
    ));

    const linkProps = vue.computed(() => (
      hasLink.value === true
        ? {
            href: linkRoute.value.href,
            target: attrs.target,
            role: 'link'
          }
        : {}
    ));

    // should match RouterLink from Vue Router
    function navigateToLink (e) {
      if (
        // component is not disabled
        props.disable === true

        // don't redirect with control keys
        || e.metaKey || e.altKey || e.ctrlKey || e.shiftKey

        // don't redirect when preventDefault called
        // ...unless calling go() from @click(e, go)
        || (e.__qNavigate !== true && e.defaultPrevented === true)

        // don't redirect on right click
        || (e.button !== undefined && e.button !== 0)

        // don't redirect if it should open in a new window
        || attrs.target === '_blank'
      ) {
        return false
      }

      prevent(e);

      proxy.$router[ props.replace === true ? 'replace' : 'push' ](props.to)
        .catch(() => {});

      return true
    }

    return {
      hasLink,
      linkTag,
      linkRoute,
      linkIsActive,
      linkIsExactActive,
      linkClass,
      linkProps,

      navigateToLink
    }
  }

  var QBreadcrumbsEl = vue.defineComponent({
    name: 'QBreadcrumbsEl',

    props: {
      ...useRouterLinkProps,

      label: String,
      icon: String,

      tag: {
        type: String,
        default: 'span'
      }
    },

    setup (props, { slots }) {
      const { linkTag, linkProps, hasLink, navigateToLink } = useRouterLink();

      const data = vue.computed(() => {
        const acc = { ...linkProps.value };
        if (hasLink.value === true) {
          acc.onClick = navigateToLink;
        }
        return acc
      });

      const iconClass = vue.computed(() =>
        'q-breadcrumbs__el-icon'
        + (props.label !== void 0 ? ' q-breadcrumbs__el-icon--with-label' : '')
      );

      return () => {
        const child = [];

        props.icon !== void 0 && child.push(
          vue.h(QIcon, {
            class: iconClass.value,
            name: props.icon
          })
        );

        props.label !== void 0 && child.push(props.label);

        return vue.h(linkTag.value, {
          class: 'q-breadcrumbs__el q-link flex inline items-center relative-position',
          ...data.value
        }, hMergeSlot(slots.default, child))
      }
    }
  });

  const useSpinnerProps = {
    size: {
      type: [ Number, String ],
      default: '1em'
    },
    color: String
  };

  function useSpinner (props) {
    return {
      cSize: vue.computed(() => (
        props.size in useSizeDefaults
          ? `${ useSizeDefaults[ props.size ] }px`
          : props.size
      )),

      classes: vue.computed(() =>
        'q-spinner' + (props.color ? ` text-${ props.color }` : '')
      )
    }
  }

  var QSpinner = vue.defineComponent({
    name: 'QSpinner',

    props: {
      ...useSpinnerProps,

      thickness: {
        type: Number,
        default: 5
      }
    },

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value + ' q-spinner-mat',
        width: cSize.value,
        height: cSize.value,
        viewBox: '25 25 50 50'
      }, [
        vue.h('circle', {
          class: 'path',
          cx: '50',
          cy: '50',
          r: '20',
          fill: 'none',
          stroke: 'currentColor',
          'stroke-width': props.thickness,
          'stroke-miterlimit': '10'
        })
      ])
    }
  });

  function offset (el) {
    if (el === window) {
      return { top: 0, left: 0 }
    }
    const { top, left } = el.getBoundingClientRect();
    return { top, left }
  }

  function style (el, property) {
    return window.getComputedStyle(el).getPropertyValue(property)
  }

  function height (el) {
    return el === window
      ? window.innerHeight
      : el.getBoundingClientRect().height
  }

  function width$1 (el) {
    return el === window
      ? window.innerWidth
      : el.getBoundingClientRect().width
  }

  function css (element, css) {
    const style = element.style;

    Object.keys(css).forEach(prop => {
      style[ prop ] = css[ prop ];
    });
  }

  function cssBatch (elements, style) {
    elements.forEach(el => css(el, style));
  }

  function ready (fn) {
    if (typeof fn !== 'function') {
      return
    }

    if (document.readyState !== 'loading') {
      return fn()
    }

    document.addEventListener('DOMContentLoaded', fn, false);
  }

  // internal
  function getElement$1 (el) {
    if (el === void 0 || el === null) {
      return void 0
    }

    if (typeof el === 'string') {
      try {
        return document.querySelector(el) || void 0
      }
      catch (err) {
        return void 0
      }
    }

    const target = vue.isRef(el) === true
      ? el.value
      : el;

    if (target) {
      return target.$el || target
    }
  }

  // internal
  function childHasFocus (el, focusedEl) {
    if (el === void 0 || el.contains(focusedEl) === true) {
      return true
    }

    for (let next = el.nextElementSibling; next !== null; next = next.nextElementSibling) {
      if (next.contains(focusedEl)) {
        return true
      }
    }

    return false
  }

  var dom = {
    offset,
    style,
    height,
    width: width$1,
    css,
    cssBatch,
    ready
  };

  function throttle (fn, limit = 250) {
    let wait = false, result;

    return function (/* ...args */) {
      if (wait === false) {
        wait = true;
        setTimeout(() => { wait = false; }, limit);
        result = fn.apply(this, arguments);
      }

      return result
    }
  }

  function showRipple (evt, el, ctx, forceCenter) {
    ctx.modifiers.stop === true && stop(evt);

    const color = ctx.modifiers.color;
    let center = ctx.modifiers.center;
    center = center === true || forceCenter === true;

    const
      node = document.createElement('span'),
      innerNode = document.createElement('span'),
      pos = position(evt),
      { left, top, width, height } = el.getBoundingClientRect(),
      diameter = Math.sqrt(width * width + height * height),
      radius = diameter / 2,
      centerX = `${ (width - diameter) / 2 }px`,
      x = center ? centerX : `${ pos.left - left - radius }px`,
      centerY = `${ (height - diameter) / 2 }px`,
      y = center ? centerY : `${ pos.top - top - radius }px`;

    innerNode.className = 'q-ripple__inner';
    css(innerNode, {
      height: `${ diameter }px`,
      width: `${ diameter }px`,
      transform: `translate3d(${ x },${ y },0) scale3d(.2,.2,1)`,
      opacity: 0
    });

    node.className = `q-ripple${ color ? ' text-' + color : '' }`;
    node.setAttribute('dir', 'ltr');
    node.appendChild(innerNode);
    el.appendChild(node);

    const abort = () => {
      node.remove();
      clearTimeout(timer);
    };
    ctx.abort.push(abort);

    let timer = setTimeout(() => {
      innerNode.classList.add('q-ripple__inner--enter');
      innerNode.style.transform = `translate3d(${ centerX },${ centerY },0) scale3d(1,1,1)`;
      innerNode.style.opacity = 0.2;

      timer = setTimeout(() => {
        innerNode.classList.remove('q-ripple__inner--enter');
        innerNode.classList.add('q-ripple__inner--leave');
        innerNode.style.opacity = 0;

        timer = setTimeout(() => {
          node.remove();
          ctx.abort.splice(ctx.abort.indexOf(abort), 1);
        }, 275);
      }, 250);
    }, 50);
  }

  function updateModifiers$1 (ctx, { modifiers, value, arg, instance }) {
    const cfg = Object.assign({}, instance.$q.config.ripple, modifiers, value);
    ctx.modifiers = {
      early: cfg.early === true,
      stop: cfg.stop === true,
      center: cfg.center === true,
      color: cfg.color || arg,
      keyCodes: [].concat(cfg.keyCodes || 13)
    };
  }

  var Ripple = {
        name: 'ripple',

        beforeMount (el, binding) {
          const ctx = {
            enabled: binding.value !== false,
            modifiers: {},
            abort: [],

            start (evt) {
              if (
                ctx.enabled === true
                && evt.qSkipRipple !== true
                && (
                  ctx.modifiers.early === true
                    ? [ 'mousedown', 'touchstart' ].includes(evt.type) === true
                    : evt.type === 'click'
                )
              ) {
                showRipple(evt, el, ctx, evt.qKeyEvent === true);
              }
            },

            keystart: throttle(evt => {
              if (
                ctx.enabled === true
                && evt.qSkipRipple !== true
                && isKeyCode(evt, ctx.modifiers.keyCodes) === true
                && evt.type === `key${ ctx.modifiers.early === true ? 'down' : 'up' }`
              ) {
                showRipple(evt, el, ctx, true);
              }
            }, 300)
          };

          updateModifiers$1(ctx, binding);

          el.__qripple = ctx;

          addEvt(ctx, 'main', [
            [ el, 'mousedown', 'start', 'passive' ],
            [ el, 'touchstart', 'start', 'passive' ],
            [ el, 'click', 'start', 'passive' ],
            [ el, 'keydown', 'keystart', 'passive' ],
            [ el, 'keyup', 'keystart', 'passive' ]
          ]);
        },

        updated (el, binding) {
          if (binding.oldValue !== binding.value) {
            const ctx = el.__qripple;
            ctx.enabled = binding.value !== false;

            if (ctx.enabled === true && Object(binding.value) === binding.value) {
              updateModifiers$1(ctx, binding);
            }
          }
        },

        beforeUnmount (el) {
          const ctx = el.__qripple;
          ctx.abort.forEach(fn => { fn(); });
          cleanEvt(ctx, 'main');
          delete el._qripple;
        }
      };

  const padding = {
    none: 0,
    xs: 4,
    sm: 8,
    md: 16,
    lg: 24,
    xl: 32
  };

  const defaultSizes$2 = {
    xs: 8,
    sm: 10,
    md: 14,
    lg: 20,
    xl: 24
  };

  const useBtnProps = {
    ...useSizeProps,
    ...useRouterLinkProps,

    type: {
      type: String,
      default: 'button'
    },

    label: [ Number, String ],
    icon: String,
    iconRight: String,

    round: Boolean,
    outline: Boolean,
    flat: Boolean,
    unelevated: Boolean,
    rounded: Boolean,
    push: Boolean,
    glossy: Boolean,

    size: String,
    fab: Boolean,
    fabMini: Boolean,
    padding: String,

    color: String,
    textColor: String,
    noCaps: Boolean,
    noWrap: Boolean,
    dense: Boolean,

    tabindex: [ Number, String ],

    ripple: {
      type: [ Boolean, Object ],
      default: true
    },

    align: {
      ...useAlignProps.align,
      default: 'center'
    },
    stack: Boolean,
    stretch: Boolean,
    loading: {
      type: Boolean,
      default: null
    },
    disable: Boolean
  };

  function useBtn (props) {
    const sizeStyle = useSize(props, defaultSizes$2);
    const alignClass = useAlign(props);
    const { hasLink, linkProps, navigateToLink } = useRouterLink();

    const style = vue.computed(() => {
      const obj = props.fab === false && props.fabMini === false
        ? sizeStyle.value
        : {};

      return props.padding !== void 0
        ? Object.assign({}, obj, {
            padding: props.padding
              .split(/\s+/)
              .map(v => (v in padding ? padding[ v ] + 'px' : v))
              .join(' '),
            minWidth: '0',
            minHeight: '0'
          })
        : obj
    });

    const isRounded = vue.computed(() =>
      props.rounded === true || props.fab === true || props.fabMini === true
    );

    const isActionable = vue.computed(() =>
      props.disable !== true && props.loading !== true
    );

    const tabIndex = vue.computed(() => (
      isActionable.value === true ? props.tabindex || 0 : -1
    ));

    const isLink = vue.computed(() =>
      props.type === 'a' || hasLink.value === true
    );

    const design = vue.computed(() => {
      if (props.flat === true) return 'flat'
      if (props.outline === true) return 'outline'
      if (props.push === true) return 'push'
      if (props.unelevated === true) return 'unelevated'
      return 'standard'
    });

    const attributes = vue.computed(() => {
      const acc = { tabindex: tabIndex.value };

      if (props.type !== 'a') {
        acc.type = props.type;
      }

      if (hasLink.value === true) {
        Object.assign(acc, linkProps.value);
      }
      else {
        acc.role = props.type === 'a' ? 'link' : 'button';
      }

      if (props.loading === true && props.percentage !== void 0) {
        Object.assign(acc, {
          role: 'progressbar',
          'aria-valuemin': 0,
          'aria-valuemax': 100,
          'aria-valuenow': props.percentage
        });
      }

      if (props.disable === true) {
        acc.disabled = '';
        acc[ 'aria-disabled' ] = 'true';
      }

      return acc
    });

    const classes = vue.computed(() => {
      let colors;

      if (props.color !== void 0) {
        if (props.flat === true || props.outline === true) {
          colors = `text-${ props.textColor || props.color }`;
        }
        else {
          colors = `bg-${ props.color } text-${ props.textColor || 'white' }`;
        }
      }
      else if (props.textColor) {
        colors = `text-${ props.textColor }`;
      }

      return `q-btn--${ design.value } `
        + `q-btn--${ props.round === true ? 'round' : `rectangle${ isRounded.value === true ? ' q-btn--rounded' : '' }` }`
        + (colors !== void 0 ? ' ' + colors : '')
        + (isActionable.value === true ? ' q-btn--actionable q-focusable q-hoverable' : (props.disable === true ? ' disabled' : ''))
        + (props.fab === true ? ' q-btn--fab' : (props.fabMini === true ? ' q-btn--fab-mini' : ''))
        + (props.noCaps === true ? ' q-btn--no-uppercase' : '')
        + (props.dense === true ? ' q-btn--dense' : '')
        + (props.stretch === true ? ' no-border-radius self-stretch' : '')
        + (props.glossy === true ? ' glossy' : '')
    });

    const innerClasses = vue.computed(() =>
      alignClass.value + (props.stack === true ? ' column' : ' row')
      + (props.noWrap === true ? ' no-wrap text-no-wrap' : '')
      + (props.loading === true ? ' q-btn__content--hidden' : '')
    );

    return {
      classes,
      style,
      innerClasses,
      attributes,
      hasLink,
      isLink,
      navigateToLink,
      isActionable
    }
  }

  const modifiersAll = {
    left: true,
    right: true,
    up: true,
    down: true,
    horizontal: true,
    vertical: true
  };

  const directionList = Object.keys(modifiersAll);

  modifiersAll.all = true;

  function getModifierDirections (mod) {
    const dir = {};

    for (const direction of directionList) {
      if (mod[ direction ] === true) {
        dir[ direction ] = true;
      }
    }

    if (Object.keys(dir).length === 0) {
      return modifiersAll
    }

    if (dir.horizontal === true) {
      dir.left = dir.right = true;
    }
    else if (dir.left === true && dir.right === true) {
      dir.horizontal = true;
    }

    if (dir.vertical === true) {
      dir.up = dir.down = true;
    }
    else if (dir.up === true && dir.down === true) {
      dir.vertical = true;
    }

    if (dir.horizontal === true && dir.vertical === true) {
      dir.all = true;
    }

    return dir
  }

  const getTouchTarget = iosEmulated !== true && (
    client.is.ios === true
    || window.navigator.vendor.toLowerCase().indexOf('apple') > -1
  )
    ? () => document
    : target => target;

  function shouldStart (evt, ctx) {
    return ctx.event === void 0
      && evt.target !== void 0
      && evt.target.draggable !== true
      && typeof ctx.handler === 'function'
      && evt.target.nodeName.toUpperCase() !== 'INPUT'
      && (evt.qClonedBy === void 0 || evt.qClonedBy.indexOf(ctx.uid) === -1)
  }

  const { passiveCapture } = listenOpts;

  let
    touchTarget = null,
    keyboardTarget = null,
    mouseTarget = null;

  var QBtn = vue.defineComponent({
    name: 'QBtn',

    props: {
      ...useBtnProps,

      percentage: Number,
      darkPercentage: Boolean
    },

    emits: [ 'click', 'keydown', 'touchstart', 'mousedown', 'keyup' ],

    setup (props, { slots, emit }) {
      const { proxy } = vue.getCurrentInstance();

      const {
        classes, style, innerClasses,
        attributes,
        hasLink, isLink, navigateToLink,
        isActionable
      } = useBtn(props);

      const rootRef = vue.ref(null);
      const blurTargetRef = vue.ref(null);

      let localTouchTargetEl = null, avoidMouseRipple, mouseTimer;

      const hasLabel = vue.computed(() =>
        props.label !== void 0 && props.label !== null && props.label !== ''
      );

      const ripple = vue.computed(() => (
        props.ripple === false
          ? false
          : {
              keyCodes: isLink.value === true ? [ 13, 32 ] : [ 13 ],
              ...(props.ripple === true ? {} : props.ripple)
            }
      ));

      const percentageStyle = vue.computed(() => {
        const val = Math.max(0, Math.min(100, props.percentage));
        return val > 0
          ? { transition: 'transform 0.6s', transform: `translateX(${ val - 100 }%)` }
          : {}
      });

      const onEvents = vue.computed(() => {
        if (props.loading === true) {
          return {
            onMousedown: onLoadingEvt,
            onTouchstartPassive: onLoadingEvt,
            onClick: onLoadingEvt,
            onKeydown: onLoadingEvt,
            onKeyup: onLoadingEvt
          }
        }

        if (isActionable.value === true) {
          return {
            onClick,
            onKeydown,
            onMousedown,
            onTouchstartPassive
          }
        }

        return {
          // needed; especially for disabled <a> tags
          onClick: stopAndPrevent
        }
      });

      const directives = vue.computed(() => {
        // if props.disable !== true && props.ripple !== false
        return [ [
          Ripple,
          ripple.value,
          void 0,
          { center: props.round }
        ] ]
      });

      const nodeProps = vue.computed(() => ({
        ref: rootRef,
        class: 'q-btn q-btn-item non-selectable no-outline ' + classes.value,
        style: style.value,
        ...attributes.value,
        ...onEvents.value
      }));

      function onClick (e) {
        if (e !== void 0) {
          if (e.defaultPrevented === true) {
            return
          }

          const el = document.activeElement;
          // focus button if it came from ENTER on form
          // prevent the new submit (already done)
          if (
            props.type === 'submit'
            && el !== document.body
            && rootRef.value.contains(el) === false
            // required for iOS and desktop Safari
            && el.contains(rootRef.value) === false
          ) {
            rootRef.value.focus();

            const onClickCleanup = () => {
              document.removeEventListener('keydown', stopAndPrevent, true);
              document.removeEventListener('keyup', onClickCleanup, passiveCapture);
              rootRef.value !== null && rootRef.value.removeEventListener('blur', onClickCleanup, passiveCapture);
            };

            document.addEventListener('keydown', stopAndPrevent, true);
            document.addEventListener('keyup', onClickCleanup, passiveCapture);
            rootRef.value.addEventListener('blur', onClickCleanup, passiveCapture);
          }
        }

        if (hasLink.value === true) {
          const go = () => {
            e.__qNavigate = true;
            navigateToLink(e);
          };

          emit('click', e, go);
          e.defaultPrevented !== true && go();
        }
        else {
          emit('click', e);
        }
      }

      function onKeydown (e) {
        if (isKeyCode(e, [ 13, 32 ]) === true) {
          stopAndPrevent(e);

          if (keyboardTarget !== rootRef.value) {
            keyboardTarget !== null && cleanup();

            // focus external button if the focus helper was focused before
            rootRef.value.focus();

            keyboardTarget = rootRef.value;
            rootRef.value.classList.add('q-btn--active');
            document.addEventListener('keyup', onPressEnd, true);
            rootRef.value.addEventListener('blur', onPressEnd, passiveCapture);
          }
        }

        emit('keydown', e);
      }

      function onTouchstartPassive (e) {
        if (touchTarget !== rootRef.value) {
          touchTarget !== null && cleanup();
          touchTarget = rootRef.value;

          localTouchTargetEl = getTouchTarget(e.target);
          localTouchTargetEl.addEventListener('touchcancel', onPressEnd, passiveCapture);
          localTouchTargetEl.addEventListener('touchend', onPressEnd, passiveCapture);
        }

        // avoid duplicated mousedown event
        // triggering another early ripple
        avoidMouseRipple = true;
        clearTimeout(mouseTimer);
        mouseTimer = setTimeout(() => {
          avoidMouseRipple = false;
        }, 200);

        emit('touchstart', e);
      }

      function onMousedown (e) {
        if (mouseTarget !== rootRef.value) {
          mouseTarget !== null && cleanup();
          mouseTarget = rootRef.value;
          rootRef.value.classList.add('q-btn--active');
          document.addEventListener('mouseup', onPressEnd, passiveCapture);
        }

        e.qSkipRipple = avoidMouseRipple === true;
        emit('mousedown', e);
      }

      function onPressEnd (e) {
        // needed for IE (because it emits blur when focusing button from focus helper)
        if (e !== void 0 && e.type === 'blur' && document.activeElement === rootRef.value) {
          return
        }

        if (e !== void 0 && e.type === 'keyup') {
          if (keyboardTarget === rootRef.value && isKeyCode(e, [ 13, 32 ]) === true) {
            // for click trigger
            const evt = new MouseEvent('click', e);
            evt.qKeyEvent = true;
            e.defaultPrevented === true && prevent(evt);
            e.cancelBubble === true && stop(evt);
            rootRef.value.dispatchEvent(evt);

            stopAndPrevent(e);

            // for ripple
            e.qKeyEvent = true;
          }

          emit('keyup', e);
        }

        cleanup();
      }

      function cleanup (destroying) {
        const blurTarget = blurTargetRef.value;

        if (
          destroying !== true
          && (touchTarget === rootRef.value || mouseTarget === rootRef.value)
          && blurTarget !== null
          && blurTarget !== document.activeElement
        ) {
          blurTarget.setAttribute('tabindex', -1);
          blurTarget.focus();
        }

        if (touchTarget === rootRef.value) {
          if (localTouchTargetEl !== null) {
            localTouchTargetEl.removeEventListener('touchcancel', onPressEnd, passiveCapture);
            localTouchTargetEl.removeEventListener('touchend', onPressEnd, passiveCapture);
          }
          touchTarget = localTouchTargetEl = null;
        }

        if (mouseTarget === rootRef.value) {
          document.removeEventListener('mouseup', onPressEnd, passiveCapture);
          mouseTarget = null;
        }

        if (keyboardTarget === rootRef.value) {
          document.removeEventListener('keyup', onPressEnd, true);
          rootRef.value !== null && rootRef.value.removeEventListener('blur', onPressEnd, passiveCapture);
          keyboardTarget = null;
        }

        rootRef.value !== null && rootRef.value.classList.remove('q-btn--active');
      }

      function onLoadingEvt (evt) {
        evt.qSkipRipple = true;
      }

      vue.onBeforeUnmount(() => {
        cleanup(true);
      });

      // expose public methods
      Object.assign(proxy, { click: onClick });

      return () => {
        let inner = [];

        props.icon !== void 0 && inner.push(
          vue.h(QIcon, {
            name: props.icon,
            left: props.stack === false && hasLabel.value === true,
            role: 'img',
            'aria-hidden': 'true'
          })
        );

        hasLabel.value === true && inner.push(
          vue.h('span', { class: 'block' }, [ props.label ])
        );

        inner = hMergeSlot(slots.default, inner);

        if (props.iconRight !== void 0 && props.round === false) {
          inner.push(
            vue.h(QIcon, {
              name: props.iconRight,
              right: props.stack === false && hasLabel.value === true,
              role: 'img',
              'aria-hidden': 'true'
            })
          );
        }

        const child = [
          vue.h('span', {
            class: 'q-focus-helper',
            ref: blurTargetRef
          })
        ];

        if (props.loading === true && props.percentage !== void 0) {
          child.push(
            vue.h('span', {
              class: 'q-btn__progress absolute-full overflow-hidden'
            }, [
              vue.h('span', {
                class: 'q-btn__progress-indicator fit block' + (props.darkPercentage === true ? ' q-btn__progress--dark' : ''),
                style: percentageStyle.value
              })
            ])
          );
        }

        child.push(
          vue.h('span', {
            class: 'q-btn__content text-center col items-center q-anchor--skip ' + innerClasses.value
          }, inner)
        );

        props.loading !== null && child.push(
          vue.h(vue.Transition, {
            name: 'q-transition--fade'
          }, () => (
            props.loading === true
              ? [
                  vue.h('span', {
                    key: 'loading',
                    class: 'absolute-full flex flex-center'
                  }, slots.loading !== void 0 ? slots.loading() : [ vue.h(QSpinner) ])
                ]
              : null
          ))
        );

        return hDir(
          isLink.value === true ? 'a' : 'button',
          nodeProps.value,
          child,
          'ripple',
          props.disable !== true && props.ripple !== false,
          () => directives.value
        )
      }
    }
  });

  var QBtnGroup = vue.defineComponent({
    name: 'QBtnGroup',

    props: {
      unelevated: Boolean,
      outline: Boolean,
      flat: Boolean,
      rounded: Boolean,
      push: Boolean,
      stretch: Boolean,
      glossy: Boolean,
      spread: Boolean
    },

    setup (props, { slots }) {
      const classes = vue.computed(() => {
        const cls = [ 'unelevated', 'outline', 'flat', 'rounded', 'push', 'stretch', 'glossy' ]
          .filter(t => props[ t ] === true)
          .map(t => `q-btn-group--${ t }`).join(' ');

        return `q-btn-group row no-wrap${ cls.length > 0 ? ' ' + cls : '' }`
          + (props.spread === true ? ' q-btn-group--spread' : ' inline')
      });

      return () => vue.h('div', { class: classes.value }, hSlot(slots.default))
    }
  });

  function clearSelection () {
    if (window.getSelection !== void 0) {
      const selection = window.getSelection();
      if (selection.empty !== void 0) {
        selection.empty();
      }
      else if (selection.removeAllRanges !== void 0) {
        selection.removeAllRanges();
        Platform.is.mobile !== true && selection.addRange(document.createRange());
      }
    }
    else if (document.selection !== void 0) {
      document.selection.empty();
    }
  }

  const useAnchorProps = {
    target: {
      default: true
    },
    noParentEvent: Boolean,
    contextMenu: Boolean
  };

  function useAnchor ({
    showing,
    avoidEmit, // required for QPopupProxy (true)
    configureAnchorEl // optional
  }) {
    const { props, proxy, emit } = vue.getCurrentInstance();

    const anchorEl = vue.ref(null);

    let touchTimer;

    function canShow (evt) {
      // abort with no parent configured or on multi-touch
      return anchorEl.value === null
        ? false
        : (evt === void 0 || evt.touches === void 0 || evt.touches.length <= 1)
    }

    const anchorEvents = {};

    if (configureAnchorEl === void 0) {
      // default configureAnchorEl is designed for
      // QMenu & QPopupProxy (which is why it's handled here)

      Object.assign(anchorEvents, {
        hide (evt) {
          proxy.hide(evt);
        },

        toggle (evt) {
          proxy.toggle(evt);
        },

        toggleKey (evt) {
          isKeyCode(evt, 13) === true && proxy.toggle(evt);
        },

        contextClick (evt) {
          proxy.hide(evt);
          vue.nextTick(() => { proxy.show(evt); });
          prevent(evt);
        },

        mobilePrevent: prevent,

        mobileTouch (evt) {
          anchorEvents.mobileCleanup(evt);

          if (canShow(evt) !== true) {
            return
          }

          proxy.hide(evt);
          anchorEl.value.classList.add('non-selectable');

          const target = getTouchTarget(evt.target);
          addEvt(anchorEvents, 'anchor', [
            [ target, 'touchmove', 'mobileCleanup', 'passive' ],
            [ target, 'touchend', 'mobileCleanup', 'passive' ],
            [ target, 'touchcancel', 'mobileCleanup', 'passive' ],
            [ anchorEl.value, 'contextmenu', 'mobilePrevent', 'notPassive' ]
          ]);

          touchTimer = setTimeout(() => {
            proxy.show(evt);
          }, 300);
        },

        mobileCleanup (evt) {
          anchorEl.value.classList.remove('non-selectable');
          clearTimeout(touchTimer);

          if (showing.value === true && evt !== void 0) {
            clearSelection();
          }
        }
      });

      configureAnchorEl = function (context = props.contextMenu) {
        if (props.noParentEvent === true || anchorEl.value === null) { return }

        let evts;

        if (context === true) {
          if (proxy.$q.platform.is.mobile === true) {
            evts = [
              [ anchorEl.value, 'touchstart', 'mobileTouch', 'passive' ]
            ];
          }
          else {
            evts = [
              [ anchorEl.value, 'click', 'hide', 'passive' ],
              [ anchorEl.value, 'contextmenu', 'contextClick', 'notPassive' ]
            ];
          }
        }
        else {
          evts = [
            [ anchorEl.value, 'click', 'toggle', 'passive' ],
            [ anchorEl.value, 'keyup', 'toggleKey', 'passive' ]
          ];
        }

        addEvt(anchorEvents, 'anchor', evts);
      };
    }

    function unconfigureAnchorEl () {
      cleanEvt(anchorEvents, 'anchor');
    }

    function setAnchorEl (el) {
      anchorEl.value = el;
      while (anchorEl.value.classList.contains('q-anchor--skip')) {
        anchorEl.value = anchorEl.value.parentNode;
      }
      configureAnchorEl();
    }

    function pickAnchorEl () {
      if (props.target === false || props.target === '') {
        anchorEl.value = null;
      }
      else if (props.target === true) {
        setAnchorEl(proxy.$el.parentNode);
      }
      else {
        let el = props.target;

        if (typeof props.target === 'string') {
          try {
            el = document.querySelector(props.target);
          }
          catch (err) {
            el = void 0;
          }
        }

        if (el !== void 0 && el !== null) {
          anchorEl.value = el.$el || el;
          configureAnchorEl();
        }
        else {
          anchorEl.value = null;
          console.error(`Anchor: target "${ props.target }" not found`);
        }
      }
    }

    vue.watch(() => props.contextMenu, val => {
      if (anchorEl.value !== null) {
        unconfigureAnchorEl();
        configureAnchorEl(val);
      }
    });

    vue.watch(() => props.target, () => {
      if (anchorEl.value !== null) {
        unconfigureAnchorEl();
      }

      pickAnchorEl();
    });

    vue.watch(() => props.noParentEvent, val => {
      if (anchorEl.value !== null) {
        if (val === true) {
          unconfigureAnchorEl();
        }
        else {
          configureAnchorEl();
        }
      }
    });

    vue.onMounted(() => {
      pickAnchorEl();

      if (avoidEmit !== true && props.modelValue === true && anchorEl.value === null) {
        emit('update:modelValue', false);
      }
    });

    vue.onBeforeUnmount(() => {
      clearTimeout(touchTimer);
      unconfigureAnchorEl();
    });

    return {
      anchorEl,
      canShow,
      anchorEvents
    }
  }

  function useScrollTarget (
    props,
    configureScrollTarget
  ) {
    const localScrollTarget = vue.ref(null);
    let scrollFn;

    function changeScrollEvent (scrollTarget, fn) {
      const fnProp = `${ fn !== void 0 ? 'add' : 'remove' }EventListener`;
      const fnHandler = fn !== void 0 ? fn : scrollFn;

      if (scrollTarget !== window) {
        scrollTarget[ fnProp ]('scroll', fnHandler, listenOpts.passive);
      }

      window[ fnProp ]('scroll', fnHandler, listenOpts.passive);

      scrollFn = fn;
    }

    function unconfigureScrollTarget () {
      if (localScrollTarget.value !== null) {
        changeScrollEvent(localScrollTarget.value);
        localScrollTarget.value = null;
      }
    }

    const noParentEventWatcher = vue.watch(() => props.noParentEvent, () => {
      if (localScrollTarget.value !== null) {
        unconfigureScrollTarget();
        configureScrollTarget();
      }
    });

    vue.onBeforeUnmount(noParentEventWatcher);

    return {
      localScrollTarget,
      unconfigureScrollTarget,
      changeScrollEvent
    }
  }

  const useModelToggleProps = {
    modelValue: {
      type: Boolean,
      default: null
    },

    'onUpdate:modelValue': Function
  };

  const useModelToggleEmits = [
    'before-show', 'show', 'before-hide', 'hide'
  ];

  // handleShow/handleHide -> removeTick(), self (& emit show), prepareTick()

  function useModelToggle ({
    showing,
    canShow, // optional
    hideOnRouteChange, // optional
    handleShow, // optional
    handleHide, // optional
    processOnMount // optional
  }) {
    const vm = vue.getCurrentInstance();
    const { props, emit, proxy } = vm;

    let payload;

    function toggle (evt) {
      if (showing.value === true) {
        hide(evt);
      }
      else {
        show(evt);
      }
    }

    function show (evt) {
      if (props.disable === true || (canShow !== void 0 && canShow(evt) !== true)) {
        return
      }

      const listener = props[ 'onUpdate:modelValue' ] !== void 0;

      if (listener === true && false !== true) {
        emit('update:modelValue', true);
        payload = evt;
        vue.nextTick(() => {
          if (payload === evt) {
            payload = void 0;
          }
        });
      }

      if (props.modelValue === null || listener === false || false) {
        processShow(evt);
      }
    }

    function processShow (evt) {
      if (showing.value === true) {
        return
      }

      showing.value = true;

      emit('before-show', evt);

      if (handleShow !== void 0) {
        handleShow(evt);
      }
      else {
        emit('show', evt);
      }
    }

    function hide (evt) {
      if (props.disable === true) {
        return
      }

      const listener = props[ 'onUpdate:modelValue' ] !== void 0;

      if (listener === true && false !== true) {
        emit('update:modelValue', false);
        payload = evt;
        vue.nextTick(() => {
          if (payload === evt) {
            payload = void 0;
          }
        });
      }

      if (props.modelValue === null || listener === false || false) {
        processHide(evt);
      }
    }

    function processHide (evt) {
      if (showing.value === false) {
        return
      }

      showing.value = false;

      emit('before-hide', evt);

      if (handleHide !== void 0) {
        handleHide(evt);
      }
      else {
        emit('hide', evt);
      }
    }

    function processModelChange (val) {
      if (props.disable === true && val === true) {
        if (props[ 'onUpdate:modelValue' ] !== void 0) {
          emit('update:modelValue', false);
        }
      }
      else if ((val === true) !== showing.value) {
        const fn = val === true ? processShow : processHide;
        fn(payload);
      }
    }

    vue.watch(() => props.modelValue, processModelChange);

    if (hideOnRouteChange !== void 0 && vmHasRouter(vm) === true) {
      vue.watch(() => proxy.$route, () => {
        if (hideOnRouteChange.value === true && showing.value === true) {
          hide();
        }
      });
    }

    processOnMount === true && vue.onMounted(() => {
      processModelChange(props.modelValue);
    });

    // expose public methods
    const publicMethods = { show, hide, toggle };
    Object.assign(proxy, publicMethods);

    return publicMethods
  }

  let queue = [];
  const waitFlags = [];

  function addFocusWaitFlag (flag) {
    waitFlags.push(flag);
  }

  function removeFocusWaitFlag (flag) {
    const index = waitFlags.indexOf(flag);
    if (index !== -1) {
      waitFlags.splice(index, 1);
    }

    if (waitFlags.length === 0 && queue.length > 0) {
      // only call last focus handler (can't focus multiple things at once)
      queue[ queue.length - 1 ]();
      queue = [];
    }
  }

  function addFocusFn (fn) {
    if (waitFlags.length === 0) {
      fn();
    }
    else {
      queue.push(fn);
      return fn
    }
  }

  function removeFocusFn (fn) {
    const index = queue.indexOf(fn);
    if (index !== -1) {
      queue.splice(index, 1);
    }
  }

  const globalNodes = [];
  let target = document.body;

  function createGlobalNode (id) {
    const el = document.createElement('div');

    if (id !== void 0) {
      el.id = id;
    }

    if (globalConfig.globalNodes !== void 0) {
      const cls = globalConfig.globalNodes.class;
      if (cls !== void 0) {
        el.className = cls;
      }
    }

    target.appendChild(el);
    globalNodes.push(el);

    return el
  }

  function removeGlobalNode (el) {
    globalNodes.splice(globalNodes.indexOf(el), 1);
    el.remove();
  }

  function changeGlobalNodesTarget (el) {
    if (el !== target) {
      target = el;

      globalNodes.forEach(el => {
        if (el.contains(target) === false) {
          target.appendChild(el);
        }
      });
    }
  }

  const portalList = [];

  function getPortalVm (el) {
    return portalList.find(vm =>
      vm.__qPortalInnerRef.value !== null
      && vm.__qPortalInnerRef.value.contains(el)
    )
  }

  function closePortalMenus (vm, evt) {
    do {
      if (vm.$options.name === 'QMenu') {
        vm.hide(evt);

        // is this a point of separation?
        if (vm.$props.separateClosePopup === true) {
          return getParentVm(vm)
        }
      }
      else if (vm.__qPortalInnerRef !== void 0) {
        // treat it as point of separation if parent is QPopupProxy
        // (so mobile matches desktop behavior)
        // and hide it too
        const parent = getParentVm(vm);

        if (parent !== void 0 && parent.$options.name === 'QPopupProxy') {
          vm.hide(evt);
          return parent
        }
        else {
          return vm
        }
      }

      vm = getParentVm(vm);
    } while (vm !== void 0 && vm !== null)
  }

  function closePortals (vm, evt, depth) {
    while (depth !== 0 && vm !== void 0 && vm !== null) {
      if (vm.__qPortalInnerRef !== void 0) {
        depth--;

        if (vm.$options.name === 'QMenu') {
          vm = closePortalMenus(vm, evt);
          continue
        }

        vm.hide(evt);
      }

      vm = getParentVm(vm);
    }
  }

  function isOnGlobalDialog (vm) {
    vm = vm.parent;

    while (vm !== void 0 && vm !== null) {
      if (vm.type.name === 'QGlobalDialog') {
        return true
      }
      if (vm.type.name === 'QDialog' || vm.type.name === 'QMenu') {
        return false
      }

      vm = vm.parent;
    }

    return false
  }

  // Warning!
  // You MUST specify "inheritAttrs: false" in your component

  function usePortal (vm, innerRef, renderPortalContent, checkGlobalDialog) {
    const portalIsActive = vue.ref(false);

    let portalEl = null;
    const focusObj = {};
    const onGlobalDialog = checkGlobalDialog === true && isOnGlobalDialog(vm);

    function showPortal (isReady) {
      if (isReady === true) {
        removeFocusWaitFlag(focusObj);
        return
      }

      if (onGlobalDialog === false && portalEl === null) {
        portalEl = createGlobalNode();
      }

      portalIsActive.value = true;

      // register portal
      portalList.push(vm.proxy);

      addFocusWaitFlag(focusObj);
    }

    function hidePortal () {
      removeFocusWaitFlag(focusObj);
      portalIsActive.value = false;

      // unregister portal
      const index = portalList.indexOf(vm.proxy);
      if (index > -1) {
        portalList.splice(index, 1);
      }

      if (portalEl !== null) {
        removeGlobalNode(portalEl);
        portalEl = null;
      }
    }

    vue.onUnmounted(hidePortal);

    // expose publicly needed stuff for portal utils
    Object.assign(vm.proxy, { __qPortalInnerRef: innerRef });

    return {
      showPortal,
      hidePortal,

      portalIsActive,

      renderPortal: () => (
        onGlobalDialog === true
          ? renderPortalContent()
          : (
              portalIsActive.value === true
                ? [ vue.h(vue.Teleport, { to: portalEl }, renderPortalContent()) ]
                : void 0
            )
      )
    }
  }

  const useTransitionProps = {
    transitionShow: {
      type: String,
      default: 'fade'
    },

    transitionHide: {
      type: String,
      default: 'fade'
    },

    transitionDuration: {
      type: [ String, Number ],
      default: 300
    }
  };

  function useTransition (props, showing) {
    const transitionState = vue.ref(showing.value);

    vue.watch(showing, val => {
      vue.nextTick(() => { transitionState.value = val; });
    });

    // return transition
    return {
      transition: vue.computed(() => 'q-transition--' + (
        transitionState.value === true ? props.transitionHide : props.transitionShow
      )),

      transitionStyle: vue.computed(() => `--q-transition-duration: ${ props.transitionDuration }ms`)
    }
  }

  /*
   * Usage:
   *    registerTick(fn)
   *    registerTick(fn)
   *    ....
   *    prepareTick()
   */

  function useTick () {
    let tickFn;

    vue.onBeforeUnmount(() => {
      tickFn = void 0;
    });

    return {
      registerTick (fn) {
        tickFn = fn;
      },

      removeTick () {
        tickFn = void 0;
      },

      prepareTick () {
        if (tickFn !== void 0) {
          const fn = tickFn;
          vue.nextTick(() => {
            if (tickFn === fn) {
              tickFn();
              tickFn = void 0;
            }
          });
        }
      }
    }
  }

  function useTimeout () {
    let timer;

    vue.onBeforeUnmount(() => {
      clearTimeout(timer);
    });

    return {
      registerTimeout (fn, delay) {
        clearTimeout(timer);
        timer = setTimeout(fn, delay);
      },

      removeTimeout () {
        clearTimeout(timer);
      }
    }
  }

  const scrollTargets = [ null, document, document.body, document.scrollingElement, document.documentElement ];

  function getScrollTarget (el, targetEl) {
    let target = getElement$1(targetEl);

    if (target === void 0) {
      if (el === void 0 || el === null) {
        return window
      }

      target = el.closest('.scroll,.scroll-y,.overflow-auto');
    }

    return scrollTargets.includes(target)
      ? window
      : target
  }

  function getScrollHeight (el) {
    return (el === window ? document.body : el).scrollHeight
  }

  function getScrollWidth (el) {
    return (el === window ? document.body : el).scrollWidth
  }

  function getVerticalScrollPosition (scrollTarget) {
    return scrollTarget === window
      ? window.pageYOffset || window.scrollY || document.body.scrollTop || 0
      : scrollTarget.scrollTop
  }

  function getHorizontalScrollPosition (scrollTarget) {
    return scrollTarget === window
      ? window.pageXOffset || window.scrollX || document.body.scrollLeft || 0
      : scrollTarget.scrollLeft
  }

  function animVerticalScrollTo (el, to, duration = 0 /* , prevTime */) {
    const prevTime = arguments[ 3 ] === void 0 ? performance.now() : arguments[ 3 ];
    const pos = getVerticalScrollPosition(el);

    if (duration <= 0) {
      if (pos !== to) {
        setScroll$1(el, to);
      }
      return
    }

    requestAnimationFrame(nowTime => {
      const frameTime = nowTime - prevTime;
      const newPos = pos + (to - pos) / Math.max(frameTime, duration) * frameTime;
      setScroll$1(el, newPos);
      if (newPos !== to) {
        animVerticalScrollTo(el, to, duration - frameTime, nowTime);
      }
    });
  }

  function animHorizontalScrollTo (el, to, duration = 0 /* , prevTime */) {
    const prevTime = arguments[ 3 ] === void 0 ? performance.now() : arguments[ 3 ];
    const pos = getHorizontalScrollPosition(el);

    if (duration <= 0) {
      if (pos !== to) {
        setHorizontalScroll(el, to);
      }
      return
    }

    requestAnimationFrame(nowTime => {
      const frameTime = nowTime - prevTime;
      const newPos = pos + (to - pos) / Math.max(frameTime, duration) * frameTime;
      setHorizontalScroll(el, newPos);
      if (newPos !== to) {
        animHorizontalScrollTo(el, to, duration - frameTime, nowTime);
      }
    });
  }

  function setScroll$1 (scrollTarget, offset) {
    if (scrollTarget === window) {
      window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, offset);
      return
    }
    scrollTarget.scrollTop = offset;
  }

  function setHorizontalScroll (scrollTarget, offset) {
    if (scrollTarget === window) {
      window.scrollTo(offset, window.pageYOffset || window.scrollY || document.body.scrollTop || 0);
      return
    }
    scrollTarget.scrollLeft = offset;
  }

  function setVerticalScrollPosition (scrollTarget, offset, duration) {
    if (duration) {
      animVerticalScrollTo(scrollTarget, offset, duration);
      return
    }
    setScroll$1(scrollTarget, offset);
  }

  function setHorizontalScrollPosition (scrollTarget, offset, duration) {
    if (duration) {
      animHorizontalScrollTo(scrollTarget, offset, duration);
      return
    }
    setHorizontalScroll(scrollTarget, offset);
  }

  let size;
  function getScrollbarWidth () {
    if (size !== undefined) {
      return size
    }

    const
      inner = document.createElement('p'),
      outer = document.createElement('div');

    css(inner, {
      width: '100%',
      height: '200px'
    });
    css(outer, {
      position: 'absolute',
      top: '0px',
      left: '0px',
      visibility: 'hidden',
      width: '200px',
      height: '150px',
      overflow: 'hidden'
    });

    outer.appendChild(inner);

    document.body.appendChild(outer);

    const w1 = inner.offsetWidth;
    outer.style.overflow = 'scroll';
    let w2 = inner.offsetWidth;

    if (w1 === w2) {
      w2 = outer.clientWidth;
    }

    outer.remove();
    size = w1 - w2;

    return size
  }

  function hasScrollbar (el, onY = true) {
    if (!el || el.nodeType !== Node.ELEMENT_NODE) {
      return false
    }

    return onY
      ? (
          el.scrollHeight > el.clientHeight && (
            el.classList.contains('scroll')
            || el.classList.contains('overflow-auto')
            || [ 'auto', 'scroll' ].includes(window.getComputedStyle(el)[ 'overflow-y' ])
          )
        )
      : (
          el.scrollWidth > el.clientWidth && (
            el.classList.contains('scroll')
            || el.classList.contains('overflow-auto')
            || [ 'auto', 'scroll' ].includes(window.getComputedStyle(el)[ 'overflow-x' ])
          )
        )
  }

  var scroll = {
    getScrollTarget,

    getScrollHeight,
    getScrollWidth,

    getVerticalScrollPosition,
    getHorizontalScrollPosition,

    animVerticalScrollTo,
    animHorizontalScrollTo,

    setVerticalScrollPosition,
    setHorizontalScrollPosition,

    getScrollbarWidth,
    hasScrollbar
  };

  const handlers$1 = [];
  let escDown;

  function onKeydown (evt) {
    escDown = evt.keyCode === 27;
  }

  function onBlur () {
    if (escDown === true) {
      escDown = false;
    }
  }

  function onKeyup (evt) {
    if (escDown === true) {
      escDown = false;

      if (isKeyCode(evt, 27) === true) {
        handlers$1[ handlers$1.length - 1 ](evt);
      }
    }
  }

  function update$4 (action) {
    window[ action ]('keydown', onKeydown);
    window[ action ]('blur', onBlur);
    window[ action ]('keyup', onKeyup);
    escDown = false;
  }

  function addEscapeKey (fn) {
    if (client.is.desktop === true) {
      handlers$1.push(fn);

      if (handlers$1.length === 1) {
        update$4('addEventListener');
      }
    }
  }

  function removeEscapeKey (fn) {
    const index = handlers$1.indexOf(fn);
    if (index > -1) {
      handlers$1.splice(index, 1);

      if (handlers$1.length === 0) {
        update$4('removeEventListener');
      }
    }
  }

  const handlers = [];

  function trigger$1 (e) {
    handlers[ handlers.length - 1 ](e);
  }

  function addFocusout (fn) {
    if (client.is.desktop === true) {
      handlers.push(fn);

      if (handlers.length === 1) {
        document.body.addEventListener('focusin', trigger$1);
      }
    }
  }

  function removeFocusout (fn) {
    const index = handlers.indexOf(fn);
    if (index > -1) {
      handlers.splice(index, 1);

      if (handlers.length === 0) {
        document.body.removeEventListener('focusin', trigger$1);
      }
    }
  }

  let timer;

  const
    { notPassiveCapture } = listenOpts,
    registeredList = [];

  function hasModalsAbove (node) {
    while ((node = node.nextElementSibling) !== null) {
      if (node.classList.contains('q-dialog--modal')) {
        return true
      }
    }

    return false
  }

  function globalHandler (evt) {
    clearTimeout(timer);

    const target = evt.target;

    if (
      target === void 0
      || target.nodeType === 8
      || target.classList.contains('no-pointer-events') === true
    ) {
      return
    }

    for (let i = registeredList.length - 1; i >= 0; i--) {
      const state = registeredList[ i ];
      if (
        (
          state.anchorEl.value === null
          || state.anchorEl.value.contains(target) === false
        )
        && (
          target === document.body
          || (state.innerRef.value  !== null && state.innerRef.value.contains(target) === false)
        )
        && (
          state.getEl !== void 0
            ? hasModalsAbove(state.getEl()) !== true
            : true
        )
      ) {
        // mark the event as being processed by clickOutside
        // used to prevent refocus after menu close
        evt.qClickOutside = true;
        state.onClickOutside(evt);
      }
      else {
        return
      }
    }
  }

  function addClickOutside (clickOutsideProps) {
    registeredList.push(clickOutsideProps);

    if (registeredList.length === 1) {
      document.addEventListener('mousedown', globalHandler, notPassiveCapture);
      document.addEventListener('touchstart', globalHandler, notPassiveCapture);
    }
  }

  function removeClickOutside (clickOutsideProps) {
    const index = registeredList.findIndex(h => h === clickOutsideProps);

    if (index > -1) {
      registeredList.splice(index, 1);

      if (registeredList.length === 0) {
        clearTimeout(timer);
        document.removeEventListener('mousedown', globalHandler, notPassiveCapture);
        document.removeEventListener('touchstart', globalHandler, notPassiveCapture);
      }
    }
  }

  let vpLeft, vpTop;

  function validatePosition (pos) {
    const parts = pos.split(' ');
    if (parts.length !== 2) {
      return false
    }
    if ([ 'top', 'center', 'bottom' ].includes(parts[ 0 ]) !== true) {
      console.error('Anchor/Self position must start with one of top/center/bottom');
      return false
    }
    if ([ 'left', 'middle', 'right', 'start', 'end' ].includes(parts[ 1 ]) !== true) {
      console.error('Anchor/Self position must end with one of left/middle/right/start/end');
      return false
    }
    return true
  }

  function validateOffset (val) {
    if (!val) { return true }
    if (val.length !== 2) { return false }
    if (typeof val[ 0 ] !== 'number' || typeof val[ 1 ] !== 'number') {
      return false
    }
    return true
  }

  const horizontalPos = {
    'start#ltr': 'left',
    'start#rtl': 'right',
    'end#ltr': 'right',
    'end#rtl': 'left'
  }

  ;[ 'left', 'middle', 'right' ].forEach(pos => {
    horizontalPos[ `${ pos }#ltr` ] = pos;
    horizontalPos[ `${ pos }#rtl` ] = pos;
  });

  function parsePosition (pos, rtl) {
    const parts = pos.split(' ');
    return {
      vertical: parts[ 0 ],
      horizontal: horizontalPos[ `${ parts[ 1 ] }#${ rtl === true ? 'rtl' : 'ltr' }` ]
    }
  }

  function getAnchorProps (el, offset) {
    let { top, left, right, bottom, width, height } = el.getBoundingClientRect();

    if (offset !== void 0) {
      top -= offset[ 1 ];
      left -= offset[ 0 ];
      bottom += offset[ 1 ];
      right += offset[ 0 ];

      width += offset[ 0 ];
      height += offset[ 1 ];
    }

    return {
      top,
      left,
      right,
      bottom,
      width,
      height,
      middle: left + (right - left) / 2,
      center: top + (bottom - top) / 2
    }
  }

  function getTargetProps (el) {
    return {
      top: 0,
      center: el.offsetHeight / 2,
      bottom: el.offsetHeight,
      left: 0,
      middle: el.offsetWidth / 2,
      right: el.offsetWidth
    }
  }

  // cfg: { el, anchorEl, anchorOrigin, selfOrigin, offset, absoluteOffset, cover, fit, maxHeight, maxWidth }
  function setPosition (cfg) {
    if (client.is.ios === true && window.visualViewport !== void 0) {
      // uses the q-position-engine CSS class

      const el = document.body.style;
      const { offsetLeft: left, offsetTop: top } = window.visualViewport;

      if (left !== vpLeft) {
        el.setProperty('--q-pe-left', left + 'px');
        vpLeft = left;
      }
      if (top !== vpTop) {
        el.setProperty('--q-pe-top', top + 'px');
        vpTop = top;
      }
    }

    let anchorProps;

    // scroll position might change
    // if max-height/-width changes, so we
    // need to restore it after we calculate
    // the new positioning
    const { scrollLeft, scrollTop } = cfg.el;

    if (cfg.absoluteOffset === void 0) {
      anchorProps = getAnchorProps(cfg.anchorEl, cfg.cover === true ? [ 0, 0 ] : cfg.offset);
    }
    else {
      const
        { top: anchorTop, left: anchorLeft } = cfg.anchorEl.getBoundingClientRect(),
        top = anchorTop + cfg.absoluteOffset.top,
        left = anchorLeft + cfg.absoluteOffset.left;

      anchorProps = { top, left, width: 1, height: 1, right: left + 1, center: top, middle: left, bottom: top + 1 };
    }

    let elStyle = {
      maxHeight: cfg.maxHeight,
      maxWidth: cfg.maxWidth,
      visibility: 'visible'
    };

    if (cfg.fit === true || cfg.cover === true) {
      elStyle.minWidth = anchorProps.width + 'px';
      if (cfg.cover === true) {
        elStyle.minHeight = anchorProps.height + 'px';
      }
    }

    Object.assign(cfg.el.style, elStyle);

    const
      targetProps = getTargetProps(cfg.el),
      props = {
        top: anchorProps[ cfg.anchorOrigin.vertical ] - targetProps[ cfg.selfOrigin.vertical ],
        left: anchorProps[ cfg.anchorOrigin.horizontal ] - targetProps[ cfg.selfOrigin.horizontal ]
      };

    applyBoundaries(props, anchorProps, targetProps, cfg.anchorOrigin, cfg.selfOrigin);

    elStyle = {
      top: props.top + 'px',
      left: props.left + 'px'
    };

    if (props.maxHeight !== void 0) {
      elStyle.maxHeight = props.maxHeight + 'px';

      if (anchorProps.height > props.maxHeight) {
        elStyle.minHeight = elStyle.maxHeight;
      }
    }
    if (props.maxWidth !== void 0) {
      elStyle.maxWidth = props.maxWidth + 'px';

      if (anchorProps.width > props.maxWidth) {
        elStyle.minWidth = elStyle.maxWidth;
      }
    }

    Object.assign(cfg.el.style, elStyle);

    // restore scroll position
    if (cfg.el.scrollTop !== scrollTop) {
      cfg.el.scrollTop = scrollTop;
    }
    if (cfg.el.scrollLeft !== scrollLeft) {
      cfg.el.scrollLeft = scrollLeft;
    }
  }

  function applyBoundaries (props, anchorProps, targetProps, anchorOrigin, selfOrigin) {
    const
      currentHeight = targetProps.bottom,
      currentWidth = targetProps.right,
      margin = getScrollbarWidth(),
      innerHeight = window.innerHeight - margin,
      innerWidth = document.body.clientWidth;

    if (props.top < 0 || props.top + currentHeight > innerHeight) {
      if (selfOrigin.vertical === 'center') {
        props.top = anchorProps[ anchorOrigin.vertical ] > innerHeight / 2
          ? Math.max(0, innerHeight - currentHeight)
          : 0;
        props.maxHeight = Math.min(currentHeight, innerHeight);
      }
      else if (anchorProps[ anchorOrigin.vertical ] > innerHeight / 2) {
        const anchorY = Math.min(
          innerHeight,
          anchorOrigin.vertical === 'center'
            ? anchorProps.center
            : (anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.bottom : anchorProps.top)
        );
        props.maxHeight = Math.min(currentHeight, anchorY);
        props.top = Math.max(0, anchorY - currentHeight);
      }
      else {
        props.top = Math.max(0, anchorOrigin.vertical === 'center'
          ? anchorProps.center
          : (anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.top : anchorProps.bottom)
        );
        props.maxHeight = Math.min(currentHeight, innerHeight - props.top);
      }
    }

    if (props.left < 0 || props.left + currentWidth > innerWidth) {
      props.maxWidth = Math.min(currentWidth, innerWidth);
      if (selfOrigin.horizontal === 'middle') {
        props.left = anchorProps[ anchorOrigin.horizontal ] > innerWidth / 2
          ? Math.max(0, innerWidth - currentWidth)
          : 0;
      }
      else if (anchorProps[ anchorOrigin.horizontal ] > innerWidth / 2) {
        const anchorX = Math.min(
          innerWidth,
          anchorOrigin.horizontal === 'middle'
            ? anchorProps.middle
            : (anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.right : anchorProps.left)
        );
        props.maxWidth = Math.min(currentWidth, anchorX);
        props.left = Math.max(0, anchorX - props.maxWidth);
      }
      else {
        props.left = Math.max(0, anchorOrigin.horizontal === 'middle'
          ? anchorProps.middle
          : (anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.left : anchorProps.right)
        );
        props.maxWidth = Math.min(currentWidth, innerWidth - props.left);
      }
    }
  }

  var QMenu = vue.defineComponent({
    name: 'QMenu',

    inheritAttrs: false,

    props: {
      ...useAnchorProps,
      ...useModelToggleProps,
      ...useDarkProps,
      ...useTransitionProps,

      persistent: Boolean,
      autoClose: Boolean,
      separateClosePopup: Boolean,

      noRouteDismiss: Boolean,
      noRefocus: Boolean,
      noFocus: Boolean,

      fit: Boolean,
      cover: Boolean,

      square: Boolean,

      anchor: {
        type: String,
        validator: validatePosition
      },
      self: {
        type: String,
        validator: validatePosition
      },
      offset: {
        type: Array,
        validator: validateOffset
      },

      scrollTarget: {
        default: void 0
      },

      touchPosition: Boolean,

      maxHeight: {
        type: String,
        default: null
      },
      maxWidth: {
        type: String,
        default: null
      }
    },

    emits: [
      ...useModelToggleEmits,
      'click', 'escape-key'
    ],

    setup (props, { slots, emit, attrs }) {
      let refocusTarget = null, absoluteOffset, unwatchPosition, avoidAutoClose;

      const vm = vue.getCurrentInstance();
      const { proxy } = vm;
      const { $q } = proxy;

      const innerRef = vue.ref(null);
      const showing = vue.ref(false);

      const hideOnRouteChange = vue.computed(() =>
        props.persistent !== true
        && props.noRouteDismiss !== true
      );

      const isDark = useDark(props, $q);
      const { registerTick, removeTick, prepareTick } = useTick();
      const { registerTimeout, removeTimeout } = useTimeout();
      const { transition, transitionStyle } = useTransition(props, showing);
      const { localScrollTarget, changeScrollEvent, unconfigureScrollTarget } = useScrollTarget(props, configureScrollTarget);

      const { anchorEl, canShow } = useAnchor({ showing });

      const { hide } = useModelToggle({
        showing, canShow, handleShow, handleHide,
        hideOnRouteChange,
        processOnMount: true
      });

      const { showPortal, hidePortal, renderPortal } = usePortal(vm, innerRef, renderPortalContent);

      const clickOutsideProps = {
        anchorEl,
        innerRef,
        getEl: () => proxy.$el,
        onClickOutside (e) {
          if (props.persistent !== true && showing.value === true) {
            hide(e);

            if (
              // always prevent touch event
              e.type === 'touchstart'
              // prevent click if it's on a dialog backdrop
              || e.target.classList.contains('q-dialog__backdrop')
            ) {
              stopAndPrevent(e);
            }

            return true
          }
        }
      };

      const anchorOrigin = vue.computed(() =>
        parsePosition(
          props.anchor || (
            props.cover === true ? 'center middle' : 'bottom start'
          ),
          $q.lang.rtl
        )
      );

      const selfOrigin = vue.computed(() => (
        props.cover === true
          ? anchorOrigin.value
          : parsePosition(props.self || 'top start', $q.lang.rtl)
      ));

      const menuClass = vue.computed(() =>
        (props.square === true ? ' q-menu--square' : '')
        + (isDark.value === true ? ' q-menu--dark q-dark' : '')
      );

      const onEvents = vue.computed(() => (
        props.autoClose === true
          ? { onClick: onAutoClose }
          : {}
      ));

      const handlesFocus = vue.computed(() =>
        showing.value === true && props.persistent !== true
      );

      vue.watch(handlesFocus, val => {
        if (val === true) {
          addEscapeKey(onEscapeKey);
          addClickOutside(clickOutsideProps);
        }
        else {
          removeEscapeKey(onEscapeKey);
          removeClickOutside(clickOutsideProps);
        }
      });

      function focus () {
        addFocusFn(() => {
          let node = innerRef.value;

          if (node && node.contains(document.activeElement) !== true) {
            node = node.querySelector('[autofocus], [data-autofocus]') || node;
            node.focus();
          }
        });
      }

      function handleShow (evt) {
        removeTick();
        removeTimeout();

        refocusTarget = props.noRefocus === false
          ? document.activeElement
          : null;

        addFocusout(onFocusout);

        showPortal();
        configureScrollTarget();

        absoluteOffset = void 0;

        if (evt !== void 0 && (props.touchPosition || props.contextMenu)) {
          const pos = position(evt);

          if (pos.left !== void 0) {
            const { top, left } = anchorEl.value.getBoundingClientRect();
            absoluteOffset = { left: pos.left - left, top: pos.top - top };
          }
        }

        if (unwatchPosition === void 0) {
          unwatchPosition = vue.watch(
            () => $q.screen.width + '|' + $q.screen.height + '|' + props.self + '|' + props.anchor + '|' + $q.lang.rtl,
            updatePosition
          );
        }

        if (props.noFocus !== true) {
          document.activeElement.blur();
        }

        registerTick(() => {
          updatePosition();
          props.noFocus !== true && focus();
        });
        prepareTick();

        registerTimeout(() => {
          // required in order to avoid the "double-tap needed" issue
          if ($q.platform.is.ios === true) {
            // if auto-close, then this click should
            // not close the menu
            avoidAutoClose = props.autoClose;
            innerRef.value.click();
          }

          updatePosition();
          showPortal(true); // done showing portal
          emit('show', evt);
        }, props.transitionDuration);
      }

      function handleHide (evt) {
        removeTick();
        removeTimeout();

        anchorCleanup(true);

        if (
          refocusTarget !== null
          && (
            // menu was hidden from code or ESC plugin
            evt === void 0
            // menu was not closed from a mouse or touch clickOutside
            || evt.qClickOutside !== true
          )
        ) {
          refocusTarget.focus();
        }

        registerTimeout(() => {
          hidePortal();
          emit('hide', evt);
        }, props.transitionDuration);
      }

      function anchorCleanup (hiding) {
        absoluteOffset = void 0;

        if (unwatchPosition !== void 0) {
          unwatchPosition();
          unwatchPosition = void 0;
        }

        if (hiding === true || showing.value === true) {
          removeFocusout(onFocusout);
          unconfigureScrollTarget();
          removeClickOutside(clickOutsideProps);
          removeEscapeKey(onEscapeKey);
        }
      }

      function configureScrollTarget () {
        if (anchorEl.value !== null || props.scrollTarget !== void 0) {
          localScrollTarget.value = getScrollTarget(anchorEl.value, props.scrollTarget);
          changeScrollEvent(localScrollTarget.value, updatePosition);
        }
      }

      function onAutoClose (e) {
        // if auto-close, then the ios double-tap fix which
        // issues a click should not close the menu
        if (avoidAutoClose !== true) {
          closePortalMenus(proxy, e);
          emit('click', e);
        }
        else {
          avoidAutoClose = false;
        }
      }

      function onFocusout (evt) {
        // the focus is not in a vue child component
        if (
          handlesFocus.value === true
          && childHasFocus(innerRef.value, evt.target) !== true
        ) {
          focus();
        }
      }

      function onEscapeKey (evt) {
        emit('escape-key');
        hide(evt);
      }

      function updatePosition () {
        const el = innerRef.value;

        if (el === null || anchorEl.value === null) {
          return
        }

        setPosition({
          el,
          offset: props.offset,
          anchorEl: anchorEl.value,
          anchorOrigin: anchorOrigin.value,
          selfOrigin: selfOrigin.value,
          absoluteOffset,
          fit: props.fit,
          cover: props.cover,
          maxHeight: props.maxHeight,
          maxWidth: props.maxWidth
        });
      }

      function renderPortalContent () {
        return vue.h(
          vue.Transition,
          { name: transition.value, appear: true },
          () => (
            showing.value === true
              ? vue.h('div', {
                  ...attrs,
                  ref: innerRef,
                  tabindex: -1,
                  class: [
                    'q-menu q-position-engine scroll' + menuClass.value,
                    attrs.class
                  ],
                  style: [ attrs.style, transitionStyle.value ],
                  ...onEvents.value
                }, hSlot(slots.default))
              : null
          )
        )
      }

      vue.onBeforeUnmount(anchorCleanup);

      // expose public methods
      Object.assign(proxy, { focus, updatePosition });

      return renderPortal
    }
  });

  var QBtnDropdown = vue.defineComponent({
    name: 'QBtnDropdown',

    props: {
      ...useBtnProps,

      modelValue: Boolean,
      split: Boolean,
      dropdownIcon: String,

      contentClass: [ Array, String, Object ],
      contentStyle: [ Array, String, Object ],

      cover: Boolean,
      persistent: Boolean,
      noRouteDismiss: Boolean,
      autoClose: Boolean,

      menuAnchor: {
        type: String,
        default: 'bottom end'
      },
      menuSelf: {
        type: String,
        default: 'top end'
      },
      menuOffset: Array,

      disableMainBtn: Boolean,
      disableDropdown: Boolean,

      noIconAnimation: Boolean
    },

    emits: [ 'update:modelValue', 'click', 'before-show', 'show', 'before-hide', 'hide' ],

    setup (props, { slots, emit }) {
      const { proxy } = vue.getCurrentInstance();

      const showing = vue.ref(props.modelValue);
      const menuRef = vue.ref(null);

      const attributes = vue.computed(() => {
        const acc = {
          'aria-expanded': showing.value === true ? 'true' : 'false',
          'aria-haspopup': 'true'
        };

        if (
          props.disable === true
          || (
            (props.split === false && props.disableMainBtn === true)
            || props.disableDropdown === true
          )
        ) {
          acc[ 'aria-disabled' ] = 'true';
        }

        return acc
      });

      const iconClass = vue.computed(() =>
        'q-btn-dropdown__arrow'
        + (showing.value === true && props.noIconAnimation === false ? ' rotate-180' : '')
        + (props.split === false ? ' q-btn-dropdown__arrow-container' : '')
      );

      vue.watch(() => props.modelValue, val => {
        menuRef.value !== null && menuRef.value[ val ? 'show' : 'hide' ]();
      });

      vue.watch(() => props.split, hide);

      function onBeforeShow (e) {
        showing.value = true;
        emit('before-show', e);
      }

      function onShow (e) {
        emit('show', e);
        emit('update:modelValue', true);
      }

      function onBeforeHide (e) {
        showing.value = false;
        emit('before-hide', e);
      }

      function onHide (e) {
        emit('hide', e);
        emit('update:modelValue', false);
      }

      function onClick (e) {
        emit('click', e);
      }

      function onClickHide (e) {
        stop(e);
        hide();
        emit('click', e);
      }

      function toggle (evt) {
        menuRef.value !== null && menuRef.value.toggle(evt);
      }

      function show (evt) {
        menuRef.value !== null && menuRef.value.show(evt);
      }

      function hide (evt) {
        menuRef.value !== null && menuRef.value.hide(evt);
      }

      // expose public methods
      Object.assign(proxy, {
        show, hide, toggle
      });

      vue.onMounted(() => {
        props.modelValue === true && show();
      });

      return () => {
        const Arrow = [
          vue.h(QIcon, {
            class: iconClass.value,
            name: props.dropdownIcon || proxy.$q.iconSet.arrow.dropdown
          })
        ];

        props.disableDropdown !== true && Arrow.push(
          vue.h(QMenu, {
            ref: menuRef,
            class: props.contentClass,
            style: props.contentStyle,
            cover: props.cover,
            fit: true,
            persistent: props.persistent,
            noRouteDismiss: props.noRouteDismiss,
            autoClose: props.autoClose,
            anchor: props.menuAnchor,
            self: props.menuSelf,
            offset: props.menuOffset,
            separateClosePopup: true,
            onBeforeShow,
            onShow,
            onBeforeHide,
            onHide
          }, slots.default)
        );

        if (props.split === false) {
          return vue.h(QBtn, {
            class: 'q-btn-dropdown q-btn-dropdown--simple',
            ...props,
            disable: props.disable === true || props.disableMainBtn === true,
            noWrap: true,
            round: false,
            ...attributes.value,
            onClick
          }, () => hSlot(slots.label, []).concat(Arrow))
        }

        return vue.h(QBtnGroup, {
          class: 'q-btn-dropdown q-btn-dropdown--split no-wrap q-btn-item',
          outline: props.outline,
          flat: props.flat,
          rounded: props.rounded,
          push: props.push,
          unelevated: props.glossy,
          stretch: props.stretch
        }, () => [
          vue.h(QBtn, {
            class: 'q-btn-dropdown--current',
            ...props,
            disable: props.disable === true || props.disableMainBtn === true,
            noWrap: true,
            iconRight: props.iconRight,
            round: false,
            onClick: onClickHide
          }, slots.label),

          vue.h(QBtn, {
            class: 'q-btn-dropdown__arrow-container q-anchor--skip',
            ...attributes.value,
            disable: props.disable === true || props.disableDropdown === true,
            outline: props.outline,
            flat: props.flat,
            rounded: props.rounded,
            push: props.push,
            size: props.size,
            color: props.color,
            textColor: props.textColor,
            dense: props.dense,
            ripple: props.ripple
          }, () => Arrow)
        ])
      }
    }
  });

  const useFormProps = {
    name: String
  };

  function useFormAttrs (props) {
    return vue.computed(() => ({
      type: 'hidden',
      name: props.name,
      value: props.modelValue
    }))
  }

  function useFormInject (formAttrs = {}, formDomProps = {}) {
    return (child, action, className) => {
      child[ action ](
        vue.h('input', {
          class: 'hidden' + (className || ''),
          ...formAttrs.value,
          ...formDomProps.value
        })
      );
    }
  }

  function useFormInputNameAttr (props) {
    return vue.computed(() => props.name || props.for)
  }

  var QBtnToggle = vue.defineComponent({
    name: 'QBtnToggle',

    props: {
      ...useFormProps,

      modelValue: {
        required: true
      },

      options: {
        type: Array,
        required: true,
        validator: v => v.every(
          opt => ('label' in opt || 'icon' in opt || 'slot' in opt) && 'value' in opt
        )
      },

      // To avoid seeing the active raise shadow through
      // the transparent button, give it a color (even white)
      color: String,
      textColor: String,
      toggleColor: {
        type: String,
        default: 'primary'
      },
      toggleTextColor: String,

      outline: Boolean,
      flat: Boolean,
      unelevated: Boolean,
      rounded: Boolean,
      push: Boolean,
      glossy: Boolean,

      size: String,
      padding: String,

      noCaps: Boolean,
      noWrap: Boolean,
      dense: Boolean,
      readonly: Boolean,
      disable: Boolean,

      stack: Boolean,
      stretch: Boolean,

      spread: Boolean,

      clearable: Boolean,

      ripple: {
        type: [ Boolean, Object ],
        default: true
      }
    },

    emits: [ 'update:modelValue', 'clear', 'click' ],

    setup (props, { slots, emit }) {
      const hasActiveValue = vue.computed(() =>
        props.options.find(opt => opt.value === props.modelValue) !== void 0
      );

      const formAttrs = vue.computed(() => ({
        type: 'hidden',
        name: props.name,
        value: props.modelValue
      }));

      const injectFormInput = useFormInject(formAttrs);

      const btnOptions = vue.computed(() => props.options.map((item, i) => {
        const { attrs, value, slot, ...opt } = item;

        return {
          slot,
          props: {
            key: i,
            onClick (e) { set(value, item, e); },

            ...attrs,
            ...opt,

            outline: props.outline,
            flat: props.flat,
            rounded: props.rounded,
            push: props.push,
            unelevated: props.unelevated,
            dense: props.dense,

            disable: props.disable === true || opt.disable === true,

            // Options that come from the button specific options first, then from general props
            color: value === props.modelValue
              ? mergeOpt(opt, 'toggleColor')
              : mergeOpt(opt, 'color'),
            textColor: value === props.modelValue
              ? mergeOpt(opt, 'toggleTextColor')
              : mergeOpt(opt, 'textColor'),
            noCaps: mergeOpt(opt, 'noCaps') === true,
            noWrap: mergeOpt(opt, 'noWrap') === true,

            size: mergeOpt(opt, 'size'),
            padding: mergeOpt(opt, 'padding'),
            ripple: mergeOpt(opt, 'ripple'),
            stack: mergeOpt(opt, 'stack') === true,
            stretch: mergeOpt(opt, 'stretch') === true
          }
        }
      }));

      function set (value, opt, e) {
        if (props.readonly !== true) {
          if (props.modelValue === value) {
            if (props.clearable === true) {
              emit('update:modelValue', null, null);
              emit('clear');
            }
          }
          else {
            emit('update:modelValue', value, opt);
          }

          emit('click', e);
        }
      }

      function mergeOpt (opt, key) {
        return opt[ key ] === void 0 ? props[ key ] : opt[ key ]
      }

      function getContent () {
        const child = btnOptions.value.map(opt => {
          return vue.h(QBtn, opt.props, opt.slot !== void 0 ? slots[ opt.slot ] : void 0)
        });

        if (props.name !== void 0 && props.disable !== true && hasActiveValue.value === true) {
          injectFormInput(child, 'push');
        }

        return hMergeSlot(slots.default, child)
      }

      return () => vue.h(QBtnGroup, {
        class: 'q-btn-toggle',
        outline: props.outline,
        flat: props.flat,
        rounded: props.rounded,
        push: props.push,
        stretch: props.stretch,
        unelevated: props.unelevated,
        glossy: props.glossy,
        spread: props.spread
      }, getContent)
    }
  });

  var QCard = vue.defineComponent({
    name: 'QCard',

    props: {
      ...useDarkProps,

      tag: {
        type: String,
        default: 'div'
      },

      square: Boolean,
      flat: Boolean,
      bordered: Boolean
    },

    setup (props, { slots }) {
      const vm = vue.getCurrentInstance();
      const isDark = useDark(props, vm.proxy.$q);

      const classes = vue.computed(() =>
        'q-card'
        + (isDark.value === true ? ' q-card--dark q-dark' : '')
        + (props.bordered === true ? ' q-card--bordered' : '')
        + (props.square === true ? ' q-card--square no-border-radius' : '')
        + (props.flat === true ? ' q-card--flat no-shadow' : '')
      );

      return () => vue.h(props.tag, { class: classes.value }, hSlot(slots.default))
    }
  });

  var QCardSection = vue.defineComponent({
    name: 'QCardSection',

    props: {
      tag: {
        type: String,
        default: 'div'
      },

      horizontal: Boolean
    },

    setup (props, { slots }) {
      const classes = vue.computed(() =>
        'q-card__section'
        + ` q-card__section--${ props.horizontal === true ? 'horiz row no-wrap' : 'vert' }`
      );

      return () => vue.h(props.tag, { class: classes.value }, hSlot(slots.default))
    }
  });

  var QCardActions = vue.defineComponent({
    name: 'QCardActions',

    props: {
      ...useAlignProps,
      vertical: Boolean
    },

    setup (props, { slots }) {
      const alignClass = useAlign(props);

      const classes = vue.computed(() =>
        `q-card__actions ${ alignClass.value }`
        + ` q-card__actions--${ props.vertical === true ? 'vert column' : 'horiz row' }`
      );

      return () => vue.h('div', { class: classes.value }, hSlot(slots.default))
    }
  });

  function parseArg (arg) {
    // delta (min velocity -- dist / time)
    // mobile min distance on first move
    // desktop min distance until deciding if it's a swipe or not
    const data = [ 0.06, 6, 50 ];

    if (typeof arg === 'string' && arg.length) {
      arg.split(':').forEach((val, index) => {
        const v = parseFloat(val);
        v && (data[ index ] = v);
      });
    }

    return data
  }

  var TouchSwipe = {
        name: 'touch-swipe',

        beforeMount (el, { value, arg, modifiers }) {
          // early return, we don't need to do anything
          if (modifiers.mouse !== true && client.has.touch !== true) {
            return
          }

          const mouseCapture = modifiers.mouseCapture === true ? 'Capture' : '';

          const ctx = {
            handler: value,
            sensitivity: parseArg(arg),

            modifiers: modifiers,
            direction: getModifierDirections(modifiers),

            noop,

            mouseStart (evt) {
              if (shouldStart(evt, ctx) && leftClick(evt)) {
                addEvt(ctx, 'temp', [
                  [ document, 'mousemove', 'move', `notPassive${ mouseCapture }` ],
                  [ document, 'mouseup', 'end', 'notPassiveCapture' ]
                ]);
                ctx.start(evt, true);
              }
            },

            touchStart (evt) {
              if (shouldStart(evt, ctx)) {
                const target = getTouchTarget(evt.target);
                addEvt(ctx, 'temp', [
                  [ target, 'touchmove', 'move', 'notPassiveCapture' ],
                  [ target, 'touchcancel', 'end', 'notPassiveCapture' ],
                  [ target, 'touchend', 'end', 'notPassiveCapture' ]
                ]);
                ctx.start(evt);
              }
            },

            start (evt, mouseEvent) {
              client.is.firefox === true && preventDraggable(el, true);

              const pos = position(evt);

              ctx.event = {
                x: pos.left,
                y: pos.top,
                time: Date.now(),
                mouse: mouseEvent === true,
                dir: false
              };
            },

            move (evt) {
              if (ctx.event === void 0) {
                return
              }

              if (ctx.event.dir !== false) {
                stopAndPrevent(evt);
                return
              }

              const time = Date.now() - ctx.event.time;

              if (time === 0) {
                return
              }

              const
                pos = position(evt),
                distX = pos.left - ctx.event.x,
                absX = Math.abs(distX),
                distY = pos.top - ctx.event.y,
                absY = Math.abs(distY);

              if (ctx.event.mouse !== true) {
                if (absX < ctx.sensitivity[ 1 ] && absY < ctx.sensitivity[ 1 ]) {
                  ctx.end(evt);
                  return
                }
              }
              else if (absX < ctx.sensitivity[ 2 ] && absY < ctx.sensitivity[ 2 ]) {
                return
              }

              const
                velX = absX / time,
                velY = absY / time;

              if (
                ctx.direction.vertical === true
                && absX < absY
                && absX < 100
                && velY > ctx.sensitivity[ 0 ]
              ) {
                ctx.event.dir = distY < 0 ? 'up' : 'down';
              }

              if (
                ctx.direction.horizontal === true
                && absX > absY
                && absY < 100
                && velX > ctx.sensitivity[ 0 ]
              ) {
                ctx.event.dir = distX < 0 ? 'left' : 'right';
              }

              if (
                ctx.direction.up === true
                && absX < absY
                && distY < 0
                && absX < 100
                && velY > ctx.sensitivity[ 0 ]
              ) {
                ctx.event.dir = 'up';
              }

              if (
                ctx.direction.down === true
                && absX < absY
                && distY > 0
                && absX < 100
                && velY > ctx.sensitivity[ 0 ]
              ) {
                ctx.event.dir = 'down';
              }

              if (
                ctx.direction.left === true
                && absX > absY
                && distX < 0
                && absY < 100
                && velX > ctx.sensitivity[ 0 ]
              ) {
                ctx.event.dir = 'left';
              }

              if (
                ctx.direction.right === true
                && absX > absY
                && distX > 0
                && absY < 100
                && velX > ctx.sensitivity[ 0 ]
              ) {
                ctx.event.dir = 'right';
              }

              if (ctx.event.dir !== false) {
                stopAndPrevent(evt);

                if (ctx.event.mouse === true) {
                  document.body.classList.add('no-pointer-events--children');
                  document.body.classList.add('non-selectable');
                  clearSelection();

                  ctx.styleCleanup = withDelay => {
                    ctx.styleCleanup = void 0;

                    document.body.classList.remove('non-selectable');

                    const remove = () => {
                      document.body.classList.remove('no-pointer-events--children');
                    };

                    if (withDelay === true) { setTimeout(remove, 50); }
                    else { remove(); }
                  };
                }

                ctx.handler({
                  evt,
                  touch: ctx.event.mouse !== true,
                  mouse: ctx.event.mouse,
                  direction: ctx.event.dir,
                  duration: time,
                  distance: {
                    x: absX,
                    y: absY
                  }
                });
              }
              else {
                ctx.end(evt);
              }
            },

            end (evt) {
              if (ctx.event === void 0) {
                return
              }

              cleanEvt(ctx, 'temp');
              client.is.firefox === true && preventDraggable(el, false);
              ctx.styleCleanup !== void 0 && ctx.styleCleanup(true);
              evt !== void 0 && ctx.event.dir !== false && stopAndPrevent(evt);

              ctx.event = void 0;
            }
          };

          el.__qtouchswipe = ctx;

          modifiers.mouse === true && addEvt(ctx, 'main', [
            [ el, 'mousedown', 'mouseStart', `passive${ mouseCapture }` ]
          ]);

          client.has.touch === true && addEvt(ctx, 'main', [
            [ el, 'touchstart', 'touchStart', `passive${ modifiers.capture === true ? 'Capture' : '' }` ],
            [ el, 'touchmove', 'noop', 'notPassiveCapture' ]
          ]);
        },

        updated (el, mod) {
          const ctx = el.__qtouchswipe;

          if (ctx !== void 0) {
            if (mod.oldValue !== mod.value) {
              typeof mod.value !== 'function' && ctx.end();
              ctx.handler = mod.value;
            }

            ctx.direction = getModifierDirections(mod);
          }
        },

        beforeUnmount (el) {
          const ctx = el.__qtouchswipe;

          if (ctx !== void 0) {
            cleanEvt(ctx, 'main');
            cleanEvt(ctx, 'temp');

            client.is.firefox === true && preventDraggable(el, false);
            ctx.styleCleanup !== void 0 && ctx.styleCleanup();

            delete el.__qtouchswipe;
          }
        }
      };

  function useCache () {
    const cache = new Map();

    return {
      getCache: function (key, obj) {
          return cache[ key ] === void 0
            ? (cache[ key ] = obj)
            : cache[ key ]
        },

      getCacheWithFn: function (key, fn) {
          return cache[ key ] === void 0
            ? (cache[ key ] = fn())
            : cache[ key ]
        }
    }
  }

  const usePanelChildProps = {
    name: { required: true },
    disable: Boolean
  };

  const PanelWrapper$1 = {
    setup (_, { slots }) {
      return () => vue.h('div', {
        class: 'q-panel scroll',
        role: 'tabpanel'
      }, hSlot(slots.default))
    }
  };

  const usePanelProps = {
    modelValue: {
      required: true
    },

    animated: Boolean,
    infinite: Boolean,
    swipeable: Boolean,
    vertical: Boolean,

    transitionPrev: String,
    transitionNext: String,

    keepAlive: Boolean,
    keepAliveInclude: [ String, Array, RegExp ],
    keepAliveExclude: [ String, Array, RegExp ],
    keepAliveMax: Number
  };

  const usePanelEmits = [ 'update:modelValue', 'before-transition', 'transition' ];

  function usePanel () {
    const { props, emit, proxy } = vue.getCurrentInstance();
    const { getCacheWithFn } = useCache();

    let panels, forcedPanelTransition;

    const panelIndex = vue.ref(null);
    const panelTransition = vue.ref(null);

    function onSwipe (evt) {
      const dir = props.vertical === true ? 'up' : 'left';
      goToPanelByOffset((proxy.$q.lang.rtl === true ? -1 : 1) * (evt.direction === dir ? 1 : -1));
    }

    const panelDirectives = vue.computed(() => {
      // if props.swipeable
      return [ [
        TouchSwipe,
        onSwipe,
        void 0,
        {
          horizontal: props.vertical !== true,
          vertical: props.vertical,
          mouse: true
        }
      ] ]
    });

    const transitionPrev = vue.computed(() =>
      props.transitionPrev || `slide-${ props.vertical === true ? 'down' : 'right' }`
    );

    const transitionNext = vue.computed(() =>
      props.transitionNext || `slide-${ props.vertical === true ? 'up' : 'left' }`
    );

    const contentKey = vue.computed(() => (
      typeof props.modelValue === 'string' || typeof props.modelValue === 'number'
        ? props.modelValue
        : String(props.modelValue)
    ));

    const keepAliveProps = vue.computed(() => ({
      include: props.keepAliveInclude,
      exclude: props.keepAliveExclude,
      max: props.keepAliveMax
    }));

    const needsUniqueKeepAliveWrapper = vue.computed(() =>
      props.keepAliveInclude !== void 0
      || props.keepAliveExclude !== void 0
    );

    vue.watch(() => props.modelValue, (newVal, oldVal) => {
      const index = isValidPanelName(newVal) === true
        ? getPanelIndex(newVal)
        : -1;

      if (forcedPanelTransition !== true) {
        updatePanelTransition(
          index === -1 ? 0 : (index < getPanelIndex(oldVal) ? -1 : 1)
        );
      }

      if (panelIndex.value !== index) {
        panelIndex.value = index;
        emit('before-transition', newVal, oldVal);
        vue.nextTick(() => {
          emit('transition', newVal, oldVal);
        });
      }
    });

    function nextPanel () { goToPanelByOffset(1); }
    function previousPanel () { goToPanelByOffset(-1); }

    // expose public methods
    Object.assign(proxy, {
      next: nextPanel,
      previous: previousPanel,
      goTo: goToPanel
    });

    function goToPanel (name) {
      emit('update:modelValue', name);
    }

    function isValidPanelName (name) {
      return name !== void 0 && name !== null && name !== ''
    }

    function getPanelIndex (name) {
      return panels.findIndex(panel => {
        return panel.props.name === name
          && panel.props.disable !== ''
          && panel.props.disable !== true
      })
    }

    function getEnabledPanels () {
      return panels.filter(panel => {
        return panel.props.disable !== ''
          && panel.props.disable !== true
      })
    }

    function updatePanelTransition (direction) {
      const val = direction !== 0 && props.animated === true && panelIndex.value !== -1
        ? 'q-transition--' + (direction === -1 ? transitionPrev.value : transitionNext.value)
        : null;

      if (panelTransition.value !== val) {
        panelTransition.value = val;
      }
    }

    function goToPanelByOffset (direction, startIndex = panelIndex.value) {
      let index = startIndex + direction;

      while (index > -1 && index < panels.length) {
        const opt = panels[ index ];

        if (
          opt !== void 0
          && opt.props.disable !== ''
          && opt.props.disable !== true
        ) {
          updatePanelTransition(direction);
          forcedPanelTransition = true;
          emit('update:modelValue', opt.props.name);
          setTimeout(() => {
            forcedPanelTransition = false;
          });
          return
        }

        index += direction;
      }

      if (props.infinite === true && panels.length > 0 && startIndex !== -1 && startIndex !== panels.length) {
        goToPanelByOffset(direction, direction === -1 ? panels.length : -1);
      }
    }

    function updatePanelIndex () {
      const index = getPanelIndex(props.modelValue);

      if (panelIndex.value !== index) {
        panelIndex.value = index;
      }

      return true
    }

    function getPanelContentChild () {
      const panel = isValidPanelName(props.modelValue)
        && updatePanelIndex()
        && panels[ panelIndex.value ];

      return props.keepAlive === true
        ? [
            vue.h(vue.KeepAlive, keepAliveProps.value, [
              vue.h(
                needsUniqueKeepAliveWrapper.value === true
                  ? getCacheWithFn(contentKey.value, () => ({ ...PanelWrapper$1, name: contentKey.value }))
                  : PanelWrapper$1,
                { key: contentKey.value },
                () => panel
              )
            ])
          ]
        : [
            vue.h('div', {
              class: 'q-panel scroll',
              key: contentKey.value,
              role: 'tabpanel'
            }, [ panel ])
          ]
    }

    function getPanelContent () {
      if (panels.length === 0) {
        return
      }

      return props.animated === true
        ? [
            vue.h(vue.Transition, {
              name: panelTransition.value
            }, getPanelContentChild)
          ]
        : getPanelContentChild()
    }

    function updatePanelsList (slots) {
      panels = getNormalizedVNodes(
        hSlot(slots.default, [])
      ).filter(
        panel => panel.props !== null
          && panel.props.slot === void 0
          && isValidPanelName(panel.props.name)
      );

      return panels.length
    }

    function getPanels () {
      return panels
    }

    return {
      panelIndex,
      panelDirectives,

      updatePanelsList,
      updatePanelIndex,

      getPanelContent,
      getEnabledPanels,
      getPanels,

      isValidPanelName,

      keepAliveProps,
      needsUniqueKeepAliveWrapper,

      goToPanelByOffset,
      goToPanel,

      nextPanel,
      previousPanel
    }
  }

  const useFullscreenProps = {
    fullscreen: Boolean,
    noRouteFullscreenExit: Boolean
  };

  const useFullscreenEmits = [ 'update:fullscreen', 'fullscreen' ];

  function useFullscreen () {
    const vm = vue.getCurrentInstance();
    const { props, emit, proxy } = vm;

    let historyEntry, fullscreenFillerNode, container;
    const inFullscreen = vue.ref(false);

    vmHasRouter(vm) === true && vue.watch(() => proxy.$route, () => {
      props.noRouteFullscreenExit !== true && exitFullscreen();
    });

    vue.watch(() => props.fullscreen, v => {
      if (inFullscreen.value !== v) {
        toggleFullscreen();
      }
    });

    vue.watch(inFullscreen, v => {
      emit('update:fullscreen', v);
      emit('fullscreen', v);
    });

    function toggleFullscreen () {
      if (inFullscreen.value === true) {
        exitFullscreen();
      }
      else {
        setFullscreen();
      }
    }

    function setFullscreen () {
      if (inFullscreen.value === true) {
        return
      }

      inFullscreen.value = true;
      container = proxy.$el.parentNode;
      container.replaceChild(fullscreenFillerNode, proxy.$el);
      document.body.appendChild(proxy.$el);
      document.body.classList.add('q-body--fullscreen-mixin');

      historyEntry = {
        handler: exitFullscreen
      };
      History.add(historyEntry);
    }

    function exitFullscreen () {
      if (inFullscreen.value !== true) {
        return
      }

      if (historyEntry !== void 0) {
        History.remove(historyEntry);
        historyEntry = void 0;
      }

      container.replaceChild(proxy.$el, fullscreenFillerNode);
      document.body.classList.remove('q-body--fullscreen-mixin');
      inFullscreen.value = false;

      if (proxy.$el.scrollIntoView !== void 0) {
        setTimeout(() => { proxy.$el.scrollIntoView(); });
      }
    }

    vue.onBeforeMount(() => {
      fullscreenFillerNode = document.createElement('span');
    });

    vue.onMounted(() => {
      props.fullscreen === true && setFullscreen();
    });

    vue.onBeforeUnmount(exitFullscreen);

    // expose public methods
    Object.assign(proxy, {
      toggleFullscreen,
      setFullscreen,
      exitFullscreen
    });

    return {
      inFullscreen,
      toggleFullscreen
    }
  }

  const
    hasMap = typeof Map === 'function',
    hasSet = typeof Set === 'function',
    hasArrayBuffer = typeof ArrayBuffer === 'function';

  function isDeepEqual (a, b) {
    if (a === b) {
      return true
    }

    if (a !== null && b !== null && typeof a === 'object' && typeof b === 'object') {
      if (a.constructor !== b.constructor) {
        return false
      }

      let length, i;

      if (a.constructor === Array) {
        length = a.length;

        if (length !== b.length) {
          return false
        }

        for (i = length; i-- !== 0;) {
          if (isDeepEqual(a[ i ], b[ i ]) !== true) {
            return false
          }
        }

        return true
      }

      if (hasMap === true && a.constructor === Map) {
        if (a.size !== b.size) {
          return false
        }

        i = a.entries().next();
        while (i.done !== true) {
          if (b.has(i.value[ 0 ]) !== true) {
            return false
          }
          i = i.next();
        }

        i = a.entries().next();
        while (i.done !== true) {
          if (isDeepEqual(i.value[ 1 ], b.get(i.value[ 0 ])) !== true) {
            return false
          }
          i = i.next();
        }

        return true
      }

      if (hasSet === true && a.constructor === Set) {
        if (a.size !== b.size) {
          return false
        }

        i = a.entries().next();
        while (i.done !== true) {
          if (b.has(i.value[ 0 ]) !== true) {
            return false
          }
          i = i.next();
        }

        return true
      }

      if (hasArrayBuffer === true && a.buffer != null && a.buffer.constructor === ArrayBuffer) {
        length = a.length;

        if (length !== b.length) {
          return false
        }

        for (i = length; i-- !== 0;) {
          if (a[ i ] !== b[ i ]) {
            return false
          }
        }

        return true
      }

      if (a.constructor === RegExp) {
        return a.source === b.source && a.flags === b.flags
      }

      if (a.valueOf !== Object.prototype.valueOf) {
        return a.valueOf() === b.valueOf()
      }

      if (a.toString !== Object.prototype.toString) {
        return a.toString() === b.toString()
      }

      const keys = Object.keys(a);
      length = keys.length;

      if (length !== Object.keys(b).length) {
        return false
      }

      for (i = length; i-- !== 0;) {
        const key = keys[ i ];
        if (isDeepEqual(a[ key ], b[ key ]) !== true) {
          return false
        }
      }

      return true
    }

    // true if both NaN, false otherwise
    return a !== a && b !== b // eslint-disable-line no-self-compare
  }

  function isDate (v) {
    return Object.prototype.toString.call(v) === '[object Date]'
  }

  function isNumber (v) {
    return typeof v === 'number' && isFinite(v)
  }

  const navigationPositionOptions = [ 'top', 'right', 'bottom', 'left' ];
  const controlTypeOptions = [ 'regular', 'flat', 'outline', 'push', 'unelevated' ];

  var QCarousel = vue.defineComponent({
    name: 'QCarousel',

    props: {
      ...useDarkProps,
      ...usePanelProps,
      ...useFullscreenProps,

      transitionPrev: { // usePanelParentProps override
        type: String,
        default: 'fade'
      },
      transitionNext: { // usePanelParentProps override
        type: String,
        default: 'fade'
      },

      height: String,
      padding: Boolean,

      controlColor: String,
      controlTextColor: String,
      controlType: {
        type: String,
        validator: v => controlTypeOptions.includes(v),
        default: 'flat'
      },

      autoplay: [ Number, Boolean ],

      arrows: Boolean,
      prevIcon: String,
      nextIcon: String,

      navigation: Boolean,
      navigationPosition: {
        type: String,
        validator: v => navigationPositionOptions.includes(v)
      },
      navigationIcon: String,
      navigationActiveIcon: String,

      thumbnails: Boolean
    },

    emits: [
      ...useFullscreenEmits,
      ...usePanelEmits
    ],

    setup (props, { slots }) {
      const { proxy: { $q } } = vue.getCurrentInstance();

      const isDark = useDark(props, $q);

      let timer, panelsLen;

      const {
        updatePanelsList, getPanelContent,
        panelDirectives, goToPanel,
        previousPanel, nextPanel, getEnabledPanels,
        panelIndex
      } = usePanel();

      const { inFullscreen } = useFullscreen();

      const style = vue.computed(() => (
        inFullscreen.value !== true && props.height !== void 0
          ? { height: props.height }
          : {}
      ));

      const direction = vue.computed(() => (props.vertical === true ? 'vertical' : 'horizontal'));

      const classes = vue.computed(() =>
        `q-carousel q-panel-parent q-carousel--with${ props.padding === true ? '' : 'out' }-padding`
        + (inFullscreen.value === true ? ' fullscreen' : '')
        + (isDark.value === true ? ' q-carousel--dark q-dark' : '')
        + (props.arrows === true ? ` q-carousel--arrows-${ direction.value }` : '')
        + (props.navigation === true ? ` q-carousel--navigation-${ navigationPosition.value }` : '')
      );

      const arrowIcons = vue.computed(() => {
        const ico = [
          props.prevIcon || $q.iconSet.carousel[ props.vertical === true ? 'up' : 'left' ],
          props.nextIcon || $q.iconSet.carousel[ props.vertical === true ? 'down' : 'right' ]
        ];

        return props.vertical === false && $q.lang.rtl === true
          ? ico.reverse()
          : ico
      });

      const navIcon = vue.computed(() => props.navigationIcon || $q.iconSet.carousel.navigationIcon);
      const navActiveIcon = vue.computed(() => props.navigationActiveIcon || navIcon.value);
      const navigationPosition = vue.computed(() => props.navigationPosition
        || (props.vertical === true ? 'right' : 'bottom')
      );

      const controlProps = vue.computed(() => ({
        color: props.controlColor,
        textColor: props.controlTextColor,
        round: true,
        [ props.controlType ]: true,
        dense: true
      }));

      vue.watch(() => props.modelValue, () => {
        if (props.autoplay) {
          clearInterval(timer);
          startTimer();
        }
      });

      vue.watch(() => props.autoplay, val => {
        if (val) {
          startTimer();
        }
        else {
          clearInterval(timer);
        }
      });

      function startTimer () {
        timer = setTimeout(nextPanel, isNumber(props.autoplay) ? props.autoplay : 5000);
      }

      vue.onMounted(() => {
        props.autoplay && startTimer();
      });

      vue.onBeforeUnmount(() => {
        clearInterval(timer);
      });

      function getNavigationContainer (type, mapping) {
        return vue.h('div', {
          class: 'q-carousel__control q-carousel__navigation no-wrap absolute flex'
            + ` q-carousel__navigation--${ type } q-carousel__navigation--${ navigationPosition.value }`
            + (props.controlColor !== void 0 ? ` text-${ props.controlColor }` : '')
        }, [
          vue.h('div', {
            class: 'q-carousel__navigation-inner flex flex-center no-wrap'
          }, getEnabledPanels().map(mapping))
        ])
      }

      function getContent () {
        const node = [];

        if (props.navigation === true) {
          const fn = slots[ 'navigation-icon' ] !== void 0
            ? slots[ 'navigation-icon' ]
            : opts => vue.h(QBtn, {
              key: 'nav' + opts.name,
              class: `q-carousel__navigation-icon q-carousel__navigation-icon--${ opts.active === true ? '' : 'in' }active`,
              ...opts.btnProps,
              onClick: opts.onClick
            });

          const maxIndex = panelsLen - 1;
          node.push(
            getNavigationContainer('buttons', (panel, index) => {
              const name = panel.props.name;
              const active = panelIndex.value === index;

              return fn({
                index,
                maxIndex,
                name,
                active,
                btnProps: {
                  icon: active === true ? navActiveIcon.value : navIcon.value,
                  size: 'sm',
                  ...controlProps.value
                },
                onClick: () => { goToPanel(name); }
              })
            })
          );
        }
        else if (props.thumbnails === true) {
          const color = props.controlColor !== void 0
            ? ` text-${ props.controlColor }`
            : '';

          node.push(getNavigationContainer('thumbnails', panel => {
            const slide = panel.props;

            return vue.h('img', {
              key: 'tmb#' + slide.name,
              class: `q-carousel__thumbnail q-carousel__thumbnail--${ slide.name === props.modelValue ? '' : 'in' }active` + color,
              src: slide.imgSrc || slide[ 'img-src' ],
              onClick: () => { goToPanel(slide.name); }
            })
          }));
        }

        if (props.arrows === true && panelIndex.value >= 0) {
          if (props.infinite === true || panelIndex.value > 0) {
            node.push(
              vue.h('div', {
                key: 'prev',
                class: `q-carousel__control q-carousel__arrow q-carousel__prev-arrow q-carousel__prev-arrow--${ direction.value } absolute flex flex-center`
              }, [
                vue.h(QBtn, {
                  icon: arrowIcons.value[ 0 ],
                  ...controlProps.value,
                  onClick: previousPanel
                })
              ])
            );
          }

          if (props.infinite === true || panelIndex.value < panelsLen - 1) {
            node.push(
              vue.h('div', {
                key: 'next',
                class: 'q-carousel__control q-carousel__arrow q-carousel__next-arrow'
                  + ` q-carousel__next-arrow--${ direction.value } absolute flex flex-center`
              }, [
                vue.h(QBtn, {
                  icon: arrowIcons.value[ 1 ],
                  ...controlProps.value,
                  onClick: nextPanel
                })
              ])
            );
          }
        }

        return hMergeSlot(slots.control, node)
      }

      return () => {
        panelsLen = updatePanelsList(slots);

        return vue.h('div', {
          class: classes.value,
          style: style.value
        }, [
          hDir(
            'div',
            { class: 'q-carousel__slides-container' },
            getPanelContent(),
            'sl-cont',
            props.swipeable,
            () => panelDirectives.value
          )
        ].concat(getContent()))
      }
    }
  });

  var QCarouselSlide = vue.defineComponent({
    name: 'QCarouselSlide',

    props: {
      ...usePanelChildProps,
      imgSrc: String
    },

    setup (props, { slots }) {
      const style = vue.computed(() => (
        props.imgSrc
          ? { backgroundImage: `url("${ props.imgSrc }")` }
          : {}
      ));

      return () => vue.h('div', {
        class: 'q-carousel__slide',
        style: style.value
      }, hSlot(slots.default))
    }
  });

  var QCarouselControl = vue.defineComponent({
    name: 'QCarouselControl',

    props: {
      position: {
        type: String,
        default: 'bottom-right',
        validator: v => [
          'top-right', 'top-left',
          'bottom-right', 'bottom-left',
          'top', 'right', 'bottom', 'left'
        ].includes(v)
      },
      offset: {
        type: Array,
        default: () => [ 18, 18 ],
        validator: v => v.length === 2
      }
    },

    setup (props, { slots }) {
      const classes = vue.computed(() => `q-carousel__control absolute absolute-${ props.position }`);
      const style = vue.computed(() => ({
        margin: `${ props.offset[ 1 ] }px ${ props.offset[ 0 ] }px`
      }));

      return () => vue.h('div', {
        class: classes.value,
        style: style.value
      }, hSlot(slots.default))
    }
  });

  var QChatMessage = vue.defineComponent({
    name: 'QChatMessage',

    props: {
      sent: Boolean,
      label: String,
      bgColor: String,
      textColor: String,
      name: String,
      avatar: String,
      text: Array,
      stamp: String,
      size: String,
      labelHtml: Boolean,
      nameHtml: Boolean,
      textHtml: Boolean,
      stampHtml: Boolean
    },

    setup (props, { slots }) {
      const op = vue.computed(() => (props.sent === true ? 'sent' : 'received'));

      const textClass = vue.computed(() =>
        `q-message-text-content q-message-text-content--${ op.value }`
        + (props.textColor !== void 0 ? ` text-${ props.textColor }` : '')
      );

      const messageClass = vue.computed(() =>
        `q-message-text q-message-text--${ op.value }`
        + (props.bgColor !== void 0 ? ` text-${ props.bgColor }` : '')
      );

      const containerClass = vue.computed(() =>
        'q-message-container row items-end no-wrap'
        + (props.sent === true ? ' reverse' : '')
      );

      const sizeClass = vue.computed(() => (props.size !== void 0 ? `col-${ props.size }` : ''));

      const domProps = vue.computed(() => ({
        msg: props.textHtml === true ? 'innerHTML' : 'textContent',
        stamp: props.stampHtml === true ? 'innerHTML' : 'textContent',
        name: props.nameHtml === true ? 'innerHTML' : 'textContent',
        label: props.labelHtml === true ? 'innerHTML' : 'textContent'
      }));

      function wrapStamp (node) {
        if (slots.stamp !== void 0) {
          return [ node, vue.h('div', { class: 'q-message-stamp' }, slots.stamp()) ]
        }

        if (props.stamp) {
          return [
            node,
            vue.h('div', {
              class: 'q-message-stamp',
              [ domProps.value.stamp ]: props.stamp
            })
          ]
        }

        return [ node ]
      }

      function getText (contentList, withSlots) {
        const content = withSlots === true
          ? (contentList.length > 1 ? text => text : text => vue.h('div', [ text ]))
          : text => vue.h('div', { [ domProps.value.msg ]: text });

        return contentList.map((msg, index) => vue.h('div', {
          key: index,
          class: messageClass.value
        }, [
          vue.h('div', { class: textClass.value }, wrapStamp(content(msg)))
        ]))
      }

      return () => {
        const container = [];

        if (slots.avatar !== void 0) {
          container.push(slots.avatar());
        }
        else if (props.avatar !== void 0) {
          container.push(
            vue.h('img', {
              class: `q-message-avatar q-message-avatar--${ op.value }`,
              src: props.avatar,
              'aria-hidden': 'true'
            })
          );
        }

        const msg = [];

        if (slots.name !== void 0) {
          msg.push(
            vue.h('div', { class: `q-message-name q-message-name--${ op.value }` }, slots.name())
          );
        }
        else if (props.name !== void 0) {
          msg.push(
            vue.h('div', {
              class: `q-message-name q-message-name--${ op.value }`,
              [ domProps.value.name ]: props.name
            })
          );
        }

        if (slots.default !== void 0) {
          msg.push(
            getText(
              getNormalizedVNodes(slots.default()),
              true
            )
          );
        }
        else if (props.text !== void 0) {
          msg.push(getText(props.text));
        }

        container.push(
          vue.h('div', { class: sizeClass.value }, msg)
        );

        const child = [];

        if (slots.label !== void 0) {
          child.push(
            vue.h('div', { class: 'q-message-label' }, slots.label())
          );
        }
        else if (props.label !== void 0) {
          child.push(
            vue.h('div', {
              class: 'q-message-label',
              [ domProps.value.label ]: props.label
            })
          );
        }

        child.push(
          vue.h('div', { class: containerClass.value }, container)
        );

        return vue.h('div', {
          class: `q-message q-message-${ op.value }`
        }, child)
      }
    }
  });

  function useRefocusTarget (props, rootRef) {
    const refocusRef = vue.ref(null);

    const refocusTargetEl = vue.computed(() => {
      if (props.disable !== true) {
        return null
      }

      return vue.h('span', {
        ref: refocusRef,
        class: 'no-outline',
        tabindex: -1
      })
    });

    function refocusTarget (e) {
      if (e !== void 0 && e.type.indexOf('key') === 0) {
        if (document.activeElement !== rootRef.value && rootRef.value.contains(document.activeElement) === true) {
          rootRef.value.focus();
        }
      }
      else if ((e === void 0 || rootRef.value.contains(e.target) === true) && refocusRef.value !== null) {
        refocusRef.value.focus();
      }
    }

    return {
      refocusTargetEl,
      refocusTarget
    }
  }

  var optionSizes = {
    xs: 30,
    sm: 35,
    md: 40,
    lg: 50,
    xl: 60
  };

  const useCheckboxProps = {
    ...useDarkProps,
    ...useSizeProps,
    ...useFormProps,

    modelValue: {
      required: true,
      default: null
    },
    val: {},

    trueValue: { default: true },
    falseValue: { default: false },
    indeterminateValue: { default: null },

    toggleOrder: {
      type: String,
      validator: v => v === 'tf' || v === 'ft'
    },
    toggleIndeterminate: Boolean,

    label: String,
    leftLabel: Boolean,

    color: String,
    keepColor: Boolean,
    dense: Boolean,

    disable: Boolean,
    tabindex: [ String, Number ]
  };

  const useCheckboxEmits = [ 'update:modelValue' ];

  function useCheckbox (type, getInner) {
    const { props, slots, emit, proxy } = vue.getCurrentInstance();
    const { $q } = proxy;

    const isDark = useDark(props, $q);

    const rootRef = vue.ref(null);
    const { refocusTargetEl, refocusTarget } = useRefocusTarget(props, rootRef);
    const sizeStyle = useSize(props, optionSizes);

    const modelIsArray = vue.computed(() =>
      props.val !== void 0 && Array.isArray(props.modelValue)
    );

    const index = vue.computed(() => (
      modelIsArray.value === true
        ? props.modelValue.indexOf(props.val)
        : -1
    ));

    const isTrue = vue.computed(() => (
      modelIsArray.value === true
        ? index.value > -1
        : props.modelValue === props.trueValue
    ));

    const isFalse = vue.computed(() => (
      modelIsArray.value === true
        ? index.value === -1
        : props.modelValue === props.falseValue
    ));

    const isIndeterminate = vue.computed(() =>
      isTrue.value === false && isFalse.value === false
    );

    const tabindex = vue.computed(() => (
      props.disable === true ? -1 : props.tabindex || 0
    ));

    const classes = vue.computed(() =>
      `q-${ type } cursor-pointer no-outline row inline no-wrap items-center`
      + (props.disable === true ? ' disabled' : '')
      + (isDark.value === true ? ` q-${ type }--dark` : '')
      + (props.dense === true ? ` q-${ type }--dense` : '')
      + (props.leftLabel === true ? ' reverse' : '')
    );

    const innerClass = vue.computed(() => {
      const state = isTrue.value === true ? 'truthy' : (isFalse.value === true ? 'falsy' : 'indet');
      const color = props.color !== void 0 && (
        props.keepColor === true
        || (type === 'toggle' ? isTrue.value === true : isFalse.value !== true)
      )
        ? ` text-${ props.color }`
        : '';

      return `q-${ type }__inner relative-position non-selectable q-${ type }__inner--${ state }${ color }`
    });

    const formAttrs = vue.computed(() => {
      const prop = { type: 'checkbox' };

      props.name !== void 0 && Object.assign(prop, {
        checked: isTrue.value,
        name: props.name,
        value: modelIsArray.value === true
          ? props.val
          : props.trueValue
      });

      return prop
    });

    const injectFormInput = useFormInject(formAttrs);

    const attributes = vue.computed(() => {
      const attrs = {
        tabindex: tabindex.value,
        role: 'checkbox',
        'aria-label': props.label,
        'aria-checked': isIndeterminate.value === true
          ? 'mixed'
          : (isTrue.value === true ? 'true' : 'false')
      };

      if (props.disable === true) {
        attrs[ 'aria-disabled' ] = 'true';
      }

      return attrs
    });

    function onClick (e) {
      if (e !== void 0) {
        stopAndPrevent(e);
        refocusTarget(e);
      }

      if (props.disable !== true) {
        emit('update:modelValue', getNextValue(), e);
      }
    }

    function getNextValue () {
      if (modelIsArray.value === true) {
        if (isTrue.value === true) {
          const val = props.modelValue.slice();
          val.splice(index.value, 1);
          return val
        }

        return props.modelValue.concat([ props.val ])
      }

      if (isTrue.value === true) {
        if (props.toggleOrder !== 'ft' || props.toggleIndeterminate === false) {
          return props.falseValue
        }
      }
      else if (isFalse.value === true) {
        if (props.toggleOrder === 'ft' || props.toggleIndeterminate === false) {
          return props.trueValue
        }
      }
      else {
        return props.toggleOrder !== 'ft'
          ? props.trueValue
          : props.falseValue
      }

      return props.indeterminateValue
    }

    function onKeydown (e) {
      if (e.keyCode === 13 || e.keyCode === 32) {
        stopAndPrevent(e);
      }
    }

    function onKeyup (e) {
      if (e.keyCode === 13 || e.keyCode === 32) {
        onClick(e);
      }
    }

    const getInnerContent = getInner(isTrue, isIndeterminate);

    // expose public methods
    Object.assign(proxy, { toggle: onClick });

    return () => {
      const inner = getInnerContent();

      props.disable !== true && injectFormInput(
        inner,
        'unshift',
        ` q-${ type }__native absolute q-ma-none q-pa-none`
      );

      const child = [
        vue.h('div', {
          class: innerClass.value,
          style: sizeStyle.value
        }, inner)
      ];

      if (refocusTargetEl.value !== null) {
        child.push(refocusTargetEl.value);
      }

      const label = props.label !== void 0
        ? hMergeSlot(slots.default, [ props.label ])
        : hSlot(slots.default);

      label !== void 0 && child.push(
        vue.h('div', {
          class: `q-${ type }__label q-anchor--skip`
        }, label)
      );

      return vue.h('div', {
        ref: rootRef,
        class: classes.value,
        ...attributes.value,
        onClick,
        onKeydown,
        onKeyup
      }, child)
    }
  }

  const bgNode = vue.h('div', {
    class: 'q-checkbox__bg absolute'
  }, [
    vue.h('svg', {
      class: 'q-checkbox__svg fit absolute-full',
      viewBox: '0 0 24 24',
      'aria-hidden': 'true'
    }, [
      vue.h('path', {
        class: 'q-checkbox__truthy',
        fill: 'none',
        d: 'M1.73,12.91 8.1,19.28 22.79,4.59'
      }),

      vue.h('path', {
        class: 'q-checkbox__indet',
        d: 'M4,14H20V10H4'
      })
    ])
  ]);

  var QCheckbox = vue.defineComponent({
    name: 'QCheckbox',

    props: useCheckboxProps,
    emits: useCheckboxEmits,

    setup () {
      return useCheckbox('checkbox', () => () => [ bgNode ])
    }
  });

  const defaultSizes$1 = {
    xs: 8,
    sm: 10,
    md: 14,
    lg: 20,
    xl: 24
  };

  var QChip = vue.defineComponent({
    name: 'QChip',

    props: {
      ...useDarkProps,
      ...useSizeProps,

      dense: Boolean,

      icon: String,
      iconRight: String,
      iconRemove: String,
      iconSelected: String,
      label: [ String, Number ],

      color: String,
      textColor: String,

      modelValue: {
        type: Boolean,
        default: true
      },
      selected: {
        type: Boolean,
        default: null
      },

      square: Boolean,
      outline: Boolean,
      clickable: Boolean,
      removable: Boolean,

      tabindex: [ String, Number ],
      disable: Boolean,

      ripple: {
        type: [ Boolean, Object ],
        default: true
      }
    },

    emits: [ 'update:modelValue', 'update:selected', 'remove', 'click' ],

    setup (props, { slots, emit }) {
      const { proxy: { $q } } = vue.getCurrentInstance();

      const isDark = useDark(props, $q);
      const sizeStyle = useSize(props, defaultSizes$1);

      const hasLeftIcon = vue.computed(() => props.selected === true || props.icon !== void 0);

      const leftIcon = vue.computed(() => (
        props.selected === true
          ? props.iconSelected || $q.iconSet.chip.selected
          : props.icon
      ));

      const removeIcon = vue.computed(() => props.iconRemove || $q.iconSet.chip.remove);

      const isClickable = vue.computed(() =>
        props.disable === false
        && (props.clickable === true || props.selected !== null)
      );

      const classes = vue.computed(() => {
        const text = props.outline === true
          ? props.color || props.textColor
          : props.textColor;

        return 'q-chip row inline no-wrap items-center'
          + (props.outline === false && props.color !== void 0 ? ` bg-${ props.color }` : '')
          + (text ? ` text-${ text } q-chip--colored` : '')
          + (props.disable === true ? ' disabled' : '')
          + (props.dense === true ? ' q-chip--dense' : '')
          + (props.outline === true ? ' q-chip--outline' : '')
          + (props.selected === true ? ' q-chip--selected' : '')
          + (isClickable.value === true ? ' q-chip--clickable cursor-pointer non-selectable q-hoverable' : '')
          + (props.square === true ? ' q-chip--square' : '')
          + (isDark.value === true ? ' q-chip--dark q-dark' : '')
      });

      const attributes = vue.computed(() => (
        props.disable === true
          ? { tabindex: -1, 'aria-disabled': 'true' }
          : { tabindex: props.tabindex || 0 }
      ));

      function onKeyup (e) {
        e.keyCode === 13 /* ENTER */ && onClick(e);
      }

      function onClick (e) {
        if (!props.disable) {
          emit('update:selected', !props.selected);
          emit('click', e);
        }
      }

      function onRemove (e) {
        if (e.keyCode === void 0 || e.keyCode === 13) {
          stopAndPrevent(e);
          if (props.disable === false) {
            emit('update:modelValue', false);
            emit('remove');
          }
        }
      }

      function getContent () {
        const child = [];

        isClickable.value === true && child.push(
          vue.h('div', { class: 'q-focus-helper' })
        );

        hasLeftIcon.value === true && child.push(
          vue.h(QIcon, {
            class: 'q-chip__icon q-chip__icon--left',
            name: leftIcon.value
          })
        );

        const label = props.label !== void 0
          ? [ vue.h('div', { class: 'ellipsis' }, [ props.label ]) ]
          : void 0;

        child.push(
          vue.h('div', {
            class: 'q-chip__content col row no-wrap items-center q-anchor--skip'
          }, hMergeSlotSafely(slots.default, label))
        );

        props.iconRight && child.push(
          vue.h(QIcon, {
            class: 'q-chip__icon q-chip__icon--right',
            name: props.iconRight
          })
        );

        props.removable === true && child.push(
          vue.h(QIcon, {
            class: 'q-chip__icon q-chip__icon--remove cursor-pointer',
            name: removeIcon.value,
            ...attributes.value,
            onClick: onRemove,
            onKeyup: onRemove
          })
        );

        return child
      }

      return () => {
        if (props.modelValue === false) { return }

        const data = {
          class: classes.value,
          style: sizeStyle.value
        };

        isClickable.value === true && Object.assign(
          data,
          attributes.value,
          { onClick, onKeyup }
        );

        return hDir(
          'div',
          data,
          getContent(),
          'ripple',
          props.ripple !== false && props.disable !== true,
          () => [ [ Ripple, props.ripple ] ]
        )
      }
    }
  });

  // also used by QKnob
  const useCircularCommonProps = {
    ...useSizeProps,

    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },

    color: String,
    centerColor: String,
    trackColor: String,

    fontSize: String,

    // ratio
    thickness: {
      type: Number,
      default: 0.2,
      validator: v => v >= 0 && v <= 1
    },

    angle: {
      type: Number,
      default: 0
    },

    showValue: Boolean,
    reverse: Boolean,

    instantFeedback: Boolean
  };

  const
    radius = 50,
    diameter = 2 * radius,
    circumference = diameter * Math.PI,
    strokeDashArray = Math.round(circumference * 1000) / 1000;

  var QCircularProgress = vue.defineComponent({
    name: 'QCircularProgress',

    props: {
      ...useCircularCommonProps,

      value: {
        type: Number,
        default: 0
      },

      indeterminate: Boolean
    },

    setup (props, { slots }) {
      const { proxy: { $q } } = vue.getCurrentInstance();
      const sizeStyle = useSize(props);

      const svgStyle = vue.computed(() => {
        const angle = ($q.lang.rtl === true ? -1 : 1) * props.angle;

        return {
          transform: props.reverse !== ($q.lang.rtl === true)
            ? `scale3d(-1, 1, 1) rotate3d(0, 0, 1, ${ -90 - angle }deg)`
            : `rotate3d(0, 0, 1, ${ angle - 90 }deg)`
        }
      });

      const circleStyle = vue.computed(() => (
        props.instantFeedback !== true && props.indeterminate !== true
          ? { transition: 'stroke-dashoffset 0.6s ease 0s, stroke 0.6s ease' }
          : ''
      ));

      const viewBox = vue.computed(() => diameter / (1 - props.thickness / 2));

      const viewBoxAttr = vue.computed(() =>
        `${ viewBox.value / 2 } ${ viewBox.value / 2 } ${ viewBox.value } ${ viewBox.value }`
      );

      const normalized = vue.computed(() => between(props.value, props.min, props.max));

      const strokeDashOffset = vue.computed(() => circumference * (
        1 - (normalized.value - props.min) / (props.max - props.min)
      ));

      const strokeWidth = vue.computed(() => props.thickness / 2 * viewBox.value);

      function getCircle ({ thickness, offset, color, cls }) {
        return vue.h('circle', {
          class: 'q-circular-progress__' + cls + (color !== void 0 ? ` text-${ color }` : ''),
          style: circleStyle.value,
          fill: 'transparent',
          stroke: 'currentColor',
          'stroke-width': thickness,
          'stroke-dasharray': strokeDashArray,
          'stroke-dashoffset': offset,
          cx: viewBox.value,
          cy: viewBox.value,
          r: radius
        })
      }

      return () => {
        const svgChild = [];

        props.centerColor !== void 0 && props.centerColor !== 'transparent' && svgChild.push(
          vue.h('circle', {
            class: `q-circular-progress__center text-${ props.centerColor }`,
            fill: 'currentColor',
            r: radius - strokeWidth.value / 2,
            cx: viewBox.value,
            cy: viewBox.value
          })
        );

        props.trackColor !== void 0 && props.trackColor !== 'transparent' && svgChild.push(
          getCircle({
            cls: 'track',
            thickness: strokeWidth.value,
            offset: 0,
            color: props.trackColor
          })
        );

        svgChild.push(
          getCircle({
            cls: 'circle',
            thickness: strokeWidth.value,
            offset: strokeDashOffset.value,
            color: props.color
          })
        );

        const child = [
          vue.h('svg', {
            class: 'q-circular-progress__svg',
            style: svgStyle.value,
            viewBox: viewBoxAttr.value,
            'aria-hidden': 'true'
          }, svgChild)
        ];

        props.showValue === true && child.push(
          vue.h('div', {
            class: 'q-circular-progress__text absolute-full row flex-center content-center',
            style: { fontSize: props.fontSize }
          }, slots.default !== void 0 ? slots.default() : [ vue.h('div', normalized.value) ])
        );

        return vue.h('div', {
          class: `q-circular-progress q-circular-progress--${ props.indeterminate === true ? 'in' : '' }determinate`,
          style: sizeStyle.value,
          role: 'progressbar',
          'aria-valuemin': props.min,
          'aria-valuemax': props.max,
          'aria-valuenow': props.indeterminate === true ? void 0 : normalized.value
        }, hMergeSlotSafely(slots.internal, child)) // "internal" is used by QKnob
      }
    }
  });

  function getChanges (evt, ctx, isFinal) {
    const pos = position(evt);
    let
      dir,
      distX = pos.left - ctx.event.x,
      distY = pos.top - ctx.event.y,
      absX = Math.abs(distX),
      absY = Math.abs(distY);

    const direction = ctx.direction;

    if (direction.horizontal === true && direction.vertical !== true) {
      dir = distX < 0 ? 'left' : 'right';
    }
    else if (direction.horizontal !== true && direction.vertical === true) {
      dir = distY < 0 ? 'up' : 'down';
    }
    else if (direction.up === true && distY < 0) {
      dir = 'up';
      if (absX > absY) {
        if (direction.left === true && distX < 0) {
          dir = 'left';
        }
        else if (direction.right === true && distX > 0) {
          dir = 'right';
        }
      }
    }
    else if (direction.down === true && distY > 0) {
      dir = 'down';
      if (absX > absY) {
        if (direction.left === true && distX < 0) {
          dir = 'left';
        }
        else if (direction.right === true && distX > 0) {
          dir = 'right';
        }
      }
    }
    else if (direction.left === true && distX < 0) {
      dir = 'left';
      if (absX < absY) {
        if (direction.up === true && distY < 0) {
          dir = 'up';
        }
        else if (direction.down === true && distY > 0) {
          dir = 'down';
        }
      }
    }
    else if (direction.right === true && distX > 0) {
      dir = 'right';
      if (absX < absY) {
        if (direction.up === true && distY < 0) {
          dir = 'up';
        }
        else if (direction.down === true && distY > 0) {
          dir = 'down';
        }
      }
    }

    let synthetic = false;

    if (dir === void 0 && isFinal === false) {
      if (ctx.event.isFirst === true || ctx.event.lastDir === void 0) {
        return {}
      }

      dir = ctx.event.lastDir;
      synthetic = true;

      if (dir === 'left' || dir === 'right') {
        pos.left -= distX;
        absX = 0;
        distX = 0;
      }
      else {
        pos.top -= distY;
        absY = 0;
        distY = 0;
      }
    }

    return {
      synthetic,
      payload: {
        evt,
        touch: ctx.event.mouse !== true,
        mouse: ctx.event.mouse === true,
        position: pos,
        direction: dir,
        isFirst: ctx.event.isFirst,
        isFinal: isFinal === true,
        duration: Date.now() - ctx.event.time,
        distance: {
          x: absX,
          y: absY
        },
        offset: {
          x: distX,
          y: distY
        },
        delta: {
          x: pos.left - ctx.event.lastX,
          y: pos.top - ctx.event.lastY
        }
      }
    }
  }

  let uid$4 = 0;

  var TouchPan = {
        name: 'touch-pan',

        beforeMount (el, { value, modifiers }) {
          // early return, we don't need to do anything
          if (modifiers.mouse !== true && client.has.touch !== true) {
            return
          }

          function handleEvent (evt, mouseEvent) {
            if (modifiers.mouse === true && mouseEvent === true) {
              stopAndPrevent(evt);
            }
            else {
              modifiers.stop === true && stop(evt);
              modifiers.prevent === true && prevent(evt);
            }
          }

          const ctx = {
            uid: 'qvtp_' + (uid$4++),
            handler: value,
            modifiers,
            direction: getModifierDirections(modifiers),

            noop,

            mouseStart (evt) {
              if (shouldStart(evt, ctx) && leftClick(evt)) {
                addEvt(ctx, 'temp', [
                  [ document, 'mousemove', 'move', 'notPassiveCapture' ],
                  [ document, 'mouseup', 'end', 'passiveCapture' ]
                ]);

                ctx.start(evt, true);
              }
            },

            touchStart (evt) {
              if (shouldStart(evt, ctx)) {
                const target = getTouchTarget(evt.target);

                addEvt(ctx, 'temp', [
                  [ target, 'touchmove', 'move', 'notPassiveCapture' ],
                  [ target, 'touchcancel', 'end', 'passiveCapture' ],
                  [ target, 'touchend', 'end', 'passiveCapture' ]
                ]);

                ctx.start(evt);
              }
            },

            start (evt, mouseEvent) {
              client.is.firefox === true && preventDraggable(el, true);
              ctx.lastEvt = evt;

              const pos = position(evt);

              /*
              * Stop propagation so possible upper v-touch-pan don't catch this as well;
              * If we're not the target (based on modifiers), we'll re-emit the event later
              */
              if (mouseEvent === true || modifiers.stop === true) {
                /*
                * are we directly switching to detected state?
                * clone event only otherwise
                */
                if (
                  ctx.direction.all !== true
                  && (mouseEvent !== true || ctx.direction.mouseAllDir !== true)
                ) {
                  const clone = evt.type.indexOf('mouse') > -1
                    ? new MouseEvent(evt.type, evt)
                    : new TouchEvent(evt.type, evt);

                  evt.defaultPrevented === true && prevent(clone);
                  evt.cancelBubble === true && stop(clone);

                  clone.qClonedBy = evt.qClonedBy === void 0
                    ? [ ctx.uid ]
                    : evt.qClonedBy.concat(ctx.uid);
                  clone.qKeyEvent = evt.qKeyEvent;
                  clone.qClickOutside = evt.qClickOutside;

                  ctx.initialEvent = {
                    target: evt.target,
                    event: clone
                  };
                }

                stop(evt);
              }

              ctx.event = {
                x: pos.left,
                y: pos.top,
                time: Date.now(),
                mouse: mouseEvent === true,
                detected: false,
                isFirst: true,
                isFinal: false,
                lastX: pos.left,
                lastY: pos.top
              };
            },

            move (evt) {
              if (ctx.event === void 0) {
                return
              }

              ctx.lastEvt = evt;

              const isMouseEvt = ctx.event.mouse === true;
              const start = () => {
                handleEvent(evt, isMouseEvt);

                if (modifiers.preserveCursor !== true) {
                  document.documentElement.style.cursor = 'grabbing';
                }
                isMouseEvt === true && document.body.classList.add('no-pointer-events--children');
                document.body.classList.add('non-selectable');
                clearSelection();

                ctx.styleCleanup = withDelayedFn => {
                  ctx.styleCleanup = void 0;

                  if (modifiers.preserveCursor !== true) {
                    document.documentElement.style.cursor = '';
                  }
                  document.body.classList.remove('non-selectable');

                  if (isMouseEvt === true) {
                    const remove = () => {
                      document.body.classList.remove('no-pointer-events--children');
                    };

                    if (withDelayedFn !== void 0) {
                      setTimeout(() => {
                        remove();
                        withDelayedFn();
                      }, 50);
                    }
                    else { remove(); }
                  }
                  else if (withDelayedFn !== void 0) {
                    withDelayedFn();
                  }
                };
              };

              if (ctx.event.detected === true) {
                ctx.event.isFirst !== true && handleEvent(evt, ctx.event.mouse);

                const { payload, synthetic } = getChanges(evt, ctx, false);

                if (payload !== void 0) {
                  if (ctx.handler(payload) === false) {
                    ctx.end(evt);
                  }
                  else {
                    if (ctx.styleCleanup === void 0 && ctx.event.isFirst === true) {
                      start();
                    }

                    ctx.event.lastX = payload.position.left;
                    ctx.event.lastY = payload.position.top;
                    ctx.event.lastDir = synthetic === true ? void 0 : payload.direction;
                    ctx.event.isFirst = false;
                  }
                }

                return
              }

              if (
                ctx.direction.all === true
                || (isMouseEvt === true && ctx.modifiers.mouseAllDir === true)
              ) {
                start();
                ctx.event.detected = true;
                ctx.move(evt);
                return
              }

              const
                pos = position(evt),
                distX = pos.left - ctx.event.x,
                distY = pos.top - ctx.event.y,
                absX = Math.abs(distX),
                absY = Math.abs(distY);

              if (absX !== absY) {
                if (
                  (ctx.direction.horizontal === true && absX > absY)
                  || (ctx.direction.vertical === true && absX < absY)
                  || (ctx.direction.up === true && absX < absY && distY < 0)
                  || (ctx.direction.down === true && absX < absY && distY > 0)
                  || (ctx.direction.left === true && absX > absY && distX < 0)
                  || (ctx.direction.right === true && absX > absY && distX > 0)
                ) {
                  ctx.event.detected = true;
                  ctx.move(evt);
                }
                else {
                  ctx.end(evt, true);
                }
              }
            },

            end (evt, abort) {
              if (ctx.event === void 0) {
                return
              }

              cleanEvt(ctx, 'temp');
              client.is.firefox === true && preventDraggable(el, false);

              if (abort === true) {
                ctx.styleCleanup !== void 0 && ctx.styleCleanup();

                if (ctx.event.detected !== true && ctx.initialEvent !== void 0) {
                  ctx.initialEvent.target.dispatchEvent(ctx.initialEvent.event);
                }
              }
              else if (ctx.event.detected === true) {
                ctx.event.isFirst === true && ctx.handler(getChanges(evt === void 0 ? ctx.lastEvt : evt, ctx).payload);

                const { payload } = getChanges(evt === void 0 ? ctx.lastEvt : evt, ctx, true);
                const fn = () => { ctx.handler(payload); };

                if (ctx.styleCleanup !== void 0) {
                  ctx.styleCleanup(fn);
                }
                else {
                  fn();
                }
              }

              ctx.event = void 0;
              ctx.initialEvent = void 0;
              ctx.lastEvt = void 0;
            }
          };

          el.__qtouchpan = ctx;

          modifiers.mouse === true && addEvt(ctx, 'main', [
            [ el, 'mousedown', 'mouseStart', `passive${ modifiers.mouseCapture === true ? 'Capture' : '' }` ]
          ]);

          client.has.touch === true && addEvt(ctx, 'main', [
            [ el, 'touchstart', 'touchStart', `passive${ modifiers.capture === true ? 'Capture' : '' }` ],
            [ el, 'touchmove', 'noop', 'notPassiveCapture' ]
          ]);
        },

        updated (el, mod) {
          const ctx = el.__qtouchpan;

          if (ctx !== void 0) {
            if (mod.oldValue !== mod.value) {
              typeof value !== 'function' && ctx.end();
              ctx.handler = mod.value;
            }

            ctx.direction = getModifierDirections(mod);
          }
        },

        beforeUnmount (el) {
          const ctx = el.__qtouchpan;

          if (ctx !== void 0) {
            // emit the end event when the directive is destroyed while active
            // this is only needed in TouchPan because the rest of the touch directives do not emit an end event
            // the condition is also checked in the start of function but we avoid the call
            ctx.event !== void 0 && ctx.end();

            cleanEvt(ctx, 'main');
            cleanEvt(ctx, 'temp');

            client.is.firefox === true && preventDraggable(el, false);
            ctx.styleCleanup !== void 0 && ctx.styleCleanup();

            delete el.__qtouchpan;
          }
        }
      };

  // PGDOWN, LEFT, DOWN, PGUP, RIGHT, UP
  const keyCodes$2 = [ 34, 37, 40, 33, 39, 38 ];

  function getRatio (evt, dragging, reverse, vertical) {
    const
      pos = position(evt),
      val = vertical === true
        ? between((pos.top - dragging.top) / dragging.height, 0, 1)
        : between((pos.left - dragging.left) / dragging.width, 0, 1);

    return reverse === true ? 1.0 - val : val
  }

  function getModel (ratio, min, max, step, decimals) {
    let model = min + ratio * (max - min);

    if (step > 0) {
      const modulo = (model - min) % step;
      model += (Math.abs(modulo) >= step / 2 ? (modulo < 0 ? -1 : 1) * step : 0) - modulo;
    }

    if (decimals > 0) {
      model = parseFloat(model.toFixed(decimals));
    }

    return between(model, min, max)
  }

  const useSliderProps = {
    ...useDarkProps,

    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    step: {
      type: Number,
      default: 1,
      validator: v => v >= 0
    },

    color: String,

    labelColor: String,
    labelTextColor: String,
    dense: Boolean,

    label: Boolean,
    labelAlways: Boolean,
    markers: Boolean,
    snap: Boolean,

    vertical: Boolean,
    reverse: Boolean,

    disable: Boolean,
    readonly: Boolean,
    tabindex: [ String, Number ],

    thumbPath: {
      type: String,
      default: 'M 4, 10 a 6,6 0 1,0 12,0 a 6,6 0 1,0 -12,0'
    }
  };

  const useSliderEmits = [ 'pan', 'update:modelValue', 'change' ];

  function useSlider ({ updateValue, updatePosition, getDragging }) {
    const { props, emit, proxy: { $q } } = vue.getCurrentInstance();
    const isDark = useDark(props, $q);

    const active = vue.ref(false);
    const preventFocus = vue.ref(false);
    const focus = vue.ref(false);
    const dragging = vue.ref(false);

    const axis = vue.computed(() => (props.vertical === true ? '--v' : '--h'));

    const isReversed = vue.computed(() => (
      props.vertical === true
        ? props.reverse === true
        : props.reverse !== ($q.lang.rtl === true)
    ));

    const editable = vue.computed(() => props.disable !== true && props.readonly !== true && props.min < props.max);

    const classes = vue.computed(() =>
      `q-slider q-slider${ axis.value } q-slider--${ active.value === true ? '' : 'in' }active`
      + (isReversed.value === true ? ' q-slider--reversed' : '')
      + (props.color !== void 0 ? ` text-${ props.color }` : '')
      + (props.disable === true ? ' disabled' : ' q-slider--enabled' + (editable.value === true ? ' q-slider--editable' : ''))
      + (focus.value === 'both' ? ' q-slider--focus' : '')
      + (props.label || props.labelAlways === true ? ' q-slider--label' : '')
      + (props.labelAlways === true ? ' q-slider--label-always' : '')
      + (isDark.value === true ? ' q-slider--dark' : '')
      + (props.dense === true ? ' q-slider--dense q-slider--dense' + axis.value : '')
    );

    const decimals = vue.computed(() => (String(props.step).trim('0').split('.')[ 1 ] || '').length);
    const step = vue.computed(() => (props.step === 0 ? 1 : props.step));
    const minMaxDiff = vue.computed(() => props.max - props.min);

    const markerStyle = vue.computed(() => {
      if (minMaxDiff.value !== 0) {
        const size = 100 * step.value / minMaxDiff.value;

        return {
          backgroundSize: props.vertical === true
            ? `2px ${ size }%`
            : `${ size }% 2px`
        }
      }

      return null
    });

    const tabindex = vue.computed(() => (editable.value === true ? props.tabindex || 0 : -1));

    const positionProp = vue.computed(() => (
      props.vertical === true
        ? (isReversed.value === true ? 'bottom' : 'top')
        : isReversed.value === true ? 'right' : 'left'
    ));

    const sizeProp = vue.computed(() => (props.vertical === true ? 'height' : 'width'));

    const orientation = vue.computed(() => (props.vertical === true ? 'vertical' : 'horizontal'));

    const attributes = vue.computed(() => {
      const acc = {
        role: 'slider',
        'aria-valuemin': props.min,
        'aria-valuemax': props.max,
        'aria-orientation': orientation.value,
        'data-step': props.step
      };

      if (props.disable === true) {
        acc[ 'aria-disabled' ] = 'true';
      }
      else if (props.readonly === true) {
        acc[ 'aria-readonly' ] = 'true';
      }

      return acc
    });

    const panDirective = vue.computed(() => {
      // if editable.value === true
      return [ [
        TouchPan,
        onPan,
        void 0,
        {
          [ orientation.value ]: true,
          prevent: true,
          stop: true,
          mouse: true,
          mouseAllDir: true
        }
      ] ]
    });

    function getThumbSvg () {
      return vue.h('svg', {
        class: 'q-slider__thumb absolute',
        viewBox: '0 0 20 20',
        width: '20',
        height: '20',
        'aria-hidden': 'true'
      }, [
        vue.h('path', { d: props.thumbPath })
      ])
    }

    function getPinStyle (percent, ratio) {
      if (props.vertical === true) {
        return {}
      }

      const offset = `${ Math.ceil(20 * Math.abs(0.5 - ratio)) }px`;
      return {
        pin: {
          transformOrigin: `${ $q.lang.rtl === true ? offset : `calc(100% - ${ offset })` } 50%`
        },

        pinTextContainer: {
          [ $q.lang.rtl === true ? 'left' : 'right' ]: `${ percent * 100 }%`,
          transform: `translateX(${ Math.ceil(($q.lang.rtl === true ? -1 : 1) * 20 * percent) }px)`
        }
      }
    }

    function onPan (event) {
      if (event.isFinal) {
        if (dragging.value !== void 0) {
          updatePosition(event.evt);
          // only if touch, because we also have mousedown/up:
          event.touch === true && updateValue(true);
          dragging.value = void 0;
          emit('pan', 'end');
        }
        active.value = false;
      }
      else if (event.isFirst) {
        dragging.value = getDragging(event.evt);
        updatePosition(event.evt);
        updateValue();
        active.value = true;
        emit('pan', 'start');
      }
      else {
        updatePosition(event.evt);
        updateValue();
      }
    }

    function onBlur () {
      focus.value = false;
    }

    function onActivate (evt) {
      updatePosition(evt, getDragging(evt));
      updateValue();

      preventFocus.value = true;
      active.value = true;

      document.addEventListener('mouseup', onDeactivate, true);
    }

    function onDeactivate () {
      preventFocus.value = false;

      if (dragging.value === void 0) {
        active.value = false;
      }

      updateValue(true);
      onBlur();

      document.removeEventListener('mouseup', onDeactivate, true);
    }

    function onMobileClick (evt) {
      updatePosition(evt, getDragging(evt));
      updateValue(true);
    }

    function onKeyup (evt) {
      if (keyCodes$2.includes(evt.keyCode)) {
        updateValue(true);
      }
    }

    vue.onBeforeUnmount(() => {
      document.removeEventListener('mouseup', onDeactivate, true);
    });

    return {
      state: {
        active,
        focus,
        preventFocus,
        dragging,

        axis,
        isReversed,
        editable,
        classes,
        decimals,
        step,
        minMaxDiff,
        markerStyle,
        tabindex,
        positionProp,
        sizeProp,
        attributes,
        panDirective
      },

      methods: {
        onActivate,
        onMobileClick,
        onBlur,
        onKeyup,
        getThumbSvg,
        getPinStyle
      }
    }
  }

  var QSlider = vue.defineComponent({
    name: 'QSlider',

    props: {
      ...useSliderProps,
      ...useFormProps,

      modelValue: {
        required: true,
        default: null,
        validator: v => typeof v === 'number' || v === null
      },

      labelValue: [ String, Number ]
    },

    emits: useSliderEmits,

    setup (props, { emit }) {
      const { proxy: { $q } } = vue.getCurrentInstance();

      const formAttrs = useFormAttrs(props);
      const injectFormInput = useFormInject(formAttrs);

      const rootRef = vue.ref(null);
      const model = vue.ref(props.modelValue === null ? props.min : props.modelValue);
      const curRatio = vue.ref(0);

      const { state, methods } = useSlider({
        updateValue, updatePosition, getDragging
      });

      const modelRatio = vue.computed(() => (
        state.minMaxDiff.value === 0 ? 0 : (model.value - props.min) / state.minMaxDiff.value
      ));
      const ratio = vue.computed(() => (state.active.value === true ? curRatio.value : modelRatio.value));

      const trackStyle = vue.computed(() => ({
        [ state.positionProp.value ]: 0,
        [ state.sizeProp.value ]: `${ 100 * ratio.value }%`
      }));

      const thumbStyle = vue.computed(() => ({
        [ state.positionProp.value ]: `${ 100 * ratio.value }%`
      }));

      const thumbClass = vue.computed(() => (
        state.preventFocus.value === false && state.focus.value === true
          ? ' q-slider--focus'
          : ''
      ));

      const pinClass = vue.computed(() => (
        props.labelColor !== void 0
          ? `text-${ props.labelColor }`
          : ''
      ));

      const pinTextClass = vue.computed(() =>
        'q-slider__pin-value-marker-text'
        + (props.labelTextColor !== void 0 ? ` text-${ props.labelTextColor }` : '')
      );

      const events = vue.computed(() => {
        if (state.editable.value !== true) {
          return {}
        }

        return $q.platform.is.mobile === true
          ? { onClick: methods.onMobileClick }
          : {
              onMousedown: methods.onActivate,
              onFocus,
              onBlur: methods.onBlur,
              onKeydown,
              onKeyup: methods.onKeyup
            }
      });

      const label = vue.computed(() => (
        props.labelValue !== void 0
          ? props.labelValue
          : model.value
      ));

      const pinStyle = vue.computed(() => {
        const percent = (props.reverse === true ? -ratio.value : ratio.value - 1);
        return methods.getPinStyle(percent, ratio.value)
      });

      vue.watch(() => props.modelValue, v => {
        model.value = v === null
          ? 0
          : between(v, props.min, props.max);
      });

      vue.watch(() => props.min + props.max, () => {
        model.value = between(model.value, props.min, props.max);
      });

      function updateValue (change) {
        if (model.value !== props.modelValue) {
          emit('update:modelValue', model.value);
        }
        change === true && emit('change', model.value);
      }

      function getDragging () {
        return rootRef.value.getBoundingClientRect()
      }

      function updatePosition (event, dragging = state.dragging.value) {
        const ratio = getRatio(
          event,
          dragging,
          state.isReversed.value,
          props.vertical
        );

        model.value = getModel(ratio, props.min, props.max, props.step, state.decimals.value);
        curRatio.value = props.snap !== true || props.step === 0
          ? ratio
          : (
              state.minMaxDiff.value === 0 ? 0 : (model.value - props.min) / state.minMaxDiff.value
            );
      }

      function onFocus () {
        state.focus.value = true;
      }

      function onKeydown (evt) {
        if (!keyCodes$2.includes(evt.keyCode)) {
          return
        }

        stopAndPrevent(evt);

        const
          stepVal = ([ 34, 33 ].includes(evt.keyCode) ? 10 : 1) * state.step.value,
          offset = [ 34, 37, 40 ].includes(evt.keyCode) ? -stepVal : stepVal;

        model.value = between(
          parseFloat((model.value + offset).toFixed(state.decimals.value)),
          props.min,
          props.max
        );

        updateValue();
      }

      return () => {
        const child = [
          methods.getThumbSvg(),
          vue.h('div', { class: 'q-slider__focus-ring' })
        ];

        if (props.label === true || props.labelAlways === true) {
          child.push(
            vue.h('div', {
              class: `q-slider__pin q-slider__pin${ state.axis.value } absolute ` + pinClass.value,
              style: pinStyle.value.pin
            }, [
              vue.h('div', {
                class: `q-slider__pin-text-container q-slider__pin-text-container${ state.axis.value }`,
                style: pinStyle.value.pinTextContainer
              }, [
                vue.h('span', {
                  class: 'q-slider__pin-text ' + pinTextClass.value
                }, [
                  label.value
                ])
              ])
            ]),

            vue.h('div', {
              class: `q-slider__arrow q-slider__arrow${ state.axis.value } ${ pinClass.value }`
            })
          );
        }

        if (props.name !== void 0 && props.disable !== true) {
          injectFormInput(child, 'push');
        }

        const track = [
          vue.h('div', {
            class: `q-slider__track q-slider__track${ state.axis.value } absolute`,
            style: trackStyle.value
          })
        ];

        props.markers === true && track.push(
          vue.h('div', {
            class: `q-slider__track-markers q-slider__track-markers${ state.axis.value } absolute-full fit`,
            style: state.markerStyle.value
          })
        );

        const content = [
          vue.h('div', {
            class: `q-slider__track-container q-slider__track-container${ state.axis.value } absolute`
          }, track),

          vue.h('div', {
            class: `q-slider__thumb-container q-slider__thumb-container${ state.axis.value } absolute non-selectable` + thumbClass.value,
            style: thumbStyle.value
          }, child)
        ];

        const data = {
          ref: rootRef,
          class: state.classes.value + (props.modelValue === null ? ' q-slider--no-value' : ''),
          ...state.attributes.value,
          'aria-valuenow': props.modelValue,
          tabindex: state.tabindex.value,
          ...events.value
        };

        return hDir('div', data, content, 'slide', state.editable.value, () => state.panDirective.value)
      }
    }
  });

  function useCanRender () {
    const canRender = vue.ref(!isRuntimeSsrPreHydration.value);

    if (canRender.value === false) {
      vue.onMounted(() => {
        canRender.value = true;
      });
    }

    return canRender
  }

  const hasObserver = typeof ResizeObserver !== 'undefined';
  const resizeProps = hasObserver === true
    ? {}
    : {
        style: 'display:block;position:absolute;top:0;left:0;right:0;bottom:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1;',
        url: 'about:blank'
      };

  var QResizeObserver = vue.defineComponent({
    name: 'QResizeObserver',

    props: {
      debounce: {
        type: [ String, Number ],
        default: 100
      }
    },

    emits: [ 'resize' ],

    setup (props, { emit }) {

      let timer, targetEl, size = { width: -1, height: -1 };

      function trigger (now) {
        if (now === true || props.debounce === 0 || props.debounce === '0') {
          onResize();
        }
        else if (!timer) {
          timer = setTimeout(onResize, props.debounce);
        }
      }

      function onResize () {
        timer = void 0;

        if (targetEl) {
          const { offsetWidth: width, offsetHeight: height } = targetEl;

          if (width !== size.width || height !== size.height) {
            size = { width, height };
            emit('resize', size);
          }
        }
      }

      const vm = vue.getCurrentInstance();

      // expose public methods
      Object.assign(vm.proxy, { trigger });

      if (hasObserver === true) {
        let observer;

        vue.onMounted(() => {
          vue.nextTick(() => {
            targetEl = vm.proxy.$el.parentNode;

            if (targetEl) {
              observer = new ResizeObserver(trigger);
              observer.observe(targetEl);
              onResize();
            }
          });
        });

        vue.onBeforeUnmount(() => {
          clearTimeout(timer);

          if (observer !== void 0) {
            if (observer.disconnect !== void 0) {
              observer.disconnect();
            }
            else if (targetEl) { // FF for Android
              observer.unobserve(targetEl);
            }
          }
        });

        return noop
      }
      else { // no observer, so fallback to old iframe method
        const canRender = useCanRender();

        let curDocView;

        function cleanup () {
          clearTimeout(timer);

          if (curDocView !== void 0) {
            // iOS is fuzzy, need to check it first
            if (curDocView.removeEventListener !== void 0) {
              curDocView.removeEventListener('resize', trigger, listenOpts.passive);
            }
            curDocView = void 0;
          }
        }

        function onObjLoad () {
          cleanup();

          if (targetEl && targetEl.contentDocument) {
            curDocView = targetEl.contentDocument.defaultView;
            curDocView.addEventListener('resize', trigger, listenOpts.passive);
            onResize();
          }
        }

        vue.onMounted(() => {
          vue.nextTick(() => {
            targetEl = vm.proxy.$el;
            targetEl && onObjLoad();
          });
        });

        vue.onBeforeUnmount(cleanup);

        return () => {
          if (canRender.value === true) {
            return vue.h('object', {
              style: resizeProps.style,
              tabindex: -1, // fix for Firefox
              type: 'text/html',
              data: resizeProps.url,
              'aria-hidden': 'true',
              onLoad: onObjLoad
            })
          }
        }
      }
    }
  });

  function getIndicatorClass (color, top, vertical) {
    const pos = vertical === true
      ? [ 'left', 'right' ]
      : [ 'top', 'bottom' ];

    return `absolute-${ top === true ? pos[ 0 ] : pos[ 1 ] }${ color ? ` text-${ color }` : '' }`
  }

  const alignValues$1 = [ 'left', 'center', 'right', 'justify' ];

  var QTabs = vue.defineComponent({
    name: 'QTabs',

    props: {
      modelValue: [ Number, String ],

      align: {
        type: String,
        default: 'center',
        validator: v => alignValues$1.includes(v)
      },
      breakpoint: {
        type: [ String, Number ],
        default: 600
      },

      vertical: Boolean,
      shrink: Boolean,
      stretch: Boolean,

      activeColor: String,
      activeBgColor: String,
      indicatorColor: String,
      leftIcon: String,
      rightIcon: String,

      outsideArrows: Boolean,
      mobileArrows: Boolean,

      switchIndicator: Boolean,

      narrowIndicator: Boolean,
      inlineLabel: Boolean,
      noCaps: Boolean,

      dense: Boolean,

      contentClass: String,

      'onUpdate:modelValue': Function
    },

    setup (props, { slots, emit }) {
      const vm = vue.getCurrentInstance();
      const { proxy: { $q } } = vm;

      const { registerTick, prepareTick } = useTick();
      const { registerTimeout } = useTimeout();

      const rootRef = vue.ref(null);
      const contentRef = vue.ref(null);

      const currentModel = vue.ref(props.modelValue);
      const scrollable = vue.ref(false);
      const leftArrow = vue.ref(true);
      const rightArrow = vue.ref(false);
      const justify = vue.ref(false);

      const arrowsEnabled = vue.computed(() =>
        $q.platform.is.desktop === true || props.mobileArrows === true
      );

      const tabList = [];

      let localFromRoute = false, animateTimer, scrollTimer, unwatchRoute;
      let localUpdateArrows = arrowsEnabled.value === true
        ? updateArrowsFn
        : noop;

      const tabProps = vue.computed(() => ({
        activeColor: props.activeColor,
        activeBgColor: props.activeBgColor,
        indicatorClass: getIndicatorClass(
          props.indicatorColor,
          props.switchIndicator,
          props.vertical
        ),
        narrowIndicator: props.narrowIndicator,
        inlineLabel: props.inlineLabel,
        noCaps: props.noCaps
      }));

      const alignClass = vue.computed(() => {
        const align = scrollable.value === true
          ? 'left'
          : (justify.value === true ? 'justify' : props.align);

        return `q-tabs__content--align-${ align }`
      });

      const classes = vue.computed(() =>
        'q-tabs row no-wrap items-center'
        + ` q-tabs--${ scrollable.value === true ? '' : 'not-' }scrollable`
        + ` q-tabs--${ props.vertical === true ? 'vertical' : 'horizontal' }`
        + ` q-tabs__arrows--${ arrowsEnabled.value === true && props.outsideArrows === true ? 'outside' : 'inside' }`
        + (props.dense === true ? ' q-tabs--dense' : '')
        + (props.shrink === true ? ' col-shrink' : '')
        + (props.stretch === true ? ' self-stretch' : '')
      );

      const innerClass = vue.computed(() =>
        'q-tabs__content row no-wrap items-center self-stretch hide-scrollbar '
        + alignClass.value
        + (props.contentClass !== void 0 ? ` ${ props.contentClass }` : '')
        + ($q.platform.is.mobile === true ? ' scroll' : '')
      );

      const domProps = vue.computed(() => (
        props.vertical === true
          ? { container: 'height', content: 'offsetHeight', scroll: 'scrollHeight' }
          : { container: 'width', content: 'offsetWidth', scroll: 'scrollWidth' }
      ));

      vue.watch(() => props.modelValue, name => {
        updateModel({ name, setCurrent: true, skipEmit: true });
      });

      vue.watch(() => props.outsideArrows, () => {
        vue.nextTick(recalculateScroll());
      });

      vue.watch(arrowsEnabled, v => {
        localUpdateArrows = v === true
          ? updateArrowsFn
          : noop;

        vue.nextTick(recalculateScroll());
      });

      function updateModel ({ name, setCurrent, skipEmit, fromRoute }) {
        if (currentModel.value !== name) {
          skipEmit !== true && emit('update:modelValue', name);
          if (
            setCurrent === true
            || props[ 'onUpdate:modelValue' ] !== void 0
          ) {
            animate(currentModel.value, name);
            currentModel.value = name;
          }
        }

        if (fromRoute !== void 0) {
          localFromRoute = fromRoute;
        }
      }

      function recalculateScroll () {
        registerTick(() => {
          if (vm.isDeactivated !== true && vm.isUnmounted !== true) {
            updateContainer({
              width: rootRef.value.offsetWidth,
              height: rootRef.value.offsetHeight
            });
          }
        });

        prepareTick();
      }

      function updateContainer (domSize) {
        const
          size = domSize[ domProps.value.container ],
          scrollSize = Math.min(
            contentRef.value[ domProps.value.scroll ],
            Array.prototype.reduce.call(
              contentRef.value.children,
              (acc, el) => acc + el[ domProps.value.content ],
              0
            )
          ),
          scroll = size > 0 && scrollSize > size; // when there is no tab, in Chrome, size === 0 and scrollSize === 1

        if (scrollable.value !== scroll) {
          scrollable.value = scroll;
        }

        // Arrows need to be updated even if the scroll status was already true
        scroll === true && vue.nextTick(localUpdateArrows);

        const localJustify = size < parseInt(props.breakpoint, 10);

        if (justify.value !== localJustify) {
          justify.value = localJustify;
        }
      }

      function animate (oldName, newName) {
        const
          oldTab = oldName !== void 0 && oldName !== null && oldName !== ''
            ? tabList.find(tab => tab.name.value === oldName)
            : null,
          newTab = newName !== void 0 && newName !== null && newName !== ''
            ? tabList.find(tab => tab.name.value === newName)
            : null;

        if (oldTab && newTab) {
          const
            oldEl = oldTab.tabIndicatorRef.value,
            newEl = newTab.tabIndicatorRef.value;

          clearTimeout(animateTimer);

          oldEl.style.transition = 'none';
          oldEl.style.transform = 'none';
          newEl.style.transition = 'none';
          newEl.style.transform = 'none';

          const
            oldPos = oldEl.getBoundingClientRect(),
            newPos = newEl.getBoundingClientRect();

          newEl.style.transform = props.vertical === true
            ? `translate3d(0,${ oldPos.top - newPos.top }px,0) scale3d(1,${ newPos.height ? oldPos.height / newPos.height : 1 },1)`
            : `translate3d(${ oldPos.left - newPos.left }px,0,0) scale3d(${ newPos.width ? oldPos.width / newPos.width : 1 },1,1)`;

          // allow scope updates to kick in (QRouteTab needs more time)
          vue.nextTick(() => {
            animateTimer = setTimeout(() => {
              newEl.style.transition = 'transform .25s cubic-bezier(.4, 0, .2, 1)';
              newEl.style.transform = 'none';
            }, 70);
          });
        }

        if (newTab && scrollable.value === true) {
          const
            { left, width, top, height } = contentRef.value.getBoundingClientRect(),
            newPos = newTab.rootRef.value.getBoundingClientRect();

          let offset = props.vertical === true ? newPos.top - top : newPos.left - left;

          if (offset < 0) {
            contentRef.value[ props.vertical === true ? 'scrollTop' : 'scrollLeft' ] += Math.floor(offset);
            localUpdateArrows();
            return
          }

          offset += props.vertical === true ? newPos.height - height : newPos.width - width;
          if (offset > 0) {
            contentRef.value[ props.vertical === true ? 'scrollTop' : 'scrollLeft' ] += Math.ceil(offset);
            localUpdateArrows();
          }
        }
      }

      function updateArrowsFn () {
        const content = contentRef.value;
        if (content !== null) {
          const
            rect = content.getBoundingClientRect(),
            pos = props.vertical === true ? content.scrollTop : content.scrollLeft;

          leftArrow.value = pos > 0;
          rightArrow.value = props.vertical === true
            ? Math.ceil(pos + rect.height) < content.scrollHeight
            : Math.ceil(pos + rect.width) < content.scrollWidth;
        }
      }

      function animScrollTo (value) {
        stopAnimScroll();
        scrollTowards(value);

        scrollTimer = setInterval(() => {
          if (scrollTowards(value)) {
            stopAnimScroll();
          }
        }, 5);
      }

      function scrollToStart () {
        animScrollTo(0);
      }

      function scrollToEnd () {
        animScrollTo(9999);
      }

      function stopAnimScroll () {
        clearInterval(scrollTimer);
      }

      function scrollTowards (value) {
        const content = contentRef.value;
        let
          pos = props.vertical === true ? content.scrollTop : content.scrollLeft,
          done = false;

        const direction = value < pos ? -1 : 1;

        pos += direction * 5;
        if (pos < 0) {
          done = true;
          pos = 0;
        }
        else if (
          (direction === -1 && pos <= value)
          || (direction === 1 && pos >= value)
        ) {
          done = true;
          pos = value;
        }

        content[ props.vertical === true ? 'scrollTop' : 'scrollLeft' ] = pos;
        localUpdateArrows();

        return done
      }

      function getRouteList () {
        return tabList.filter(tab => tab.routerProps !== void 0 && tab.routerProps.hasLink.value === true)
      }

      // do not use directly; use verifyRouteModel() instead
      function updateActiveRoute () {
        let href = '', name = null, wasActive = localFromRoute;

        getRouteList().forEach(tab => {
          if (
            tab.routerProps !== void 0
            && tab.routerProps[ tab.routerProps.exact.value === true ? 'linkIsExactActive' : 'linkIsActive' ].value === true
            && tab.routerProps.linkRoute.value.href.length > href.length
          ) {
            href = tab.routerProps.linkRoute.value.href;
            name = tab.name.value;
          }
          else if (currentModel.value === tab.name.value) {
            wasActive = true;
          }
        });

        if (wasActive === true || name !== null) {
          updateModel({ name, setCurrent: true, fromRoute: true });
        }
      }

      function verifyRouteModel () {
        registerTimeout(updateActiveRoute);
      }

      function registerTab (getTab) {
        tabList.push(getTab);

        const routeList = getRouteList();

        if (routeList.length > 0) {
          if (unwatchRoute === void 0) {
            unwatchRoute = vue.watch(() => vm.proxy.$route, verifyRouteModel);
          }

          verifyRouteModel();
        }
      }

      /*
       * Vue has an aggressive diff (in-place replacement) so we cannot
       * ensure that the instance getting destroyed is the actual tab
       * reported here. As a result, we cannot use its name or check
       * if it's a route one to make the necessary updates. We need to
       * always check the existing list again and infer the changes.
       */
      function unregisterTab (tabData) {
        tabList.splice(tabList.indexOf(tabData), 1);

        if (unwatchRoute !== void 0) {
          const routeList = getRouteList();

          if (routeList.length === 0) {
            unwatchRoute();
            unwatchRoute = void 0;
          }

          verifyRouteModel();
        }
      }

      vue.provide(tabsKey, {
        currentModel,
        tabProps,

        registerTab,
        unregisterTab,

        verifyRouteModel,
        updateModel,
        recalculateScroll
      });

      vue.onBeforeUnmount(() => {
        clearTimeout(animateTimer);
        unwatchRoute !== void 0 && unwatchRoute();
      });

      vue.onActivated(recalculateScroll);

      return () => {
        const child = [
          vue.h(QResizeObserver, { onResize: updateContainer }),

          vue.h('div', {
            ref: contentRef,
            class: innerClass.value,
            onScroll: localUpdateArrows
          }, hSlot(slots.default))
        ];

        arrowsEnabled.value === true && child.push(
          vue.h(QIcon, {
            class: 'q-tabs__arrow q-tabs__arrow--left absolute q-tab__icon'
              + (leftArrow.value === true ? '' : ' q-tabs__arrow--faded'),
            name: props.leftIcon || $q.iconSet.tabs[ props.vertical === true ? 'up' : 'left' ],
            onMousedown: scrollToStart,
            onTouchstartPassive: scrollToStart,
            onMouseup: stopAnimScroll,
            onMouseleave: stopAnimScroll,
            onTouchend: stopAnimScroll
          }),

          vue.h(QIcon, {
            class: 'q-tabs__arrow q-tabs__arrow--right absolute q-tab__icon'
              + (rightArrow.value === true ? '' : ' q-tabs__arrow--faded'),
            name: props.rightIcon || $q.iconSet.tabs[ props.vertical === true ? 'down' : 'right' ],
            onMousedown: scrollToEnd,
            onTouchstartPassive: scrollToEnd,
            onMouseup: stopAnimScroll,
            onMouseleave: stopAnimScroll,
            onTouchend: stopAnimScroll
          })
        );

        return vue.h('div', {
          ref: rootRef,
          class: classes.value,
          role: 'tablist'
        }, child)
      }
    }
  });

  let uid$3 = 0;

  const useTabEmits = [ 'click', 'keyup' ];

  const useTabProps = {
    icon: String,
    label: [ Number, String ],

    alert: [ Boolean, String ],
    alertIcon: String,

    name: {
      type: [ Number, String ],
      default: () => `t_${ uid$3++ }`
    },

    noCaps: Boolean,

    tabindex: [ String, Number ],
    disable: Boolean,

    contentClass: String,

    ripple: {
      type: [ Boolean, Object ],
      default: true
    }
  };

  function useTab (props, slots, emit, routerProps) {
    const $tabs = vue.inject(tabsKey, () => {
      console.error('QTab/QRouteTab component needs to be child of QTabs');
    });

    const blurTargetRef = vue.ref(null);
    const rootRef = vue.ref(null);
    const tabIndicatorRef = vue.ref(null);

    const isActive = vue.computed(() => $tabs.currentModel.value === props.name);

    const classes = vue.computed(() =>
      'q-tab relative-position self-stretch flex flex-center text-center'
      + ` q-tab--${ isActive.value === true ? '' : 'in' }active`
      + (
        isActive.value === true
          ? (
              ($tabs.tabProps.value.activeColor ? ` text-${ $tabs.tabProps.value.activeColor }` : '')
              + ($tabs.tabProps.value.activeBgColor ? ` bg-${ $tabs.tabProps.value.activeBgColor }` : '')
            )
          : ''
      )
      + (props.icon && props.label && $tabs.tabProps.value.inlineLabel === false ? ' q-tab--full' : '')
      + (props.noCaps === true || $tabs.tabProps.value.noCaps === true ? ' q-tab--no-caps' : '')
      + (props.disable === true ? ' disabled' : ' q-focusable q-hoverable cursor-pointer')
    );

    const innerClass = vue.computed(() =>
      'q-tab__content self-stretch flex-center relative-position q-anchor--skip non-selectable '
      + ($tabs.tabProps.value.inlineLabel === true ? 'row no-wrap q-tab__content--inline' : 'column')
      + (props.contentClass !== void 0 ? ` ${ props.contentClass }` : '')
    );

    const tabIndex = vue.computed(() => (
      props.disable === true || isActive.value === true ? -1 : props.tabindex || 0
    ));

    function onClick (e, keyboard) {
      keyboard !== true && blurTargetRef.value !== null && blurTargetRef.value.focus();

      if (props.disable !== true) {
        if (routerProps !== void 0) {
          if (routerProps.hasLink.value === true) {
            const go = () => {
              e.__qNavigate = true;
              routerProps.navigateToLink(e);
            };

            emit('click', e, go);
            e.defaultPrevented !== true && go();
          }
          else {
            emit('click', e);
          }
        }
        else {
          emit('click', e);
          $tabs.updateModel({ name: props.name, fromRoute: false });
        }
      }
    }

    function onKeyup (e) {
      isKeyCode(e, 13) === true && onClick(e, true);
      emit('keyup', e);
    }

    function getContent () {
      const
        narrow = $tabs.tabProps.value.narrowIndicator,
        content = [],
        indicator = vue.h('div', {
          ref: tabIndicatorRef,
          class: [
            'q-tab__indicator',
            $tabs.tabProps.value.indicatorClass
          ]
        });

      props.icon !== void 0 && content.push(
        vue.h(QIcon, {
          class: 'q-tab__icon',
          name: props.icon
        })
      );

      props.label !== void 0 && content.push(
        vue.h('div', { class: 'q-tab__label' }, props.label)
      );

      props.alert !== false && content.push(
        props.alertIcon !== void 0
          ? vue.h(QIcon, {
              class: 'q-tab__alert-icon',
              color: props.alert !== true
                ? props.alert
                : void 0,
              name: props.alertIcon
            })
          : vue.h('div', {
            class: 'q-tab__alert'
              + (props.alert !== true ? ` text-${ props.alert }` : '')
          })
      );

      narrow === true && content.push(indicator);

      const node = [
        vue.h('div', { class: 'q-focus-helper', tabindex: -1, ref: blurTargetRef }),
        vue.h('div', { class: innerClass.value }, hMergeSlot(slots.default, content))
      ];

      narrow === false && node.push(indicator);

      return node
    }

    const tabData = {
      name: vue.computed(() => props.name),
      rootRef,
      tabIndicatorRef,
      routerProps
    };

    vue.onBeforeUnmount(() => {
      $tabs.unregisterTab(tabData);
      $tabs.recalculateScroll();
    });

    vue.onMounted(() => {
      $tabs.registerTab(tabData);
      $tabs.recalculateScroll();
    });

    function renderTab (tag, customData) {
      const data = {
        ref: rootRef,
        class: classes.value,
        tabindex: tabIndex.value,
        role: 'tab',
        'aria-selected': isActive.value,
        'aria-disabled': props.disable === true ? 'true' : void 0,
        onClick,
        onKeyup,
        ...customData
      };

      return hDir(
        tag,
        data,
        getContent(),
        'main',
        props.ripple !== false && props.disable === false,
        () => [ [ Ripple, props.ripple ] ]
      )
    }

    return { renderTab, $tabs }
  }

  var QTab = vue.defineComponent({
    name: 'QTab',

    props: useTabProps,

    emits: useTabEmits,

    setup (props, { slots, emit }) {
      const { renderTab } = useTab(props, slots, emit);
      return () => renderTab('div')
    }
  });

  var QTabPanels = vue.defineComponent({
    name: 'QTabPanels',

    props: {
      ...usePanelProps,
      ...useDarkProps
    },

    emits: usePanelEmits,

    setup (props, { slots }) {
      const vm = vue.getCurrentInstance();
      const isDark = useDark(props, vm.proxy.$q);

      const { updatePanelsList, getPanelContent, panelDirectives } = usePanel();

      const classes = vue.computed(() =>
        'q-tab-panels q-panel-parent'
        + (isDark.value === true ? ' q-tab-panels--dark q-dark' : '')
      );

      return () => {
        updatePanelsList(slots);

        return hDir(
          'div',
          { class: classes.value },
          getPanelContent(),
          'pan',
          props.swipeable,
          () => panelDirectives.value
        )
      }
    }
  });

  var QTabPanel = vue.defineComponent({
    name: 'QTabPanel',

    props: usePanelChildProps,

    setup (_, { slots }) {
      return () => vue.h('div', { class: 'q-tab-panel' }, hSlot(slots.default))
    }
  });

  // file referenced from docs

  const
    hex = /^#[0-9a-fA-F]{3}([0-9a-fA-F]{3})?$/,
    hexa = /^#[0-9a-fA-F]{4}([0-9a-fA-F]{4})?$/,
    hexOrHexa = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/,
    rgb = /^rgb\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5])\)$/,
    rgba = /^rgba\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),(0|0\.[0-9]+[1-9]|0\.[1-9]+|1)\)$/;

  const testPattern = {
    date: v => /^-?[\d]+\/[0-1]\d\/[0-3]\d$/.test(v),
    time: v => /^([0-1]?\d|2[0-3]):[0-5]\d$/.test(v),
    fulltime: v => /^([0-1]?\d|2[0-3]):[0-5]\d:[0-5]\d$/.test(v),
    timeOrFulltime: v => /^([0-1]?\d|2[0-3]):[0-5]\d(:[0-5]\d)?$/.test(v),

    hexColor: v => hex.test(v),
    hexaColor: v => hexa.test(v),
    hexOrHexaColor: v => hexOrHexa.test(v),

    rgbColor: v => rgb.test(v),
    rgbaColor: v => rgba.test(v),
    rgbOrRgbaColor: v => rgb.test(v) || rgba.test(v),

    hexOrRgbColor: v => hex.test(v) || rgb.test(v),
    hexaOrRgbaColor: v => hexa.test(v) || rgba.test(v),
    anyColor: v => hexOrHexa.test(v) || rgb.test(v) || rgba.test(v)
  };

  var patterns = {
    testPattern
  };

  const reRGBA = /^rgb(a)?\((\d{1,3}),(\d{1,3}),(\d{1,3}),?([01]?\.?\d*?)?\)$/;

  function rgbToHex ({ r, g, b, a }) {
    const alpha = a !== void 0;

    r = Math.round(r);
    g = Math.round(g);
    b = Math.round(b);

    if (
      r > 255
      || g > 255
      || b > 255
      || (alpha && a > 100)
    ) {
      throw new TypeError('Expected 3 numbers below 256 (and optionally one below 100)')
    }

    a = alpha
      ? (Math.round(255 * a / 100) | 1 << 8).toString(16).slice(1)
      : '';

    return '#' + ((b | g << 8 | r << 16) | 1 << 24).toString(16).slice(1) + a
  }

  function rgbToString ({ r, g, b, a }) {
    return `rgb${ a !== void 0 ? 'a' : '' }(${ r },${ g },${ b }${ a !== void 0 ? ',' + (a / 100) : '' })`
  }

  function hexToRgb (hex) {
    if (typeof hex !== 'string') {
      throw new TypeError('Expected a string')
    }

    hex = hex.replace(/^#/, '');

    if (hex.length === 3) {
      hex = hex[ 0 ] + hex[ 0 ] + hex[ 1 ] + hex[ 1 ] + hex[ 2 ] + hex[ 2 ];
    }
    else if (hex.length === 4) {
      hex = hex[ 0 ] + hex[ 0 ] + hex[ 1 ] + hex[ 1 ] + hex[ 2 ] + hex[ 2 ] + hex[ 3 ] + hex[ 3 ];
    }

    const num = parseInt(hex, 16);

    return hex.length > 6
      ? { r: num >> 24 & 255, g: num >> 16 & 255, b: num >> 8 & 255, a: Math.round((num & 255) / 2.55) }
      : { r: num >> 16, g: num >> 8 & 255, b: num & 255 }
  }

  function hsvToRgb ({ h, s, v, a }) {
    let r, g, b;
    s = s / 100;
    v = v / 100;

    h = h / 360;
    const
      i = Math.floor(h * 6),
      f = h * 6 - i,
      p = v * (1 - s),
      q = v * (1 - f * s),
      t = v * (1 - (1 - f) * s);

    switch (i % 6) {
      case 0:
        r = v;
        g = t;
        b = p;
        break
      case 1:
        r = q;
        g = v;
        b = p;
        break
      case 2:
        r = p;
        g = v;
        b = t;
        break
      case 3:
        r = p;
        g = q;
        b = v;
        break
      case 4:
        r = t;
        g = p;
        b = v;
        break
      case 5:
        r = v;
        g = p;
        b = q;
        break
    }

    return {
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b * 255),
      a
    }
  }

  function rgbToHsv ({ r, g, b, a }) {
    const
      max = Math.max(r, g, b),
      min = Math.min(r, g, b),
      d = max - min,
      s = (max === 0 ? 0 : d / max),
      v = max / 255;
    let h;

    switch (max) {
      case min:
        h = 0;
        break
      case r:
        h = (g - b) + d * (g < b ? 6 : 0);
        h /= 6 * d;
        break
      case g:
        h = (b - r) + d * 2;
        h /= 6 * d;
        break
      case b:
        h = (r - g) + d * 4;
        h /= 6 * d;
        break
    }

    return {
      h: Math.round(h * 360),
      s: Math.round(s * 100),
      v: Math.round(v * 100),
      a
    }
  }

  function textToRgb (str) {
    if (typeof str !== 'string') {
      throw new TypeError('Expected a string')
    }

    const color = str.replace(/ /g, '');

    const m = reRGBA.exec(color);

    if (m === null) {
      return hexToRgb(color)
    }

    const rgb = {
      r: Math.min(255, parseInt(m[ 2 ], 10)),
      g: Math.min(255, parseInt(m[ 3 ], 10)),
      b: Math.min(255, parseInt(m[ 4 ], 10))
    };

    if (m[ 1 ]) {
      const alpha = parseFloat(m[ 5 ]);
      rgb.a = Math.min(1, isNaN(alpha) === true ? 1 : alpha) * 100;
    }

    return rgb
  }

  /* works as darken if percent < 0 */
  function lighten (color, percent) {
    if (typeof color !== 'string') {
      throw new TypeError('Expected a string as color')
    }
    if (typeof percent !== 'number') {
      throw new TypeError('Expected a numeric percent')
    }

    const rgb = textToRgb(color),
      t = percent < 0 ? 0 : 255,
      p = Math.abs(percent) / 100,
      R = rgb.r,
      G = rgb.g,
      B = rgb.b;

    return '#' + (
      0x1000000 + (Math.round((t - R) * p) + R) * 0x10000
      + (Math.round((t - G) * p) + G) * 0x100
      + (Math.round((t - B) * p) + B)
    ).toString(16).slice(1)
  }

  function luminosity (color) {
    if (typeof color !== 'string' && (!color || color.r === void 0)) {
      throw new TypeError('Expected a string or a {r, g, b} object as color')
    }

    const
      rgb = typeof color === 'string' ? textToRgb(color) : color,
      r = rgb.r / 255,
      g = rgb.g / 255,
      b = rgb.b / 255,
      R = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4),
      G = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4),
      B = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
    return 0.2126 * R + 0.7152 * G + 0.0722 * B
  }

  function brightness (color) {
    if (typeof color !== 'string' && (!color || color.r === void 0)) {
      throw new TypeError('Expected a string or a {r, g, b} object as color')
    }

    const rgb = typeof color === 'string'
      ? textToRgb(color)
      : color;

    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000
  }

  function blend (fgColor, bgColor) {
    if (typeof fgColor !== 'string' && (!fgColor || fgColor.r === void 0)) {
      throw new TypeError('Expected a string or a {r, g, b[, a]} object as fgColor')
    }

    if (typeof bgColor !== 'string' && (!bgColor || bgColor.r === void 0)) {
      throw new TypeError('Expected a string or a {r, g, b[, a]} object as bgColor')
    }

    const
      rgb1 = typeof fgColor === 'string' ? textToRgb(fgColor) : fgColor,
      r1 = rgb1.r / 255,
      g1 = rgb1.g / 255,
      b1 = rgb1.b / 255,
      a1 = rgb1.a !== void 0 ? rgb1.a / 100 : 1,
      rgb2 = typeof bgColor === 'string' ? textToRgb(bgColor) : bgColor,
      r2 = rgb2.r / 255,
      g2 = rgb2.g / 255,
      b2 = rgb2.b / 255,
      a2 = rgb2.a !== void 0 ? rgb2.a / 100 : 1,
      a = a1 + a2 * (1 - a1),
      r = Math.round(((r1 * a1 + r2 * a2 * (1 - a1)) / a) * 255),
      g = Math.round(((g1 * a1 + g2 * a2 * (1 - a1)) / a) * 255),
      b = Math.round(((b1 * a1 + b2 * a2 * (1 - a1)) / a) * 255);

    const ret = { r, g, b, a: Math.round(a * 100) };
    return typeof fgColor === 'string'
      ? rgbToHex(ret)
      : ret
  }

  function changeAlpha (color, offset) {
    if (typeof color !== 'string') {
      throw new TypeError('Expected a string as color')
    }

    if (offset === void 0 || offset < -1 || offset > 1) {
      throw new TypeError('Expected offset to be between -1 and 1')
    }

    const { r, g, b, a } = textToRgb(color);
    const alpha = a !== void 0 ? a / 100 : 0;

    return rgbToHex({
      r, g, b, a: Math.round(Math.min(1, Math.max(0, alpha + offset)) * 100)
    })
  }

  function getPaletteColor (colorName) {
    if (typeof colorName !== 'string') {
      throw new TypeError('Expected a string as color')
    }

    const el = document.createElement('div');

    el.className = `text-${ colorName } invisible fixed no-pointer-events`;
    document.body.appendChild(el);

    const result = getComputedStyle(el).getPropertyValue('color');

    el.remove();

    return rgbToHex(textToRgb(result))
  }

  var colors = {
    rgbToHex,
    hexToRgb,
    hsvToRgb,
    rgbToHsv,
    textToRgb,
    lighten,
    luminosity,
    brightness,
    blend,
    changeAlpha,
    getPaletteColor
  };

  const palette = [
    'rgb(255,204,204)', 'rgb(255,230,204)', 'rgb(255,255,204)', 'rgb(204,255,204)', 'rgb(204,255,230)', 'rgb(204,255,255)', 'rgb(204,230,255)', 'rgb(204,204,255)', 'rgb(230,204,255)', 'rgb(255,204,255)',
    'rgb(255,153,153)', 'rgb(255,204,153)', 'rgb(255,255,153)', 'rgb(153,255,153)', 'rgb(153,255,204)', 'rgb(153,255,255)', 'rgb(153,204,255)', 'rgb(153,153,255)', 'rgb(204,153,255)', 'rgb(255,153,255)',
    'rgb(255,102,102)', 'rgb(255,179,102)', 'rgb(255,255,102)', 'rgb(102,255,102)', 'rgb(102,255,179)', 'rgb(102,255,255)', 'rgb(102,179,255)', 'rgb(102,102,255)', 'rgb(179,102,255)', 'rgb(255,102,255)',
    'rgb(255,51,51)', 'rgb(255,153,51)', 'rgb(255,255,51)', 'rgb(51,255,51)', 'rgb(51,255,153)', 'rgb(51,255,255)', 'rgb(51,153,255)', 'rgb(51,51,255)', 'rgb(153,51,255)', 'rgb(255,51,255)',
    'rgb(255,0,0)', 'rgb(255,128,0)', 'rgb(255,255,0)', 'rgb(0,255,0)', 'rgb(0,255,128)', 'rgb(0,255,255)', 'rgb(0,128,255)', 'rgb(0,0,255)', 'rgb(128,0,255)', 'rgb(255,0,255)',
    'rgb(245,0,0)', 'rgb(245,123,0)', 'rgb(245,245,0)', 'rgb(0,245,0)', 'rgb(0,245,123)', 'rgb(0,245,245)', 'rgb(0,123,245)', 'rgb(0,0,245)', 'rgb(123,0,245)', 'rgb(245,0,245)',
    'rgb(214,0,0)', 'rgb(214,108,0)', 'rgb(214,214,0)', 'rgb(0,214,0)', 'rgb(0,214,108)', 'rgb(0,214,214)', 'rgb(0,108,214)', 'rgb(0,0,214)', 'rgb(108,0,214)', 'rgb(214,0,214)',
    'rgb(163,0,0)', 'rgb(163,82,0)', 'rgb(163,163,0)', 'rgb(0,163,0)', 'rgb(0,163,82)', 'rgb(0,163,163)', 'rgb(0,82,163)', 'rgb(0,0,163)', 'rgb(82,0,163)', 'rgb(163,0,163)',
    'rgb(92,0,0)', 'rgb(92,46,0)', 'rgb(92,92,0)', 'rgb(0,92,0)', 'rgb(0,92,46)', 'rgb(0,92,92)', 'rgb(0,46,92)', 'rgb(0,0,92)', 'rgb(46,0,92)', 'rgb(92,0,92)',
    'rgb(255,255,255)', 'rgb(205,205,205)', 'rgb(178,178,178)', 'rgb(153,153,153)', 'rgb(127,127,127)', 'rgb(102,102,102)', 'rgb(76,76,76)', 'rgb(51,51,51)', 'rgb(25,25,25)', 'rgb(0,0,0)'
  ];

  const thumbPath = 'M5 5 h10 v10 h-10 v-10 z';

  var QColor = vue.defineComponent({
    name: 'QColor',

    props: {
      ...useDarkProps,
      ...useFormProps,

      modelValue: String,

      defaultValue: String,
      defaultView: {
        type: String,
        default: 'spectrum',
        validator: v => [ 'spectrum', 'tune', 'palette' ].includes(v)
      },

      formatModel: {
        type: String,
        default: 'auto',
        validator: v => [ 'auto', 'hex', 'rgb', 'hexa', 'rgba' ].includes(v)
      },

      palette: Array,

      noHeader: Boolean,
      noFooter: Boolean,

      square: Boolean,
      flat: Boolean,
      bordered: Boolean,

      disable: Boolean,
      readonly: Boolean
    },

    emits: [ 'update:modelValue', 'change' ],

    setup (props, { emit }) {
      const { proxy } = vue.getCurrentInstance();
      const { $q } = proxy;

      const isDark = useDark(props, $q);
      const { getCache } = useCache();

      const spectrumRef = vue.ref(null);
      const errorIconRef = vue.ref(null);

      const forceHex = vue.computed(() => (
        props.formatModel === 'auto'
          ? null
          : props.formatModel.indexOf('hex') > -1
      ));

      const forceAlpha = vue.computed(() => (
        props.formatModel === 'auto'
          ? null
          : props.formatModel.indexOf('a') > -1
      ));

      const topView = vue.ref(
        props.formatModel === 'auto'
          ? (
              (props.modelValue === void 0 || props.modelValue === null || props.modelValue === '' || props.modelValue.startsWith('#'))
                ? 'hex'
                : 'rgb'
            )
          : (props.formatModel.startsWith('hex') ? 'hex' : 'rgb')
      );

      const view = vue.ref(props.defaultView);
      const model = vue.ref(parseModel(props.modelValue || props.defaultValue));

      const editable = vue.computed(() => props.disable !== true && props.readonly !== true);

      const isHex = vue.computed(() =>
        props.modelValue === void 0
        || props.modelValue === null
        || props.modelValue === ''
        || props.modelValue.startsWith('#')
      );

      const isOutputHex = vue.computed(() => (
        forceHex.value !== null
          ? forceHex.value
          : isHex.value
      ));

      const formAttrs = vue.computed(() => ({
        type: 'hidden',
        name: props.name,
        value: model.value[ isOutputHex.value === true ? 'hex' : 'rgb' ]
      }));

      const injectFormInput = useFormInject(formAttrs);

      const hasAlpha = vue.computed(() => (
        forceAlpha.value !== null
          ? forceAlpha.value
          : model.value.a !== void 0
      ));

      const currentBgColor = vue.computed(() => ({
        backgroundColor: model.value.rgb || '#000'
      }));

      const headerClass = vue.computed(() => {
        const light = model.value.a !== void 0 && model.value.a < 65
          ? true
          : luminosity(model.value) > 0.4;

        return 'q-color-picker__header-content absolute-full'
          + ` q-color-picker__header-content--${ light ? 'light' : 'dark' }`
      });

      const spectrumStyle = vue.computed(() => ({
        background: `hsl(${ model.value.h },100%,50%)`
      }));

      const spectrumPointerStyle = vue.computed(() => ({
        top: `${ 100 - model.value.v }%`,
        [ $q.lang.rtl === true ? 'right' : 'left' ]: `${ model.value.s }%`
      }));

      const computedPalette = vue.computed(() => (
        props.palette !== void 0 && props.palette.length > 0
          ? props.palette
          : palette
      ));

      const classes = vue.computed(() =>
        'q-color-picker'
        + (props.bordered === true ? ' q-color-picker--bordered' : '')
        + (props.square === true ? ' q-color-picker--square no-border-radius' : '')
        + (props.flat === true ? ' q-color-picker--flat no-shadow' : '')
        + (props.disable === true ? ' disabled' : '')
        + (isDark.value === true ? ' q-color-picker--dark q-dark' : '')
      );

      const attributes = vue.computed(() => {
        if (props.disable === true) {
          return { 'aria-disabled': 'true' }
        }
        if (props.readonly === true) {
          return { 'aria-readonly': 'true' }
        }
        return {}
      });

      const spectrumDirective = vue.computed(() => {
        // if editable.value === true
        return [ [
          TouchPan,
          onSpectrumPan,
          void 0,
          { prevent: true, stop: true, mouse: true }
        ] ]
      });

      vue.watch(() => props.modelValue, v => {
        const localModel = parseModel(v || props.defaultValue);
        if (localModel.hex !== model.value.hex) {
          model.value = localModel;
        }
      });

      vue.watch(() => props.defaultValue, v => {
        if (!props.modelValue && v) {
          const localModel = parseModel(v);
          if (localModel.hex !== model.value.hex) {
            model.value = localModel;
          }
        }
      });

      function updateModel (rgb, change) {
        // update internally
        model.value.hex = rgbToHex(rgb);
        model.value.rgb = rgbToString(rgb);
        model.value.r = rgb.r;
        model.value.g = rgb.g;
        model.value.b = rgb.b;
        model.value.a = rgb.a;

        const value = model.value[ isOutputHex.value === true ? 'hex' : 'rgb' ];

        // emit new value
        emit('update:modelValue', value);
        change === true && emit('change', value);
      }

      function parseModel (v) {
        const alpha = forceAlpha.value !== void 0
          ? forceAlpha.value
          : (
              props.formatModel === 'auto'
                ? null
                : props.formatModel.indexOf('a') > -1
            );

        if (typeof v !== 'string' || v.length === 0 || testPattern.anyColor(v.replace(/ /g, '')) !== true) {
          return {
            h: 0,
            s: 0,
            v: 0,
            r: 0,
            g: 0,
            b: 0,
            a: alpha === true ? 100 : void 0,
            hex: void 0,
            rgb: void 0
          }
        }

        const model = textToRgb(v);

        if (alpha === true && model.a === void 0) {
          model.a = 100;
        }

        model.hex = rgbToHex(model);
        model.rgb = rgbToString(model);

        return Object.assign(model, rgbToHsv(model))
      }

      function changeSpectrum (left, top, change) {
        const panel = spectrumRef.value;
        if (panel === void 0) { return }

        const
          width = panel.clientWidth,
          height = panel.clientHeight,
          rect = panel.getBoundingClientRect();

        let x = Math.min(width, Math.max(0, left - rect.left));

        if ($q.lang.rtl === true) {
          x = width - x;
        }

        const
          y = Math.min(height, Math.max(0, top - rect.top)),
          s = Math.round(100 * x / width),
          v = Math.round(100 * Math.max(0, Math.min(1, -(y / height) + 1))),
          rgb = hsvToRgb({
            h: model.value.h,
            s,
            v,
            a: hasAlpha.value === true ? model.value.a : void 0
          });

        model.value.s = s;
        model.value.v = v;
        updateModel(rgb, change);
      }

      function onHueChange (val, change) {
        const h = Math.round(val);
        const rgb = hsvToRgb({
          h,
          s: model.value.s,
          v: model.value.v,
          a: hasAlpha.value === true ? model.value.a : void 0
        });

        model.value.h = h;
        updateModel(rgb, change);
      }

      function onNumericChange (value, formatModel, max, evt, change) {
        evt !== void 0 && stop(evt);

        if (!/^[0-9]+$/.test(value)) {
          change === true && proxy.$forceUpdate();
          return
        }

        const val = Math.floor(Number(value));

        if (val < 0 || val > max) {
          change === true && proxy.$forceUpdate();
          return
        }

        const rgb = {
          r: formatModel === 'r' ? val : model.value.r,
          g: formatModel === 'g' ? val : model.value.g,
          b: formatModel === 'b' ? val : model.value.b,
          a: hasAlpha.value === true
            ? (formatModel === 'a' ? val : model.value.a)
            : void 0
        };

        if (formatModel !== 'a') {
          const hsv = rgbToHsv(rgb);
          model.value.h = hsv.h;
          model.value.s = hsv.s;
          model.value.v = hsv.v;
        }

        updateModel(rgb, change);

        if (evt !== void 0 && change !== true && evt.target.selectionEnd !== void 0) {
          const index = evt.target.selectionEnd;
          vue.nextTick(() => {
            evt.target.setSelectionRange(index, index);
          });
        }
      }

      function onEditorChange (evt, change) {
        let rgb;
        const inp = evt.target.value;

        stop(evt);

        if (topView.value === 'hex') {
          if (
            inp.length !== (hasAlpha.value === true ? 9 : 7)
            || !/^#[0-9A-Fa-f]+$/.test(inp)
          ) {
            return true
          }

          rgb = hexToRgb(inp);
        }
        else {
          let model;

          if (!inp.endsWith(')')) {
            return true
          }
          else if (hasAlpha.value !== true && inp.startsWith('rgb(')) {
            model = inp.substring(4, inp.length - 1).split(',').map(n => parseInt(n, 10));

            if (
              model.length !== 3
              || !/^rgb\([0-9]{1,3},[0-9]{1,3},[0-9]{1,3}\)$/.test(inp)
            ) {
              return true
            }
          }
          else if (hasAlpha.value === true && inp.startsWith('rgba(')) {
            model = inp.substring(5, inp.length - 1).split(',');

            if (
              model.length !== 4
              || !/^rgba\([0-9]{1,3},[0-9]{1,3},[0-9]{1,3},(0|0\.[0-9]+[1-9]|0\.[1-9]+|1)\)$/.test(inp)
            ) {
              return true
            }

            for (let i = 0; i < 3; i++) {
              const v = parseInt(model[ i ], 10);
              if (v < 0 || v > 255) {
                return true
              }
              model[ i ] = v;
            }

            const v = parseFloat(model[ 3 ]);
            if (v < 0 || v > 1) {
              return true
            }
            model[ 3 ] = v;
          }
          else {
            return true
          }

          if (
            model[ 0 ] < 0 || model[ 0 ] > 255
            || model[ 1 ] < 0 || model[ 1 ] > 255
            || model[ 2 ] < 0 || model[ 2 ] > 255
            || (hasAlpha.value === true && (model[ 3 ] < 0 || model[ 3 ] > 1))
          ) {
            return true
          }

          rgb = {
            r: model[ 0 ],
            g: model[ 1 ],
            b: model[ 2 ],
            a: hasAlpha.value === true
              ? model[ 3 ] * 100
              : void 0
          };
        }

        const hsv = rgbToHsv(rgb);
        model.value.h = hsv.h;
        model.value.s = hsv.s;
        model.value.v = hsv.v;

        updateModel(rgb, change);

        if (change !== true) {
          const index = evt.target.selectionEnd;
          vue.nextTick(() => {
            evt.target.setSelectionRange(index, index);
          });
        }
      }

      function onPalettePick (color) {
        const def = parseModel(color);
        const rgb = { r: def.r, g: def.g, b: def.b, a: def.a };

        if (rgb.a === void 0) {
          rgb.a = model.value.a;
        }

        model.value.h = def.h;
        model.value.s = def.s;
        model.value.v = def.v;

        updateModel(rgb, true);
      }

      function onSpectrumPan (evt) {
        if (evt.isFinal) {
          changeSpectrum(
            evt.position.left,
            evt.position.top,
            true
          );
        }
        else {
          onSpectrumChange(evt);
        }
      }

      const onSpectrumChange = throttle(
        evt => { changeSpectrum(evt.position.left, evt.position.top); },
        20
      );

      function onSpectrumClick (evt) {
        changeSpectrum(
          evt.pageX - window.pageXOffset,
          evt.pageY - window.pageYOffset,
          true
        );
      }

      function onActivate (evt) {
        changeSpectrum(
          evt.pageX - window.pageXOffset,
          evt.pageY - window.pageYOffset
        );
      }

      function updateErrorIcon (val) {
        // we MUST avoid vue triggering a render,
        // so manually changing this
        if (errorIconRef.value !== null) {
          errorIconRef.value.$el.style.opacity = val ? 1 : 0;
        }
      }

      function getHeader () {
        return vue.h('div', {
          class: 'q-color-picker__header relative-position overflow-hidden'
        }, [
          vue.h('div', { class: 'q-color-picker__header-bg absolute-full' }),

          vue.h('div', {
            class: headerClass.value,
            style: currentBgColor.value
          }, [
            vue.h(QTabs, {
              modelValue: topView.value,
              dense: true,
              align: 'justify',
              ...getCache('topVTab', {
                'onUpdate:modelValue': val => { topView.value = val; }
              })
            }, () => [
              vue.h(QTab, {
                label: 'HEX' + (hasAlpha.value === true ? 'A' : ''),
                name: 'hex',
                ripple: false
              }),

              vue.h(QTab, {
                label: 'RGB' + (hasAlpha.value === true ? 'A' : ''),
                name: 'rgb',
                ripple: false
              })
            ]),

            vue.h('div', {
              class: 'q-color-picker__header-banner row flex-center no-wrap'
            }, [
              vue.h('input', {
                class: 'fit',
                value: model.value[ topView.value ],
                ...(editable.value !== true
                  ? { readonly: true }
                  : {}
                ),
                ...getCache('topIn', {
                  onInput: evt => {
                    updateErrorIcon(onEditorChange(evt) === true);
                  },
                  onChange: stop,
                  onBlur: evt => {
                    onEditorChange(evt, true) === true && proxy.$forceUpdate();
                    updateErrorIcon(false);
                  }
                })
              }),

              vue.h(QIcon, {
                ref: errorIconRef,
                class: 'q-color-picker__error-icon absolute no-pointer-events',
                name: $q.iconSet.type.negative
              })
            ])
          ])
        ])
      }

      function getContent () {
        return vue.h(QTabPanels, {
          modelValue: view.value,
          animated: true
        }, () => [
          vue.h(QTabPanel, {
            class: 'q-color-picker__spectrum-tab overflow-hidden',
            name: 'spectrum'
          }, getSpectrumTab),

          vue.h(QTabPanel, {
            class: 'q-pa-md q-color-picker__tune-tab',
            name: 'tune'
          }, getTuneTab),

          vue.h(QTabPanel, {
            class: 'q-color-picker__palette-tab',
            name: 'palette'
          }, getPaletteTab)
        ])
      }

      function getFooter () {
        return vue.h('div', {
          class: 'q-color-picker__footer relative-position overflow-hidden'
        }, [
          vue.h(QTabs, {
            class: 'absolute-full',
            modelValue: view.value,
            dense: true,
            align: 'justify',
            ...getCache('ftIn', {
              'onUpdate:modelValue': val => { view.value = val; }
            })
          }, () => [
            vue.h(QTab, {
              icon: $q.iconSet.colorPicker.spectrum,
              name: 'spectrum',
              ripple: false
            }),

            vue.h(QTab, {
              icon: $q.iconSet.colorPicker.tune,
              name: 'tune',
              ripple: false
            }),

            vue.h(QTab, {
              icon: $q.iconSet.colorPicker.palette,
              name: 'palette',
              ripple: false
            })
          ])
        ])
      }

      function getSpectrumTab () {
        const data = {
          ref: spectrumRef,
          class: 'q-color-picker__spectrum non-selectable relative-position cursor-pointer'
            + (editable.value !== true ? ' readonly' : ''),
          style: spectrumStyle.value,
          ...(editable.value === true
            ? {
                onClick: onSpectrumClick,
                onMousedown: onActivate
              }
            : {}
          )
        };

        const child = [
          vue.h('div', { style: { paddingBottom: '100%' } }),
          vue.h('div', { class: 'q-color-picker__spectrum-white absolute-full' }),
          vue.h('div', { class: 'q-color-picker__spectrum-black absolute-full' }),
          vue.h('div', {
            class: 'absolute',
            style: spectrumPointerStyle.value
          }, [
            model.value.hex !== void 0
              ? vue.h('div', { class: 'q-color-picker__spectrum-circle' })
              : null
          ])
        ];

        const sliders = [
          vue.h('div', { class: 'q-color-picker__hue non-selectable' }, [
            vue.h(QSlider, {
              modelValue: model.value.h,
              min: 0,
              max: 360,
              fillHandleAlways: true,
              readonly: editable.value !== true,
              thumbPath,
              'onUpdate:modelValue': onHueChange,
              ...getCache('lazyhue', {
                onChange: val => onHueChange(val, true)
              })
            })
          ])
        ];

        hasAlpha.value === true && sliders.push(
          vue.h('div', { class: 'q-color-picker__alpha non-selectable' }, [
            vue.h(QSlider, {
              modelValue: model.value.a,
              min: 0,
              max: 100,
              fillHandleAlways: true,
              readonly: editable.value !== true,
              thumbPath,
              ...getCache('alphaSlide', {
                'onUpdate:modelValue': value => onNumericChange(value, 'a', 100),
                onChange: value => onNumericChange(value, 'a', 100, void 0, true)
              })
            })
          ])
        );

        return [
          hDir('div', data, child, 'spec', editable.value, () => spectrumDirective.value),
          vue.h('div', { class: 'q-color-picker__sliders' }, sliders)
        ]
      }

      function getTuneTab () {
        return [
          vue.h('div', { class: 'row items-center no-wrap' }, [
            vue.h('div', 'R'),
            vue.h(QSlider, {
              modelValue: model.value.r,
              min: 0,
              max: 255,
              color: 'red',
              dark: isDark.value,
              readonly: editable.value !== true,
              ...getCache('rSlide', {
                'onUpdate:modelValue': value => onNumericChange(value, 'r', 255),
                onChange: value => onNumericChange(value, 'r', 255, void 0, true)
              })
            }),
            vue.h('input', {
              value: model.value.r,
              maxlength: 3,
              readonly: editable.value !== true,
              onChange: stop,
              ...getCache('rIn', {
                onInput: evt => onNumericChange(evt.target.value, 'r', 255, evt),
                onBlur: evt => onNumericChange(evt.target.value, 'r', 255, evt, true)
              })
            })
          ]),

          vue.h('div', { class: 'row items-center no-wrap' }, [
            vue.h('div', 'G'),
            vue.h(QSlider, {
              modelValue: model.value.g,
              min: 0,
              max: 255,
              color: 'green',
              dark: isDark.value,
              readonly: editable.value !== true,
              ...getCache('gSlide', {
                'onUpdate:modelValue': value => onNumericChange(value, 'g', 255),
                onChange: value => onNumericChange(value, 'g', 255, void 0, true)
              })
            }),
            vue.h('input', {
              value: model.value.g,
              maxlength: 3,
              readonly: editable.value !== true,
              onChange: stop,
              ...getCache('gIn', {
                onInput: evt => onNumericChange(evt.target.value, 'g', 255, evt),
                onBlur: evt => onNumericChange(evt.target.value, 'g', 255, evt, true)
              })
            })
          ]),

          vue.h('div', { class: 'row items-center no-wrap' }, [
            vue.h('div', 'B'),
            vue.h(QSlider, {
              modelValue: model.value.b,
              min: 0,
              max: 255,
              color: 'blue',
              readonly: editable.value !== true,
              dark: isDark.value,
              ...getCache('bSlide', {
                'onUpdate:modelValue': value => onNumericChange(value, 'b', 255),
                onChange: value => onNumericChange(value, 'b', 255, void 0, true)
              })
            }),
            vue.h('input', {
              value: model.value.b,
              maxlength: 3,
              readonly: editable.value !== true,
              onChange: stop,
              ...getCache('bIn', {
                onInput: evt => onNumericChange(evt.target.value, 'b', 255, evt),
                onBlur: evt => onNumericChange(evt.target.value, 'b', 255, evt, true)
              })
            })
          ]),

          hasAlpha.value === true ? vue.h('div', { class: 'row items-center no-wrap' }, [
            vue.h('div', 'A'),
            vue.h(QSlider, {
              modelValue: model.value.a,
              color: 'grey',
              readonly: editable.value !== true,
              dark: isDark.value,
              ...getCache('aSlide', {
                'onUpdate:modelValue': value => onNumericChange(value, 'a', 100),
                onChange: value => onNumericChange(value, 'a', 100, void 0, true)
              })
            }),
            vue.h('input', {
              value: model.value.a,
              maxlength: 3,
              readonly: editable.value !== true,
              onChange: stop,
              ...getCache('aIn', {
                onInput: evt => onNumericChange(evt.target.value, 'a', 100, evt),
                onBlur: evt => onNumericChange(evt.target.value, 'a', 100, evt, true)
              })
            })
          ]) : null
        ]
      }

      function getPaletteTab () {
        return [
          vue.h('div', {
            class: 'row items-center q-color-picker__palette-rows'
              + (editable.value === true ? ' q-color-picker__palette-rows--editable' : '')
          }, computedPalette.value.map(color => vue.h('div', {
            class: 'q-color-picker__cube col-auto',
            style: { backgroundColor: color },
            ...(editable.value === true ? getCache('palette#' + color, {
              onClick: () => {
                onPalettePick(color);
              }
            }) : {})
          })))
        ]
      }

      return () => {
        const child = [ getContent() ];

        if (props.name !== void 0 && props.disable !== true) {
          injectFormInput(child, 'push');
        }

        props.noHeader !== true && child.unshift(
          getHeader()
        );

        props.noFooter !== true && child.push(
          getFooter()
        );

        return vue.h('div', {
          class: classes.value,
          ...attributes.value
        }, child)
      }
    }
  });

  // taken from https://github.com/jalaali/jalaali-js

  /*
    Jalaali years starting the 33-year rule.
  */
  const breaks = [
    -61, 9, 38, 199, 426, 686, 756, 818, 1111, 1181, 1210,
    1635, 2060, 2097, 2192, 2262, 2324, 2394, 2456, 3178
  ];

  /*
    Converts a Gregorian date to Jalaali.
  */
  function toJalaali (gy, gm, gd) {
    if (Object.prototype.toString.call(gy) === '[object Date]') {
      gd = gy.getDate();
      gm = gy.getMonth() + 1;
      gy = gy.getFullYear();
    }
    return d2j(g2d(gy, gm, gd))
  }

  /*
    Converts a Jalaali date to Gregorian.
  */
  function toGregorian (jy, jm, jd) {
    return d2g(j2d(jy, jm, jd))
  }

  /*
    Is this a leap year or not?
  */
  function isLeapJalaaliYear (jy) {
    return jalCalLeap(jy) === 0
  }

  /*
    Number of days in a given month in a Jalaali year.
  */
  function jalaaliMonthLength (jy, jm) {
    if (jm <= 6) return 31
    if (jm <= 11) return 30
    if (isLeapJalaaliYear(jy)) return 30
    return 29
  }

  /*
      This function determines if the Jalaali (Persian) year is
      leap (366-day long) or is the common year (365 days)

      @param jy Jalaali calendar year (-61 to 3177)
      @returns number of years since the last leap year (0 to 4)
   */
  function jalCalLeap (jy) {
    const bl = breaks.length;
    let
      jp = breaks[ 0 ],
      jm,
      jump,
      leap,
      n,
      i;

    if (jy < jp || jy >= breaks[ bl - 1 ]) { throw new Error('Invalid Jalaali year ' + jy) }

    for (i = 1; i < bl; i += 1) {
      jm = breaks[ i ];
      jump = jm - jp;
      if (jy < jm) { break }
      jp = jm;
    }
    n = jy - jp;

    if (jump - n < 6) { n = n - jump + div(jump + 4, 33) * 33; }
    leap = mod(mod(n + 1, 33) - 1, 4);
    if (leap === -1) {
      leap = 4;
    }

    return leap
  }

  /*
    This function determines if the Jalaali (Persian) year is
    leap (366-day long) or is the common year (365 days), and
    finds the day in March (Gregorian calendar) of the first
    day of the Jalaali year (jy).

    @param jy Jalaali calendar year (-61 to 3177)
    @param withoutLeap when don't need leap (true or false) default is false
    @return
      leap: number of years since the last leap year (0 to 4)
      gy: Gregorian year of the beginning of Jalaali year
      march: the March day of Farvardin the 1st (1st day of jy)
    @see: http://www.astro.uni.torun.pl/~kb/Papers/EMP/PersianC-EMP.htm
    @see: http://www.fourmilab.ch/documents/calendar/
  */
  function jalCal (jy, withoutLeap) {
    const
      bl = breaks.length,
      gy = jy + 621;
    let
      leapJ = -14,
      jp = breaks[ 0 ],
      jm,
      jump,
      leap,
      n,
      i;

    if (jy < jp || jy >= breaks[ bl - 1 ]) { throw new Error('Invalid Jalaali year ' + jy) }

    // Find the limiting years for the Jalaali year jy.
    for (i = 1; i < bl; i += 1) {
      jm = breaks[ i ];
      jump = jm - jp;
      if (jy < jm) { break }
      leapJ = leapJ + div(jump, 33) * 8 + div(mod(jump, 33), 4);
      jp = jm;
    }
    n = jy - jp;

    // Find the number of leap years from AD 621 to the beginning
    // of the current Jalaali year in the Persian calendar.
    leapJ = leapJ + div(n, 33) * 8 + div(mod(n, 33) + 3, 4);
    if (mod(jump, 33) === 4 && jump - n === 4) { leapJ += 1; }

    // And the same in the Gregorian calendar (until the year gy).
    const leapG = div(gy, 4) - div((div(gy, 100) + 1) * 3, 4) - 150;

    // Determine the Gregorian date of Farvardin the 1st.
    const march = 20 + leapJ - leapG;

    // Find how many years have passed since the last leap year.
    if (!withoutLeap) {
      if (jump - n < 6) { n = n - jump + div(jump + 4, 33) * 33; }
      leap = mod(mod(n + 1, 33) - 1, 4);
      if (leap === -1) {
        leap = 4;
      }
    }

    return {
      leap: leap,
      gy: gy,
      march: march
    }
  }

  /*
    Converts a date of the Jalaali calendar to the Julian Day number.

    @param jy Jalaali year (1 to 3100)
    @param jm Jalaali month (1 to 12)
    @param jd Jalaali day (1 to 29/31)
    @return Julian Day number
  */
  function j2d (jy, jm, jd) {
    const r = jalCal(jy, true);
    return g2d(r.gy, 3, r.march) + (jm - 1) * 31 - div(jm, 7) * (jm - 7) + jd - 1
  }

  /*
    Converts the Julian Day number to a date in the Jalaali calendar.

    @param jdn Julian Day number
    @return
      jy: Jalaali year (1 to 3100)
      jm: Jalaali month (1 to 12)
      jd: Jalaali day (1 to 29/31)
  */
  function d2j (jdn) {
    const gy = d2g(jdn).gy; // Calculate Gregorian year (gy).
    let
      jy = gy - 621,
      jd,
      jm,
      k;
    const
      r = jalCal(jy, false),
      jdn1f = g2d(gy, 3, r.march);

    // Find number of days that passed since 1 Farvardin.
    k = jdn - jdn1f;
    if (k >= 0) {
      if (k <= 185) {
        // The first 6 months.
        jm = 1 + div(k, 31);
        jd = mod(k, 31) + 1;
        return {
          jy: jy,
          jm: jm,
          jd: jd
        }
      }
      else {
        // The remaining months.
        k -= 186;
      }
    }
    else {
      // Previous Jalaali year.
      jy -= 1;
      k += 179;
      if (r.leap === 1) { k += 1; }
    }
    jm = 7 + div(k, 30);
    jd = mod(k, 30) + 1;
    return {
      jy: jy,
      jm: jm,
      jd: jd
    }
  }

  /*
    Calculates the Julian Day number from Gregorian or Julian
    calendar dates. This integer number corresponds to the noon of
    the date (i.e. 12 hours of Universal Time).
    The procedure was tested to be good since 1 March, -100100 (of both
    calendars) up to a few million years into the future.

    @param gy Calendar year (years BC numbered 0, -1, -2, ...)
    @param gm Calendar month (1 to 12)
    @param gd Calendar day of the month (1 to 28/29/30/31)
    @return Julian Day number
  */
  function g2d (gy, gm, gd) {
    let d = div((gy + div(gm - 8, 6) + 100100) * 1461, 4)
        + div(153 * mod(gm + 9, 12) + 2, 5)
        + gd - 34840408;
    d = d - div(div(gy + 100100 + div(gm - 8, 6), 100) * 3, 4) + 752;
    return d
  }

  /*
    Calculates Gregorian and Julian calendar dates from the Julian Day number
    (jdn) for the period since jdn=-34839655 (i.e. the year -100100 of both
    calendars) to some millions years ahead of the present.

    @param jdn Julian Day number
    @return
      gy: Calendar year (years BC numbered 0, -1, -2, ...)
      gm: Calendar month (1 to 12)
      gd: Calendar day of the month M (1 to 28/29/30/31)
  */
  function d2g (jdn) {
    let j = 4 * jdn + 139361631;
    j = j + div(div(4 * jdn + 183187720, 146097) * 3, 4) * 4 - 3908;
    const
      i = div(mod(j, 1461), 4) * 5 + 308,
      gd = div(mod(i, 153), 5) + 1,
      gm = mod(div(i, 153), 12) + 1,
      gy = div(j, 1461) - 100100 + div(8 - gm, 6);
    return {
      gy: gy,
      gm: gm,
      gd: gd
    }
  }

  /*
    Utility helper functions.
  */

  function div (a, b) {
    return ~~(a / b)
  }

  function mod (a, b) {
    return a - ~~(a / b) * b
  }

  const calendars = [ 'gregorian', 'persian' ];

  const useDatetimeProps = {
    modelValue: {
      required: true
    },

    mask: {
      type: String
    },
    locale: Object,

    calendar: {
      type: String,
      validator: v => calendars.includes(v),
      default: 'gregorian'
    },

    landscape: Boolean,

    color: String,
    textColor: String,

    square: Boolean,
    flat: Boolean,
    bordered: Boolean,

    readonly: Boolean,
    disable: Boolean
  };

  const useDatetimeEmits = [ 'update:modelValue' ];

  function getDayHash (date) {
    return date.year + '/' + pad(date.month) + '/' + pad(date.day)
  }

  function useDatetime (props, $q) {
    const editable = vue.computed(() => {
      return props.disable !== true && props.readonly !== true
    });

    const tabindex = vue.computed(() => {
      return props.editable === true ? 0 : -1
    });

    const headerClass = vue.computed(() => {
      const cls = [];
      props.color !== void 0 && cls.push(`bg-${ props.color }`);
      props.textColor !== void 0 && cls.push(`text-${ props.textColor }`);
      return cls.join(' ')
    });

    function getLocale () {
      return props.locale || $q.lang.date
    }

    function getCurrentDate (dateOnly) {
      const d = new Date();
      const timeFill = dateOnly === true ? null : 0;

      if (props.calendar === 'persian') {
        const jDate = toJalaali(d);
        return {
          year: jDate.jy,
          month: jDate.jm,
          day: jDate.jd
        }
      }

      return {
        year: d.getFullYear(),
        month: d.getMonth() + 1,
        day: d.getDate(),
        hour: timeFill,
        minute: timeFill,
        second: timeFill,
        millisecond: timeFill
      }
    }

    return {
      editable,
      tabindex,
      headerClass,

      getLocale,
      getCurrentDate
    }
  }

  /* eslint no-fallthrough: 0 */

  const
    MILLISECONDS_IN_DAY = 86400000,
    MILLISECONDS_IN_HOUR = 3600000,
    MILLISECONDS_IN_MINUTE = 60000,
    defaultMask = 'YYYY-MM-DDTHH:mm:ss.SSSZ',
    token = /\[((?:[^\]\\]|\\]|\\)*)\]|d{1,4}|M{1,4}|m{1,2}|w{1,2}|Qo|Do|D{1,4}|YY(?:YY)?|H{1,2}|h{1,2}|s{1,2}|S{1,3}|Z{1,2}|a{1,2}|[AQExX]/g,
    reverseToken = /(\[[^\]]*\])|d{1,4}|M{1,4}|m{1,2}|w{1,2}|Qo|Do|D{1,4}|YY(?:YY)?|H{1,2}|h{1,2}|s{1,2}|S{1,3}|Z{1,2}|a{1,2}|[AQExX]|([.*+:?^,\s${}()|\\]+)/g,
    regexStore = {};

  function getRegexData (mask, dateLocale) {
    const
      days = '(' + dateLocale.days.join('|') + ')',
      key = mask + days;

    if (regexStore[ key ] !== void 0) {
      return regexStore[ key ]
    }

    const
      daysShort = '(' + dateLocale.daysShort.join('|') + ')',
      months = '(' + dateLocale.months.join('|') + ')',
      monthsShort = '(' + dateLocale.monthsShort.join('|') + ')';

    const map = {};
    let index = 0;

    const regexText = mask.replace(reverseToken, match => {
      index++;
      switch (match) {
        case 'YY':
          map.YY = index;
          return '(-?\\d{1,2})'
        case 'YYYY':
          map.YYYY = index;
          return '(-?\\d{1,4})'
        case 'M':
          map.M = index;
          return '(\\d{1,2})'
        case 'MM':
          map.M = index; // bumping to M
          return '(\\d{2})'
        case 'MMM':
          map.MMM = index;
          return monthsShort
        case 'MMMM':
          map.MMMM = index;
          return months
        case 'D':
          map.D = index;
          return '(\\d{1,2})'
        case 'Do':
          map.D = index++; // bumping to D
          return '(\\d{1,2}(st|nd|rd|th))'
        case 'DD':
          map.D = index; // bumping to D
          return '(\\d{2})'
        case 'H':
          map.H = index;
          return '(\\d{1,2})'
        case 'HH':
          map.H = index; // bumping to H
          return '(\\d{2})'
        case 'h':
          map.h = index;
          return '(\\d{1,2})'
        case 'hh':
          map.h = index; // bumping to h
          return '(\\d{2})'
        case 'm':
          map.m = index;
          return '(\\d{1,2})'
        case 'mm':
          map.m = index; // bumping to m
          return '(\\d{2})'
        case 's':
          map.s = index;
          return '(\\d{1,2})'
        case 'ss':
          map.s = index; // bumping to s
          return '(\\d{2})'
        case 'S':
          map.S = index;
          return '(\\d{1})'
        case 'SS':
          map.S = index; // bump to S
          return '(\\d{2})'
        case 'SSS':
          map.S = index; // bump to S
          return '(\\d{3})'
        case 'A':
          map.A = index;
          return '(AM|PM)'
        case 'a':
          map.a = index;
          return '(am|pm)'
        case 'aa':
          map.aa = index;
          return '(a\\.m\\.|p\\.m\\.)'

        case 'ddd':
          return daysShort
        case 'dddd':
          return days
        case 'Q':
        case 'd':
        case 'E':
          return '(\\d{1})'
        case 'Qo':
          return '(1st|2nd|3rd|4th)'
        case 'DDD':
        case 'DDDD':
          return '(\\d{1,3})'
        case 'w':
          return '(\\d{1,2})'
        case 'ww':
          return '(\\d{2})'

        case 'Z': // to split: (?:(Z)()()|([+-])?(\\d{2}):?(\\d{2}))
          map.Z = index;
          return '(Z|[+-]\\d{2}:\\d{2})'
        case 'ZZ':
          map.ZZ = index;
          return '(Z|[+-]\\d{2}\\d{2})'

        case 'X':
          map.X = index;
          return '(-?\\d+)'
        case 'x':
          map.x = index;
          return '(-?\\d{4,})'

        default:
          index--;
          if (match[ 0 ] === '[') {
            match = match.substring(1, match.length - 1);
          }
          return match.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
      }
    });

    const res = { map, regex: new RegExp('^' + regexText) };
    regexStore[ key ] = res;

    return res
  }

  function extractDate (str, mask, dateLocale) {
    const d = __splitDate(str, mask, dateLocale);

    const date = new Date(
      d.year,
      d.month === null ? null : d.month - 1,
      d.day,
      d.hour,
      d.minute,
      d.second,
      d.millisecond
    );

    const tzOffset = date.getTimezoneOffset();

    return d.timezoneOffset === null || d.timezoneOffset === tzOffset
      ? date
      : getChange(date, { minutes: d.timezoneOffset - tzOffset }, true)
  }

  function __splitDate (str, mask, dateLocale, calendar, defaultModel) {
    const date = {
      year: null,
      month: null,
      day: null,
      hour: null,
      minute: null,
      second: null,
      millisecond: null,
      timezoneOffset: null,
      dateHash: null,
      timeHash: null
    };

    defaultModel !== void 0 && Object.assign(date, defaultModel);

    if (
      str === void 0
      || str === null
      || str === ''
      || typeof str !== 'string'
    ) {
      return date
    }

    if (mask === void 0) {
      mask = defaultMask;
    }

    const
      langOpts = dateLocale !== void 0 ? dateLocale : Plugin$7.props.date,
      months = langOpts.months,
      monthsShort = langOpts.monthsShort;

    const { regex, map } = getRegexData(mask, langOpts);

    const match = str.match(regex);

    if (match === null) {
      return date
    }

    let tzString = '';

    if (map.X !== void 0 || map.x !== void 0) {
      const stamp = parseInt(match[ map.X !== void 0 ? map.X : map.x ], 10);

      if (isNaN(stamp) === true || stamp < 0) {
        return date
      }

      const d = new Date(stamp * (map.X !== void 0 ? 1000 : 1));

      date.year = d.getFullYear();
      date.month = d.getMonth() + 1;
      date.day = d.getDate();
      date.hour = d.getHours();
      date.minute = d.getMinutes();
      date.second = d.getSeconds();
      date.millisecond = d.getMilliseconds();
    }
    else {
      if (map.YYYY !== void 0) {
        date.year = parseInt(match[ map.YYYY ], 10);
      }
      else if (map.YY !== void 0) {
        const y = parseInt(match[ map.YY ], 10);
        date.year = y < 0 ? y : 2000 + y;
      }

      if (map.M !== void 0) {
        date.month = parseInt(match[ map.M ], 10);
        if (date.month < 1 || date.month > 12) {
          return date
        }
      }
      else if (map.MMM !== void 0) {
        date.month = monthsShort.indexOf(match[ map.MMM ]) + 1;
      }
      else if (map.MMMM !== void 0) {
        date.month = months.indexOf(match[ map.MMMM ]) + 1;
      }

      if (map.D !== void 0) {
        date.day = parseInt(match[ map.D ], 10);

        if (date.year === null || date.month === null || date.day < 1) {
          return date
        }

        const maxDay = calendar !== 'persian'
          ? (new Date(date.year, date.month, 0)).getDate()
          : jalaaliMonthLength(date.year, date.month);

        if (date.day > maxDay) {
          return date
        }
      }

      if (map.H !== void 0) {
        date.hour = parseInt(match[ map.H ], 10) % 24;
      }
      else if (map.h !== void 0) {
        date.hour = parseInt(match[ map.h ], 10) % 12;
        if (
          (map.A && match[ map.A ] === 'PM')
          || (map.a && match[ map.a ] === 'pm')
          || (map.aa && match[ map.aa ] === 'p.m.')
        ) {
          date.hour += 12;
        }
        date.hour = date.hour % 24;
      }

      if (map.m !== void 0) {
        date.minute = parseInt(match[ map.m ], 10) % 60;
      }

      if (map.s !== void 0) {
        date.second = parseInt(match[ map.s ], 10) % 60;
      }

      if (map.S !== void 0) {
        date.millisecond = parseInt(match[ map.S ], 10) * 10 ** (3 - match[ map.S ].length);
      }

      if (map.Z !== void 0 || map.ZZ !== void 0) {
        tzString = (map.Z !== void 0 ? match[ map.Z ].replace(':', '') : match[ map.ZZ ]);
        date.timezoneOffset = (tzString[ 0 ] === '+' ? -1 : 1) * (60 * tzString.slice(1, 3) + 1 * tzString.slice(3, 5));
      }
    }

    date.dateHash = date.year + '/' + pad(date.month) + '/' + pad(date.day);
    date.timeHash = pad(date.hour) + ':' + pad(date.minute) + ':' + pad(date.second) + tzString;

    return date
  }

  function formatTimezone (offset, delimeter = '') {
    const
      sign = offset > 0 ? '-' : '+',
      absOffset = Math.abs(offset),
      hours = Math.floor(absOffset / 60),
      minutes = absOffset % 60;

    return sign + pad(hours) + delimeter + pad(minutes)
  }

  function setMonth (date, newMonth /* 1-based */) {
    const
      test = new Date(date.getFullYear(), newMonth, 0, 0, 0, 0, 0),
      days = test.getDate();

    date.setMonth(newMonth - 1, Math.min(days, date.getDate()));
  }

  function getChange (date, mod, add) {
    const
      t = new Date(date),
      sign = (add ? 1 : -1);

    Object.keys(mod).forEach(key => {
      if (key === 'months') {
        setMonth(t, t.getMonth() + 1 + sign * mod.months);
        return
      }

      const op = key === 'years'
        ? 'FullYear'
        : capitalize(key === 'days' ? 'date' : key);
      t[ `set${ op }` ](t[ `get${ op }` ]() + sign * mod[ key ]);
    });
    return t
  }

  function isValid (date) {
    return typeof date === 'number'
      ? true
      : isNaN(Date.parse(date)) === false
  }

  function buildDate (mod, utc) {
    return adjustDate(new Date(), mod, utc)
  }

  function getDayOfWeek (date) {
    const dow = new Date(date).getDay();
    return dow === 0 ? 7 : dow
  }

  function getWeekOfYear (date) {
    // Remove time components of date
    const thursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());

    // Change date to Thursday same week
    thursday.setDate(thursday.getDate() - ((thursday.getDay() + 6) % 7) + 3);

    // Take January 4th as it is always in week 1 (see ISO 8601)
    const firstThursday = new Date(thursday.getFullYear(), 0, 4);

    // Change date to Thursday same week
    firstThursday.setDate(firstThursday.getDate() - ((firstThursday.getDay() + 6) % 7) + 3);

    // Check if daylight-saving-time-switch occurred and correct for it
    const ds = thursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
    thursday.setHours(thursday.getHours() - ds);

    // Number of weeks between target Thursday and first Thursday
    const weekDiff = (thursday - firstThursday) / (MILLISECONDS_IN_DAY * 7);
    return 1 + Math.floor(weekDiff)
  }

  function getDayIdentifier (date) {
    return date.getFullYear() * 10000 + date.getMonth() * 100 + date.getDate()
  }

  function getDateIdentifier (date, onlyDate /* = false */) {
    const d = new Date(date);
    return onlyDate === true ? getDayIdentifier(d) : d.getTime()
  }

  function isBetweenDates (date, from, to, opts = {}) {
    const
      d1 = getDateIdentifier(from, opts.onlyDate),
      d2 = getDateIdentifier(to, opts.onlyDate),
      cur = getDateIdentifier(date, opts.onlyDate);

    return (cur > d1 || (opts.inclusiveFrom === true && cur === d1))
      && (cur < d2 || (opts.inclusiveTo === true && cur === d2))
  }

  function addToDate (date, mod) {
    return getChange(date, mod, true)
  }
  function subtractFromDate (date, mod) {
    return getChange(date, mod, false)
  }

  function adjustDate (date, mod, utc) {
    const
      t = new Date(date),
      prefix = `set${ utc === true ? 'UTC' : '' }`;

    Object.keys(mod).forEach(key => {
      if (key === 'month') {
        setMonth(t, mod.month);
        return
      }

      const op = key === 'year'
        ? 'FullYear'
        : key.charAt(0).toUpperCase() + key.slice(1);
      t[ `${ prefix }${ op }` ](mod[ key ]);
    });

    return t
  }

  function startOfDate (date, unit, utc) {
    const
      t = new Date(date),
      prefix = `set${ utc === true ? 'UTC' : '' }`;

    switch (unit) {
      case 'year':
        t[ `${ prefix }Month` ](0);
      case 'month':
        t[ `${ prefix }Date` ](1);
      case 'day':
        t[ `${ prefix }Hours` ](0);
      case 'hour':
        t[ `${ prefix }Minutes` ](0);
      case 'minute':
        t[ `${ prefix }Seconds` ](0);
      case 'second':
        t[ `${ prefix }Milliseconds` ](0);
    }
    return t
  }

  function endOfDate (date, unit, utc) {
    const
      t = new Date(date),
      prefix = `set${ utc === true ? 'UTC' : '' }`;

    switch (unit) {
      case 'year':
        t[ `${ prefix }Month` ](11);
      case 'month':
        t[ `${ prefix }Date` ](daysInMonth(t));
      case 'day':
        t[ `${ prefix }Hours` ](23);
      case 'hour':
        t[ `${ prefix }Minutes` ](59);
      case 'minute':
        t[ `${ prefix }Seconds` ](59);
      case 'second':
        t[ `${ prefix }Milliseconds` ](999);
    }
    return t
  }

  function getMaxDate (date /* , ...args */) {
    let t = new Date(date);
    Array.prototype.slice.call(arguments, 1).forEach(d => {
      t = Math.max(t, new Date(d));
    });
    return t
  }

  function getMinDate (date /*, ...args */) {
    let t = new Date(date);
    Array.prototype.slice.call(arguments, 1).forEach(d => {
      t = Math.min(t, new Date(d));
    });
    return t
  }

  function getDiff (t, sub, interval) {
    return (
      (t.getTime() - t.getTimezoneOffset() * MILLISECONDS_IN_MINUTE)
      - (sub.getTime() - sub.getTimezoneOffset() * MILLISECONDS_IN_MINUTE)
    ) / interval
  }

  function getDateDiff (date, subtract, unit = 'days') {
    const
      t = new Date(date),
      sub = new Date(subtract);

    switch (unit) {
      case 'years':
        return (t.getFullYear() - sub.getFullYear())

      case 'months':
        return (t.getFullYear() - sub.getFullYear()) * 12 + t.getMonth() - sub.getMonth()

      case 'days':
        return getDiff(startOfDate(t, 'day'), startOfDate(sub, 'day'), MILLISECONDS_IN_DAY)

      case 'hours':
        return getDiff(startOfDate(t, 'hour'), startOfDate(sub, 'hour'), MILLISECONDS_IN_HOUR)

      case 'minutes':
        return getDiff(startOfDate(t, 'minute'), startOfDate(sub, 'minute'), MILLISECONDS_IN_MINUTE)

      case 'seconds':
        return getDiff(startOfDate(t, 'second'), startOfDate(sub, 'second'), 1000)
    }
  }

  function getDayOfYear (date) {
    return getDateDiff(date, startOfDate(date, 'year'), 'days') + 1
  }

  function inferDateFormat (date) {
    return isDate(date) === true
      ? 'date'
      : (typeof date === 'number' ? 'number' : 'string')
  }

  function getDateBetween (date, min, max) {
    const t = new Date(date);

    if (min) {
      const low = new Date(min);
      if (t < low) {
        return low
      }
    }

    if (max) {
      const high = new Date(max);
      if (t > high) {
        return high
      }
    }

    return t
  }

  function isSameDate (date, date2, unit) {
    const
      t = new Date(date),
      d = new Date(date2);

    if (unit === void 0) {
      return t.getTime() === d.getTime()
    }

    switch (unit) {
      case 'second':
        if (t.getSeconds() !== d.getSeconds()) {
          return false
        }
      case 'minute': // intentional fall-through
        if (t.getMinutes() !== d.getMinutes()) {
          return false
        }
      case 'hour': // intentional fall-through
        if (t.getHours() !== d.getHours()) {
          return false
        }
      case 'day': // intentional fall-through
        if (t.getDate() !== d.getDate()) {
          return false
        }
      case 'month': // intentional fall-through
        if (t.getMonth() !== d.getMonth()) {
          return false
        }
      case 'year': // intentional fall-through
        if (t.getFullYear() !== d.getFullYear()) {
          return false
        }
        break
      default:
        throw new Error(`date isSameDate unknown unit ${ unit }`)
    }

    return true
  }

  function daysInMonth (date) {
    return (new Date(date.getFullYear(), date.getMonth() + 1, 0)).getDate()
  }

  function getOrdinal (n) {
    if (n >= 11 && n <= 13) {
      return `${ n }th`
    }
    switch (n % 10) {
      case 1: return `${ n }st`
      case 2: return `${ n }nd`
      case 3: return `${ n }rd`
    }
    return `${ n }th`
  }

  const formatter = {
    // Year: 00, 01, ..., 99
    YY (date, _, forcedYear) {
      // workaround for < 1900 with new Date()
      const y = this.YYYY(date, _, forcedYear) % 100;
      return y > 0
        ? pad(y)
        : '-' + pad(Math.abs(y))
    },

    // Year: 1900, 1901, ..., 2099
    YYYY (date, _, forcedYear) {
      // workaround for < 1900 with new Date()
      return forcedYear !== void 0 && forcedYear !== null
        ? forcedYear
        : date.getFullYear()
    },

    // Month: 1, 2, ..., 12
    M (date) {
      return date.getMonth() + 1
    },

    // Month: 01, 02, ..., 12
    MM (date) {
      return pad(date.getMonth() + 1)
    },

    // Month Short Name: Jan, Feb, ...
    MMM (date, dateLocale) {
      return dateLocale.monthsShort[ date.getMonth() ]
    },

    // Month Name: January, February, ...
    MMMM (date, dateLocale) {
      return dateLocale.months[ date.getMonth() ]
    },

    // Quarter: 1, 2, 3, 4
    Q (date) {
      return Math.ceil((date.getMonth() + 1) / 3)
    },

    // Quarter: 1st, 2nd, 3rd, 4th
    Qo (date) {
      return getOrdinal(this.Q(date))
    },

    // Day of month: 1, 2, ..., 31
    D (date) {
      return date.getDate()
    },

    // Day of month: 1st, 2nd, ..., 31st
    Do (date) {
      return getOrdinal(date.getDate())
    },

    // Day of month: 01, 02, ..., 31
    DD (date) {
      return pad(date.getDate())
    },

    // Day of year: 1, 2, ..., 366
    DDD (date) {
      return getDayOfYear(date)
    },

    // Day of year: 001, 002, ..., 366
    DDDD (date) {
      return pad(getDayOfYear(date), 3)
    },

    // Day of week: 0, 1, ..., 6
    d (date) {
      return date.getDay()
    },

    // Day of week: Su, Mo, ...
    dd (date, dateLocale) {
      return this.dddd(date, dateLocale).slice(0, 2)
    },

    // Day of week: Sun, Mon, ...
    ddd (date, dateLocale) {
      return dateLocale.daysShort[ date.getDay() ]
    },

    // Day of week: Sunday, Monday, ...
    dddd (date, dateLocale) {
      return dateLocale.days[ date.getDay() ]
    },

    // Day of ISO week: 1, 2, ..., 7
    E (date) {
      return date.getDay() || 7
    },

    // Week of Year: 1 2 ... 52 53
    w (date) {
      return getWeekOfYear(date)
    },

    // Week of Year: 01 02 ... 52 53
    ww (date) {
      return pad(getWeekOfYear(date))
    },

    // Hour: 0, 1, ... 23
    H (date) {
      return date.getHours()
    },

    // Hour: 00, 01, ..., 23
    HH (date) {
      return pad(date.getHours())
    },

    // Hour: 1, 2, ..., 12
    h (date) {
      const hours = date.getHours();
      if (hours === 0) {
        return 12
      }
      if (hours > 12) {
        return hours % 12
      }
      return hours
    },

    // Hour: 01, 02, ..., 12
    hh (date) {
      return pad(this.h(date))
    },

    // Minute: 0, 1, ..., 59
    m (date) {
      return date.getMinutes()
    },

    // Minute: 00, 01, ..., 59
    mm (date) {
      return pad(date.getMinutes())
    },

    // Second: 0, 1, ..., 59
    s (date) {
      return date.getSeconds()
    },

    // Second: 00, 01, ..., 59
    ss (date) {
      return pad(date.getSeconds())
    },

    // 1/10 of second: 0, 1, ..., 9
    S (date) {
      return Math.floor(date.getMilliseconds() / 100)
    },

    // 1/100 of second: 00, 01, ..., 99
    SS (date) {
      return pad(Math.floor(date.getMilliseconds() / 10))
    },

    // Millisecond: 000, 001, ..., 999
    SSS (date) {
      return pad(date.getMilliseconds(), 3)
    },

    // Meridiem: AM, PM
    A (date) {
      return this.H(date) < 12 ? 'AM' : 'PM'
    },

    // Meridiem: am, pm
    a (date) {
      return this.H(date) < 12 ? 'am' : 'pm'
    },

    // Meridiem: a.m., p.m.
    aa (date) {
      return this.H(date) < 12 ? 'a.m.' : 'p.m.'
    },

    // Timezone: -01:00, +00:00, ... +12:00
    Z (date, dateLocale, forcedYear, forcedTimezoneOffset) {
      const tzOffset = forcedTimezoneOffset === void 0 || forcedTimezoneOffset === null
        ? date.getTimezoneOffset()
        : forcedTimezoneOffset;

      return formatTimezone(tzOffset, ':')
    },

    // Timezone: -0100, +0000, ... +1200
    ZZ (date, dateLocale, forcedYear, forcedTimezoneOffset) {
      const tzOffset = forcedTimezoneOffset === void 0 || forcedTimezoneOffset === null
        ? date.getTimezoneOffset()
        : forcedTimezoneOffset;

      return formatTimezone(tzOffset)
    },

    // Seconds timestamp: 512969520
    X (date) {
      return Math.floor(date.getTime() / 1000)
    },

    // Milliseconds timestamp: 512969520900
    x (date) {
      return date.getTime()
    }
  };

  function formatDate (val, mask, dateLocale, __forcedYear, __forcedTimezoneOffset) {
    if (
      (val !== 0 && !val)
      || val === Infinity
      || val === -Infinity
    ) {
      return
    }

    const date = new Date(val);

    if (isNaN(date)) {
      return
    }

    if (mask === void 0) {
      mask = defaultMask;
    }

    const locale = dateLocale !== void 0
      ? dateLocale
      : Plugin$7.props.date;

    return mask.replace(
      token,
      (match, text) => (
        match in formatter
          ? formatter[ match ](date, locale, __forcedYear, __forcedTimezoneOffset)
          : (text === void 0 ? match : text.split('\\]').join(']'))
      )
    )
  }

  function clone$1 (date) {
    return isDate(date) === true
      ? new Date(date.getTime())
      : date
  }

  var date = {
    isValid,
    extractDate,
    buildDate,
    getDayOfWeek,
    getWeekOfYear,
    isBetweenDates,
    addToDate,
    subtractFromDate,
    adjustDate,
    startOfDate,
    endOfDate,
    getMaxDate,
    getMinDate,
    getDateDiff,
    getDayOfYear,
    inferDateFormat,
    getDateBetween,
    isSameDate,
    daysInMonth,
    formatDate,
    clone: clone$1
  };

  const yearsInterval = 20;
  const views = [ 'Calendar', 'Years', 'Months' ];
  const viewIsValid = v => views.includes(v);
  const yearMonthValidator = v => /^-?[\d]+\/[0-1]\d$/.test(v);
  const lineStr = ' \u2014 ';

  function getMonthHash (date) {
    return date.year + '/' + pad(date.month)
  }

  var QDate = vue.defineComponent({
    name: 'QDate',

    props: {
      ...useDatetimeProps,
      ...useFormProps,
      ...useDarkProps,

      multiple: Boolean,
      range: Boolean,

      title: String,
      subtitle: String,

      mask: {
        // this mask is forced
        // when using persian calendar
        default: 'YYYY/MM/DD'
      },

      defaultYearMonth: {
        type: String,
        validator: yearMonthValidator
      },

      yearsInMonthView: Boolean,

      events: [ Array, Function ],
      eventColor: [ String, Function ],

      emitImmediately: Boolean,

      options: [ Array, Function ],

      navigationMinYearMonth: {
        type: String,
        validator: yearMonthValidator
      },

      navigationMaxYearMonth: {
        type: String,
        validator: yearMonthValidator
      },

      noUnset: Boolean,

      firstDayOfWeek: [ String, Number ],
      todayBtn: Boolean,
      minimal: Boolean,
      defaultView: {
        type: String,
        default: 'Calendar',
        validator: viewIsValid
      }
    },

    emits: [
      ...useDatetimeEmits,
      'range-start', 'range-end', 'navigation'
    ],

    setup (props, { slots, emit }) {
      const { proxy } = vue.getCurrentInstance();
      const { $q } = proxy;

      const isDark = useDark(props, $q);
      const { getCache } = useCache();
      const { tabindex, headerClass, getLocale, getCurrentDate } = useDatetime(props, $q);

      let lastEmitValue;

      const formAttrs = useFormAttrs(props);
      const injectFormInput = useFormInject(formAttrs);

      const blurTargetRef = vue.ref(null);
      const innerMask = vue.ref(getMask());
      const innerLocale = vue.ref(getLocale());

      const mask = vue.computed(() => getMask());
      const locale = vue.computed(() => getLocale());

      const today = vue.computed(() => getCurrentDate());

      // model of current calendar view:
      const viewModel = vue.ref(getViewModel(innerMask.value, innerLocale.value));

      const view = vue.ref(props.defaultView);

      const direction = $q.lang.rtl === true ? 'right' : 'left';
      const monthDirection = vue.ref(direction.value);
      const yearDirection = vue.ref(direction.value);

      const year = viewModel.value.year;
      const startYear = vue.ref(year - (year % yearsInterval) - (year < 0 ? yearsInterval : 0));
      const editRange = vue.ref(null);

      const classes = vue.computed(() => {
        const type = props.landscape === true ? 'landscape' : 'portrait';
        return `q-date q-date--${ type } q-date--${ type }-${ props.minimal === true ? 'minimal' : 'standard' }`
          + (isDark.value === true ? ' q-date--dark q-dark' : '')
          + (props.bordered === true ? ' q-date--bordered' : '')
          + (props.square === true ? ' q-date--square no-border-radius' : '')
          + (props.flat === true ? ' q-date--flat no-shadow' : '')
          + (props.disable === true ? ' disabled' : (props.readonly === true ? ' q-date--readonly' : ''))
      });

      const computedColor = vue.computed(() => {
        return props.color || 'primary'
      });

      const computedTextColor = vue.computed(() => {
        return props.textColor || 'white'
      });

      const isImmediate = vue.computed(() =>
        props.emitImmediately === true
        && props.multiple !== true
        && props.range !== true
      );

      const normalizedModel = vue.computed(() => (
        Array.isArray(props.modelValue) === true
          ? props.modelValue
          : (props.modelValue !== null && props.modelValue !== void 0 ? [ props.modelValue ] : [])
      ));

      const daysModel = vue.computed(() =>
        normalizedModel.value
          .filter(date => typeof date === 'string')
          .map(date => decodeString(date, innerMask.value, innerLocale.value))
          .filter(date => date.dateHash !== null)
      );

      const rangeModel = vue.computed(() => {
        const fn = date => decodeString(date, innerMask.value, innerLocale.value);
        return normalizedModel.value
          .filter(date => Object(date) === date && date.from !== void 0 && date.to !== void 0)
          .map(range => ({ from: fn(range.from), to: fn(range.to) }))
          .filter(range => range.from.dateHash !== null && range.to.dateHash !== null && range.from.dateHash < range.to.dateHash)
      });

      const getNativeDateFn = vue.computed(() => (
        props.calendar !== 'persian'
          ? model => new Date(model.year, model.month - 1, model.day)
          : model => {
            const gDate = toGregorian(model.year, model.month, model.day);
            return new Date(gDate.gy, gDate.gm - 1, gDate.gd)
          }
      ));

      const encodeObjectFn = vue.computed(() => (
        props.calendar === 'persian'
          ? getDayHash
          : (date, mask, locale) => formatDate(
              new Date(
                date.year,
                date.month - 1,
                date.day,
                date.hour,
                date.minute,
                date.second,
                date.millisecond
              ),
              mask === void 0 ? innerMask.value : mask,
              locale === void 0 ? innerLocale.value : locale,
              date.year,
              date.timezoneOffset
            )
      ));

      const daysInModel = vue.computed(() =>
        daysModel.value.length + rangeModel.value.reduce(
          (acc, range) => acc + 1 + getDateDiff(
            getNativeDateFn.value(range.to),
            getNativeDateFn.value(range.from)
          ),
          0
        )
      );

      const headerTitle = vue.computed(() => {
        if (props.title !== void 0 && props.title !== null && props.title.length > 0) {
          return props.title
        }

        if (editRange.value !== null) {
          const model = editRange.value.init;
          const date = getNativeDateFn.value(model);

          return innerLocale.value.daysShort[ date.getDay() ] + ', '
            + innerLocale.value.monthsShort[ model.month - 1 ] + ' '
            + model.day + lineStr + '?'
        }

        if (daysInModel.value === 0) {
          return lineStr
        }

        if (daysInModel.value > 1) {
          return `${ daysInModel.value } ${ innerLocale.value.pluralDay }`
        }

        const model = daysModel.value[ 0 ];
        const date = getNativeDateFn.value(model);

        if (isNaN(date.valueOf()) === true) {
          return lineStr
        }

        if (innerLocale.value.headerTitle !== void 0) {
          return innerLocale.value.headerTitle(date, model)
        }

        return innerLocale.value.daysShort[ date.getDay() ] + ', '
          + innerLocale.value.monthsShort[ model.month - 1 ] + ' '
          + model.day
      });

      const minSelectedModel = vue.computed(() => {
        const model = daysModel.value.concat(rangeModel.value.map(range => range.from))
          .sort((a, b) => a.year - b.year || a.month - b.month);

        return model[ 0 ]
      });

      const maxSelectedModel = vue.computed(() => {
        const model = daysModel.value.concat(rangeModel.value.map(range => range.to))
          .sort((a, b) => b.year - a.year || b.month - a.month);

        return model[ 0 ]
      });

      const headerSubtitle = vue.computed(() => {
        if (props.subtitle !== void 0 && props.subtitle !== null && props.subtitle.length > 0) {
          return props.subtitle
        }

        if (daysInModel.value === 0) {
          return lineStr
        }

        if (daysInModel.value > 1) {
          const from = minSelectedModel.value;
          const to = maxSelectedModel.value;
          const month = innerLocale.value.monthsShort;

          return month[ from.month - 1 ] + (
            from.year !== to.year
              ? ' ' + from.year + lineStr + month[ to.month - 1 ] + ' '
              : (
                  from.month !== to.month
                    ? lineStr + month[ to.month - 1 ]
                    : ''
                )
          ) + ' ' + to.year
        }

        return daysModel.value[ 0 ].year
      });

      const dateArrow = vue.computed(() => {
        const val = [ $q.iconSet.datetime.arrowLeft, $q.iconSet.datetime.arrowRight ];
        return $q.lang.rtl === true ? val.reverse() : val
      });

      const computedFirstDayOfWeek = vue.computed(() => (
        props.firstDayOfWeek !== void 0
          ? Number(props.firstDayOfWeek)
          : innerLocale.value.firstDayOfWeek
      ));

      const daysOfWeek = vue.computed(() => {
        const
          days = innerLocale.value.daysShort,
          first = computedFirstDayOfWeek.value;

        return first > 0
          ? days.slice(first, 7).concat(days.slice(0, first))
          : days
      });

      const daysInMonth = vue.computed(() => {
        const date = viewModel.value;
        return props.calendar !== 'persian'
          ? (new Date(date.year, date.month, 0)).getDate()
          : jalaaliMonthLength(date.year, date.month)
      });

      const evtColor = vue.computed(() => (
        typeof props.eventColor === 'function'
          ? props.eventColor
          : () => props.eventColor
      ));

      const minNav = vue.computed(() => {
        if (props.navigationMinYearMonth === void 0) {
          return null
        }

        const data = props.navigationMinYearMonth.split('/');
        return { year: parseInt(data[ 0 ], 10), month: parseInt(data[ 1 ], 10) }
      });

      const maxNav = vue.computed(() => {
        if (props.navigationMaxYearMonth === void 0) {
          return null
        }

        const data = props.navigationMaxYearMonth.split('/');
        return { year: parseInt(data[ 0 ], 10), month: parseInt(data[ 1 ], 10) }
      });

      const navBoundaries = vue.computed(() => {
        const data = {
          month: { prev: true, next: true },
          year: { prev: true, next: true }
        };

        if (minNav.value !== null && minNav.value.year >= viewModel.value.year) {
          data.year.prev = false;
          if (minNav.value.year === viewModel.value.year && minNav.value.month >= viewModel.value.month) {
            data.month.prev = false;
          }
        }

        if (maxNav.value !== null && maxNav.value.year <= viewModel.value.year) {
          data.year.next = false;
          if (maxNav.value.year === viewModel.value.year && maxNav.value.month <= viewModel.value.month) {
            data.month.next = false;
          }
        }

        return data
      });

      const daysMap = vue.computed(() => {
        const map = {};

        daysModel.value.forEach(entry => {
          const hash = getMonthHash(entry);

          if (map[ hash ] === void 0) {
            map[ hash ] = [];
          }

          map[ hash ].push(entry.day);
        });

        return map
      });

      const rangeMap = vue.computed(() => {
        const map = {};

        rangeModel.value.forEach(entry => {
          const hashFrom = getMonthHash(entry.from);
          const hashTo = getMonthHash(entry.to);

          if (map[ hashFrom ] === void 0) {
            map[ hashFrom ] = [];
          }

          map[ hashFrom ].push({
            from: entry.from.day,
            to: hashFrom === hashTo ? entry.to.day : void 0,
            range: entry
          });

          if (hashFrom < hashTo) {
            let hash;
            const { year, month } = entry.from;
            const cur = month < 12
              ? { year, month: month + 1 }
              : { year: year + 1, month: 1 };

            while ((hash = getMonthHash(cur)) <= hashTo) {
              if (map[ hash ] === void 0) {
                map[ hash ] = [];
              }

              map[ hash ].push({
                from: void 0,
                to: hash === hashTo ? entry.to.day : void 0,
                range: entry
              });

              cur.month++;
              if (cur.month > 12) {
                cur.year++;
                cur.month = 1;
              }
            }
          }
        });

        return map
      });

      const rangeView = vue.computed(() => {
        if (editRange.value === null) {
          return
        }

        const { init, initHash, final, finalHash } = editRange.value;

        const [ from, to ] = initHash <= finalHash
          ? [ init, final ]
          : [ final, init ];

        const fromHash = getMonthHash(from);
        const toHash = getMonthHash(to);

        if (fromHash !== viewMonthHash.value && toHash !== viewMonthHash.value) {
          return
        }

        const view = {};

        if (fromHash === viewMonthHash.value) {
          view.from = from.day;
          view.includeFrom = true;
        }
        else {
          view.from = 1;
        }

        if (toHash === viewMonthHash.value) {
          view.to = to.day;
          view.includeTo = true;
        }
        else {
          view.to = daysInMonth.value;
        }

        return view
      });

      const viewMonthHash = vue.computed(() => getMonthHash(viewModel.value));

      const selectionDaysMap = vue.computed(() => {
        const map = {};

        if (props.options === void 0) {
          for (let i = 1; i <= daysInMonth.value; i++) {
            map[ i ] = true;
          }

          return map
        }

        const fn = typeof props.options === 'function'
          ? props.options
          : date => props.options.includes(date);

        for (let i = 1; i <= daysInMonth.value; i++) {
          const dayHash = viewMonthHash.value + '/' + pad(i);
          map[ i ] = fn(dayHash);
        }

        return map
      });

      const eventDaysMap = vue.computed(() => {
        const map = {};

        if (props.events === void 0) {
          for (let i = 1; i <= daysInMonth.value; i++) {
            map[ i ] = false;
          }
        }
        else {
          const fn = typeof props.events === 'function'
            ? props.events
            : date => props.events.includes(date);

          for (let i = 1; i <= daysInMonth.value; i++) {
            const dayHash = viewMonthHash.value + '/' + pad(i);
            map[ i ] = fn(dayHash) === true && evtColor.value(dayHash);
          }
        }

        return map
      });

      const viewDays = vue.computed(() => {
        let date, endDay;
        const { year, month } = viewModel.value;

        if (props.calendar !== 'persian') {
          date = new Date(year, month - 1, 1);
          endDay = (new Date(year, month - 1, 0)).getDate();
        }
        else {
          const gDate = toGregorian(year, month, 1);
          date = new Date(gDate.gy, gDate.gm - 1, gDate.gd);
          let prevJM = month - 1;
          let prevJY = year;
          if (prevJM === 0) {
            prevJM = 12;
            prevJY--;
          }
          endDay = jalaaliMonthLength(prevJY, prevJM);
        }

        return {
          days: date.getDay() - computedFirstDayOfWeek.value - 1,
          endDay
        }
      });

      const days = vue.computed(() => {
        const res = [];
        const { days, endDay } = viewDays.value;

        const len = days < 0 ? days + 7 : days;
        if (len < 6) {
          for (let i = endDay - len; i <= endDay; i++) {
            res.push({ i, fill: true });
          }
        }

        const index = res.length;

        for (let i = 1; i <= daysInMonth.value; i++) {
          const day = { i, event: eventDaysMap.value[ i ], classes: [] };

          if (selectionDaysMap.value[ i ] === true) {
            day.in = true;
            day.flat = true;
          }

          res.push(day);
        }

        // if current view has days in model
        if (daysMap.value[ viewMonthHash.value ] !== void 0) {
          daysMap.value[ viewMonthHash.value ].forEach(day => {
            const i = index + day - 1;
            Object.assign(res[ i ], {
              selected: true,
              unelevated: true,
              flat: false,
              color: computedColor.value,
              textColor: computedTextColor.value
            });
          });
        }

        // if current view has ranges in model
        if (rangeMap.value[ viewMonthHash.value ] !== void 0) {
          rangeMap.value[ viewMonthHash.value ].forEach(entry => {
            if (entry.from !== void 0) {
              const from = index + entry.from - 1;
              const to = index + (entry.to || daysInMonth.value) - 1;

              for (let day = from; day <= to; day++) {
                Object.assign(res[ day ], {
                  range: entry.range,
                  unelevated: true,
                  color: computedColor.value,
                  textColor: computedTextColor.value
                });
              }

              Object.assign(res[ from ], {
                rangeFrom: true,
                flat: false
              });

              entry.to !== void 0 && Object.assign(res[ to ], {
                rangeTo: true,
                flat: false
              });
            }
            else if (entry.to !== void 0) {
              const to = index + entry.to - 1;

              for (let day = index; day <= to; day++) {
                Object.assign(res[ day ], {
                  range: entry.range,
                  unelevated: true,
                  color: computedColor.value,
                  textColor: computedTextColor.value
                });
              }

              Object.assign(res[ to ], {
                flat: false,
                rangeTo: true
              });
            }
            else {
              const to = index + daysInMonth.value - 1;
              for (let day = index; day <= to; day++) {
                Object.assign(res[ day ], {
                  range: entry.range,
                  unelevated: true,
                  color: computedColor.value,
                  textColor: computedTextColor.value
                });
              }
            }
          });
        }

        if (rangeView.value !== void 0) {
          const from = index + rangeView.value.from - 1;
          const to = index + rangeView.value.to - 1;

          for (let day = from; day <= to; day++) {
            res[ day ].color = computedColor.value;
            res[ day ].editRange = true;
          }

          if (rangeView.value.includeFrom === true) {
            res[ from ].editRangeFrom = true;
          }
          if (rangeView.value.includeTo === true) {
            res[ to ].editRangeTo = true;
          }
        }

        if (viewModel.value.year === today.value.year && viewModel.value.month === today.value.month) {
          res[ index + today.value.day - 1 ].today = true;
        }

        const left = res.length % 7;
        if (left > 0) {
          const afterDays = 7 - left;
          for (let i = 1; i <= afterDays; i++) {
            res.push({ i, fill: true });
          }
        }

        res.forEach(day => {
          let cls = 'q-date__calendar-item ';

          if (day.fill === true) {
            cls += 'q-date__calendar-item--fill';
          }
          else {
            cls += `q-date__calendar-item--${ day.in === true ? 'in' : 'out' }`;

            if (day.range !== void 0) {
              cls += ` q-date__range${ day.rangeTo === true ? '-to' : (day.rangeFrom === true ? '-from' : '') }`;
            }

            if (day.editRange === true) {
              cls += ` q-date__edit-range${ day.editRangeFrom === true ? '-from' : '' }${ day.editRangeTo === true ? '-to' : '' }`;
            }

            if (day.range !== void 0 || day.editRange === true) {
              cls += ` text-${ day.color }`;
            }
          }

          day.classes = cls;
        });

        return res
      });

      const attributes = vue.computed(() => (
        props.disable === true
          ? { 'aria-disabled': 'true' }
          : (props.readonly === true ? { 'aria-readonly': 'true' } : {})
      ));

      vue.watch(() => props.modelValue, v => {
        if (lastEmitValue === v) {
          lastEmitValue = 0;
        }
        else {
          const { year, month } = getViewModel(innerMask.value, innerLocale.value);
          updateViewModel(year, month);
        }
      });

      vue.watch(view, () => {
        blurTargetRef.value !== null && blurTargetRef.value.focus();
      });

      vue.watch(() => viewModel.value.year, year => {
        emit('navigation', { year, month: viewModel.value.month });
      });

      vue.watch(() => viewModel.value.month, month => {
        emit('navigation', { year: viewModel.value.year, month });
      });

      vue.watch(mask, val => {
        updateValue(val, innerLocale.value, 'mask');
        innerMask.value = val;
      });

      vue.watch(locale, val => {
        updateValue(innerMask.value, val, 'locale');
        innerLocale.value = val;
      });

      function setToday () {
        toggleDate(today.value, getMonthHash(today.value));
        setCalendarTo(today.value.year, today.value.month);
      }

      function setView (viewMode) {
        if (viewIsValid(viewMode) === true) {
          view.value = viewMode;
        }
      }

      function offsetCalendar (type, descending) {
        if ([ 'month', 'year' ].includes(type)) {
          const fn = type === 'month' ? goToMonth : goToYear;
          fn(descending === true ? -1 : 1);
        }
      }

      function setCalendarTo (year, month) {
        view.value = 'Calendar';
        updateViewModel(year, month);
      }

      function setEditingRange (from, to) {
        if (props.range === false || !from) {
          editRange.value = null;
          return
        }

        const init = Object.assign({ ...viewModel.value }, from);
        const final = to !== void 0
          ? Object.assign({ ...viewModel.value }, to)
          : init;

        editRange.value = {
          init,
          initHash: getDayHash(init),
          final,
          finalHash: getDayHash(final)
        };

        setCalendarTo(init.year, init.month);
      }

      function getMask () {
        return props.calendar === 'persian' ? 'YYYY/MM/DD' : props.mask
      }

      function decodeString (date, mask, locale) {
        return __splitDate(
          date,
          mask,
          locale,
          props.calendar,
          {
            hour: 0,
            minute: 0,
            second: 0,
            millisecond: 0
          }
        )
      }

      function getViewModel (mask, locale) {
        const model = Array.isArray(props.modelValue) === true
          ? props.modelValue
          : (props.modelValue ? [ props.modelValue ] : []);

        if (model.length === 0) {
          return getDefaultViewModel()
        }

        const decoded = decodeString(
          model[ 0 ].from !== void 0 ? model[ 0 ].from : model[ 0 ],
          mask,
          locale
        );

        return decoded.dateHash === null
          ? getDefaultViewModel()
          : decoded
      }

      function getDefaultViewModel () {
        let year, month;

        if (props.defaultYearMonth !== void 0) {
          const d = props.defaultYearMonth.split('/');
          year = parseInt(d[ 0 ], 10);
          month = parseInt(d[ 1 ], 10);
        }
        else {
          // may come from data() where computed
          // props are not yet available
          const d = today.value !== void 0
            ? today.value
            : getCurrentDate();

          year = d.year;
          month = d.month;
        }

        return {
          year,
          month,
          day: 1,
          hour: 0,
          minute: 0,
          second: 0,
          millisecond: 0,
          dateHash: year + '/' + pad(month) + '/01'
        }
      }

      function goToMonth (offset) {
        let year = viewModel.value.year;
        let month = Number(viewModel.value.month) + offset;

        if (month === 13) {
          month = 1;
          year++;
        }
        else if (month === 0) {
          month = 12;
          year--;
        }

        updateViewModel(year, month);
        isImmediate.value === true && emitImmediately('month');
      }

      function goToYear (offset) {
        const year = Number(viewModel.value.year) + offset;
        updateViewModel(year, viewModel.value.month);
        isImmediate.value === true && emitImmediately('year');
      }

      function setYear (year) {
        updateViewModel(year, viewModel.value.month);
        view.value = props.defaultView === 'Years' ? 'Months' : 'Calendar';
        isImmediate.value === true && emitImmediately('year');
      }

      function setMonth (month) {
        updateViewModel(viewModel.value.year, month);
        view.value = 'Calendar';
        isImmediate.value === true && emitImmediately('month');
      }

      function toggleDate (date, monthHash) {
        const month = daysMap.value[ monthHash ];
        const fn = month !== void 0 && month.includes(date.day) === true
          ? removeFromModel
          : addToModel;

        fn(date);
      }

      function getShortDate (date) {
        return { year: date.year, month: date.month, day: date.day }
      }

      function updateViewModel (year, month) {
        if (minNav.value !== null && year <= minNav.value.year) {
          year = minNav.value.year;
          if (month < minNav.value.month) {
            month = minNav.value.month;
          }
        }

        if (maxNav.value !== null && year >= maxNav.value.year) {
          year = maxNav.value.year;
          if (month > maxNav.value.month) {
            month = maxNav.value.month;
          }
        }

        const newHash = year + '/' + pad(month) + '/01';

        if (newHash !== viewModel.value.dateHash) {
          monthDirection.value = (viewModel.value.dateHash < newHash) === ($q.lang.rtl !== true) ? 'left' : 'right';
          if (year !== viewModel.value.year) {
            yearDirection.value = monthDirection.value;
          }

          vue.nextTick(() => {
            startYear.value = year - year % yearsInterval - (year < 0 ? yearsInterval : 0);
            Object.assign(viewModel.value, {
              year,
              month,
              day: 1,
              dateHash: newHash
            });
          });
        }
      }

      function emitValue (val, action, date) {
        const value = val !== null && val.length === 1 && props.multiple === false
          ? val[ 0 ]
          : val;

        lastEmitValue = value;

        const { reason, details } = getEmitParams(action, date);
        emit('update:modelValue', value, reason, details);
      }

      function emitImmediately (reason) {
        const date = daysModel.value[ 0 ] !== void 0 && daysModel.value[ 0 ].dateHash !== null
          ? daysModel.value[ 0 ]
          : { ...viewModel.value }; // inherit day, hours, minutes, milliseconds...

        // nextTick required because of animation delay in viewModel
        vue.nextTick(() => {
          date.year = viewModel.value.year;
          date.month = viewModel.value.month;

          const maxDay = props.calendar !== 'persian'
            ? (new Date(date.year, date.month, 0)).getDate()
            : jalaaliMonthLength(date.year, date.month);

          date.day = Math.min(Math.max(1, date.day), maxDay);

          const value = encodeEntry(date);
          lastEmitValue = value;

          const { details } = getEmitParams('', date);
          emit('update:modelValue', value, reason, details);
        });
      }

      function getEmitParams (action, date) {
        return date.from !== void 0
          ? {
              reason: `${ action }-range`,
              details: {
                ...getShortDate(date.target),
                from: getShortDate(date.from),
                to: getShortDate(date.to)
              }
            }
          : {
              reason: `${ action }-day`,
              details: getShortDate(date)
            }
      }

      function encodeEntry (date, mask, locale) {
        return date.from !== void 0
          ? { from: encodeObjectFn.value(date.from, mask, locale), to: encodeObjectFn.value(date.to, mask, locale) }
          : encodeObjectFn.value(date, mask, locale)
      }

      function addToModel (date) {
        let value;

        if (props.multiple === true) {
          if (date.from !== void 0) {
            // we also need to filter out intersections

            const fromHash = getDayHash(date.from);
            const toHash = getDayHash(date.to);

            const days = daysModel.value
              .filter(day => day.dateHash < fromHash || day.dateHash > toHash);

            const ranges = rangeModel.value
              .filter(({ from, to }) => to.dateHash < fromHash || from.dateHash > toHash);

            value = days.concat(ranges).concat(date).map(entry => encodeEntry(entry));
          }
          else {
            const model = normalizedModel.value.slice();
            model.push(encodeEntry(date));
            value = model;
          }
        }
        else {
          value = encodeEntry(date);
        }

        emitValue(value, 'add', date);
      }

      function removeFromModel (date) {
        if (props.noUnset === true) {
          return
        }

        let model = null;

        if (props.multiple === true && Array.isArray(props.modelValue) === true) {
          const val = encodeEntry(date);

          if (date.from !== void 0) {
            model = props.modelValue.filter(
              date => (
                date.from !== void 0
                  ? (date.from !== val.from && date.to !== val.to)
                  : true
              )
            );
          }
          else {
            model = props.modelValue.filter(date => date !== val);
          }

          if (model.length === 0) {
            model = null;
          }
        }

        emitValue(model, 'remove', date);
      }

      function updateValue (mask, locale, reason) {
        const model = daysModel.value
          .concat(rangeModel.value)
          .map(entry => encodeEntry(entry, mask, locale))
          .filter(entry => {
            return entry.from !== void 0
              ? entry.from.dateHash !== null && entry.to.dateHash !== null
              : entry.dateHash !== null
          });

        emit('update:modelValue', (props.multiple === true ? model : model[ 0 ]) || null, reason);
      }

      // expose public methods
      Object.assign(proxy, {
        setToday, setView, offsetCalendar, setCalendarTo, setEditingRange
      });

      function getHeader () {
        if (props.minimal === true) { return }

        return vue.h('div', {
          class: 'q-date__header ' + headerClass.value
        }, [
          vue.h('div', {
            class: 'relative-position'
          }, [
            vue.h(vue.Transition, {
              name: 'q-transition--fade'
            }, () => vue.h('div', {
              key: 'h-yr-' + headerSubtitle.value,
              class: 'q-date__header-subtitle q-date__header-link '
                + (view.value === 'Years' ? 'q-date__header-link--active' : 'cursor-pointer'),
              tabindex: tabindex.value,
              ...getCache('vY', {
                onClick () { view.value = 'Years'; },
                onKeyup (e) { e.keyCode === 13 && (view.value = 'Years'); }
              })
            }, [ headerSubtitle.value ]))
          ]),

          vue.h('div', {
            class: 'q-date__header-title relative-position flex no-wrap'
          }, [
            vue.h('div', {
              class: 'relative-position col'
            }, [
              vue.h(vue.Transition, {
                name: 'q-transition--fade'
              }, () => vue.h('div', {
                key: 'h-sub' + headerTitle.value,
                class: 'q-date__header-title-label q-date__header-link '
                  + (view.value === 'Calendar' ? 'q-date__header-link--active' : 'cursor-pointer'),
                tabindex: tabindex.value,
                ...getCache('vC', {
                  onClick () { view.value = 'Calendar'; },
                  onKeyup (e) { e.keyCode === 13 && (view.value = 'Calendar'); }
                })
              }, [ headerTitle.value ]))
            ]),

            props.todayBtn === true ? vue.h(QBtn, {
              class: 'q-date__header-today self-start',
              icon: $q.iconSet.datetime.today,
              flat: true,
              size: 'sm',
              round: true,
              tabindex: tabindex.value,
              onClick: setToday
            }) : null
          ])
        ])
      }

      function getNavigation ({ label, type, key, dir, goTo, boundaries, cls }) {
        return [
          vue.h('div', {
            class: 'row items-center q-date__arrow'
          }, [
            vue.h(QBtn, {
              round: true,
              dense: true,
              size: 'sm',
              flat: true,
              icon: dateArrow.value[ 0 ],
              tabindex: tabindex.value,
              disable: boundaries.prev === false,
              ...getCache('go-#' + type, { onClick () { goTo(-1); } })
            })
          ]),

          vue.h('div', {
            class: 'relative-position overflow-hidden flex flex-center' + cls
          }, [
            vue.h(vue.Transition, {
              name: 'q-transition--jump-' + dir
            }, () => vue.h('div', { key }, [
              vue.h(QBtn, {
                flat: true,
                dense: true,
                noCaps: true,
                label,
                tabindex: tabindex.value,
                ...getCache('view#' + type, { onClick: () => { view.value = type; } })
              })
            ]))
          ]),

          vue.h('div', {
            class: 'row items-center q-date__arrow'
          }, [
            vue.h(QBtn, {
              round: true,
              dense: true,
              size: 'sm',
              flat: true,
              icon: dateArrow.value[ 1 ],
              tabindex: tabindex.value,
              disable: boundaries.next === false,
              ...getCache('go+#' + type, { onClick () { goTo(1); } })
            })
          ])
        ]
      }

      const renderViews = {
        Calendar: () => ([
          vue.h('div', {
            key: 'calendar-view',
            class: 'q-date__view q-date__calendar'
          }, [
            vue.h('div', {
              class: 'q-date__navigation row items-center no-wrap'
            }, getNavigation({
              label: innerLocale.value.months[ viewModel.value.month - 1 ],
              type: 'Months',
              key: viewModel.value.month,
              dir: monthDirection.value,
              goTo: goToMonth,
              boundaries: navBoundaries.value.month,
              cls: ' col'
            }).concat(getNavigation({
              label: viewModel.value.year,
              type: 'Years',
              key: viewModel.value.year,
              dir: yearDirection.value,
              goTo: goToYear,
              boundaries: navBoundaries.value.year,
              cls: ''
            }))),

            vue.h('div', {
              class: 'q-date__calendar-weekdays row items-center no-wrap'
            }, daysOfWeek.value.map(day => vue.h('div', { class: 'q-date__calendar-item' }, [ vue.h('div', day) ]))),

            vue.h('div', {
              class: 'q-date__calendar-days-container relative-position overflow-hidden'
            }, [
              vue.h(vue.Transition, {
                name: 'q-transition--slide-' + monthDirection.value
              }, () => vue.h('div', {
                key: viewMonthHash.value,
                class: 'q-date__calendar-days fit'
              }, days.value.map(day => vue.h('div', { class: day.classes }, [
                day.in === true
                  ? vue.h(
                      QBtn, {
                        class: day.today === true ? 'q-date__today' : '',
                        dense: true,
                        flat: day.flat,
                        unelevated: day.unelevated,
                        color: day.color,
                        textColor: day.textColor,
                        label: day.i,
                        tabindex: tabindex.value,
                        ...getCache('day#' + day.i, {
                          onClick: () => { onDayClick(day.i); },
                          onMouseover: () => { onDayMouseover(day.i); }
                        })
                      },
                      day.event !== false
                        ? () => vue.h('div', { class: 'q-date__event bg-' + day.event })
                        : null
                    )
                  : vue.h('div', '' + day.i)
              ]))))
            ])
          ])
        ]),

        Months () {
          const currentYear = viewModel.value.year === today.value.year;
          const isDisabled = month => {
            return (
              (minNav.value !== null && viewModel.value.year === minNav.value.year && minNav.value.month > month)
              || (maxNav.value !== null && viewModel.value.year === maxNav.value.year && maxNav.value.month < month)
            )
          };

          const content = innerLocale.value.monthsShort.map((month, i) => {
            const active = viewModel.value.month === i + 1;

            return vue.h('div', {
              class: 'q-date__months-item flex flex-center'
            }, [
              vue.h(QBtn, {
                class: currentYear === true && today.value.month === i + 1 ? 'q-date__today' : null,
                flat: active !== true,
                label: month,
                unelevated: active,
                color: active === true ? computedColor.value : null,
                textColor: active === true ? computedTextColor.value : null,
                tabindex: tabindex.value,
                disable: isDisabled(i + 1),
                ...getCache('month#' + i, { onClick: () => { setMonth(i + 1); } })
              })
            ])
          });

          props.yearsInMonthView === true && content.unshift(
            vue.h('div', { class: 'row no-wrap full-width' }, [
              getNavigation({
                label: viewModel.value.year,
                type: 'Years',
                key: viewModel.value.year,
                dir: yearDirection.value,
                goTo: goToYear,
                boundaries: navBoundaries.value.year,
                cls: ' col'
              })
            ])
          );

          return vue.h('div', {
            key: 'months-view',
            class: 'q-date__view q-date__months flex flex-center'
          }, content)
        },

        Years () {
          const
            start = startYear.value,
            stop = start + yearsInterval,
            years = [];

          const isDisabled = year => {
            return (
              (minNav.value !== null && minNav.value.year > year)
              || (maxNav.value !== null && maxNav.value.year < year)
            )
          };

          for (let i = start; i <= stop; i++) {
            const active = viewModel.value.year === i;

            years.push(
              vue.h('div', {
                class: 'q-date__years-item flex flex-center'
              }, [
                vue.h(QBtn, {
                  key: 'yr' + i,
                  class: today.value.year === i ? 'q-date__today' : null,
                  flat: !active,
                  label: i,
                  dense: true,
                  unelevated: active,
                  color: active === true ? computedColor.value : null,
                  textColor: active === true ? computedTextColor.value : null,
                  tabindex: tabindex.value,
                  disable: isDisabled(i),
                  ...getCache('yr#' + i, { onClick: () => { setYear(i); } })
                })
              ])
            );
          }

          return vue.h('div', {
            class: 'q-date__view q-date__years flex flex-center'
          }, [
            vue.h('div', {
              class: 'col-auto'
            }, [
              vue.h(QBtn, {
                round: true,
                dense: true,
                flat: true,
                icon: dateArrow.value[ 0 ],
                tabindex: tabindex.value,
                disable: isDisabled(start),
                ...getCache('y-', { onClick: () => { startYear.value -= yearsInterval; } })
              })
            ]),

            vue.h('div', {
              class: 'q-date__years-content col self-stretch row items-center'
            }, years),

            vue.h('div', {
              class: 'col-auto'
            }, [
              vue.h(QBtn, {
                round: true,
                dense: true,
                flat: true,
                icon: dateArrow.value[ 1 ],
                tabindex: tabindex.value,
                disable: isDisabled(stop),
                ...getCache('y+', { onClick: () => { startYear.value += yearsInterval; } })
              })
            ])
          ])
        }
      };

      function onDayClick (dayIndex) {
        const day = { ...viewModel.value, day: dayIndex };

        if (props.range === false) {
          toggleDate(day, viewMonthHash.value);
          return
        }

        if (editRange.value === null) {
          const dayProps = days.value.find(day => day.fill !== true && day.i === dayIndex);

          if (dayProps.range !== void 0) {
            removeFromModel({ target: day, from: dayProps.range.from, to: dayProps.range.to });
            return
          }

          if (dayProps.selected === true) {
            removeFromModel(day);
            return
          }

          const initHash = getDayHash(day);

          editRange.value = {
            init: day,
            initHash,
            final: day,
            finalHash: initHash
          };

          emit('range-start', getShortDate(day));
        }
        else {
          const
            initHash = editRange.value.initHash,
            finalHash = getDayHash(day),
            payload = initHash <= finalHash
              ? { from: editRange.value.init, to: day }
              : { from: day, to: editRange.value.init };

          editRange.value = null;
          addToModel(initHash === finalHash ? day : { target: day, ...payload });

          emit('range-end', {
            from: getShortDate(payload.from),
            to: getShortDate(payload.to)
          });
        }
      }

      function onDayMouseover (dayIndex) {
        if (editRange.value !== null) {
          const final = { ...viewModel.value, day: dayIndex };

          Object.assign(editRange.value, {
            final,
            finalHash: getDayHash(final)
          });
        }
      }

      return () => {
        const content = [
          vue.h('div', {
            class: 'q-date__content col relative-position'
          }, [
            vue.h(vue.Transition, {
              name: 'q-transition--fade'
            }, renderViews[ view.value ])
          ])
        ];

        const def = hSlot(slots.default);
        def !== void 0 && content.push(
          vue.h('div', { class: 'q-date__actions' }, def)
        );

        if (props.name !== void 0 && props.disable !== true) {
          injectFormInput(content, 'push');
        }

        return vue.h('div', {
          class: classes.value,
          ...attributes.value
        }, [
          getHeader(),

          vue.h('div', {
            ref: blurTargetRef,
            class: 'q-date__main col column',
            tabindex: -1
          }, content)
        ])
      }
    }
  });

  function useHistory (showing, hide, hideOnRouteChange) {
    let historyEntry;

    function removeFromHistory () {
      if (historyEntry !== void 0) {
        History.remove(historyEntry);
        historyEntry = void 0;
      }
    }

    vue.onBeforeUnmount(() => {
      showing.value === true && removeFromHistory();
    });

    return {
      removeFromHistory,

      addToHistory () {
        historyEntry = {
          condition: () => hideOnRouteChange.value === true,
          handler: hide
        };

        History.add(historyEntry);
      }
    }
  }

  let
    registered = 0,
    scrollPositionX,
    scrollPositionY,
    maxScrollTop,
    vpPendingUpdate = false,
    bodyLeft,
    bodyTop,
    closeTimer;

  function onWheel (e) {
    if (shouldPreventScroll(e)) {
      stopAndPrevent(e);
    }
  }

  function shouldPreventScroll (e) {
    if (e.target === document.body || e.target.classList.contains('q-layout__backdrop')) {
      return true
    }

    const
      path = getEventPath(e),
      shift = e.shiftKey && !e.deltaX,
      scrollY = !shift && Math.abs(e.deltaX) <= Math.abs(e.deltaY),
      delta = shift || scrollY ? e.deltaY : e.deltaX;

    for (let index = 0; index < path.length; index++) {
      const el = path[ index ];

      if (hasScrollbar(el, scrollY)) {
        return scrollY
          ? (
              delta < 0 && el.scrollTop === 0
                ? true
                : delta > 0 && el.scrollTop + el.clientHeight === el.scrollHeight
            )
          : (
              delta < 0 && el.scrollLeft === 0
                ? true
                : delta > 0 && el.scrollLeft + el.clientWidth === el.scrollWidth
            )
      }
    }

    return true
  }

  function onAppleScroll (e) {
    if (e.target === document) {
      // required, otherwise iOS blocks further scrolling
      // until the mobile scrollbar dissappears
      document.scrollingElement.scrollTop = document.scrollingElement.scrollTop; // eslint-disable-line
    }
  }

  function onAppleResize (evt) {
    if (vpPendingUpdate === true) {
      return
    }

    vpPendingUpdate = true;

    requestAnimationFrame(() => {
      vpPendingUpdate = false;

      const
        { height } = evt.target,
        { clientHeight, scrollTop } = document.scrollingElement;

      if (maxScrollTop === void 0 || height !== window.innerHeight) {
        maxScrollTop = clientHeight - height;
        document.scrollingElement.scrollTop = scrollTop;
      }

      if (scrollTop > maxScrollTop) {
        document.scrollingElement.scrollTop -= Math.ceil((scrollTop - maxScrollTop) / 8);
      }
    });
  }

  function apply$1 (action) {
    const
      body = document.body,
      hasViewport = window.visualViewport !== void 0;

    if (action === 'add') {
      const { overflowY, overflowX } = window.getComputedStyle(body);

      scrollPositionX = getHorizontalScrollPosition(window);
      scrollPositionY = getVerticalScrollPosition(window);
      bodyLeft = body.style.left;
      bodyTop = body.style.top;

      body.style.left = `-${ scrollPositionX }px`;
      body.style.top = `-${ scrollPositionY }px`;

      if (overflowX !== 'hidden' && (overflowX === 'scroll' || body.scrollWidth > window.innerWidth)) {
        body.classList.add('q-body--force-scrollbar-x');
      }
      if (overflowY !== 'hidden' && (overflowY === 'scroll' || body.scrollHeight > window.innerHeight)) {
        body.classList.add('q-body--force-scrollbar-y');
      }

      body.classList.add('q-body--prevent-scroll');
      document.qScrollPrevented = true;
      if (client.is.ios === true) {
        if (hasViewport === true) {
          window.scrollTo(0, 0);
          window.visualViewport.addEventListener('resize', onAppleResize, listenOpts.passiveCapture);
          window.visualViewport.addEventListener('scroll', onAppleResize, listenOpts.passiveCapture);
          window.scrollTo(0, 0);
        }
        else {
          window.addEventListener('scroll', onAppleScroll, listenOpts.passiveCapture);
        }
      }
    }

    if (client.is.desktop === true && client.is.mac === true) {
      // ref. https://developers.google.com/web/updates/2017/01/scrolling-intervention
      window[ `${ action }EventListener` ]('wheel', onWheel, listenOpts.notPassive);
    }

    if (action === 'remove') {
      if (client.is.ios === true) {
        if (hasViewport === true) {
          window.visualViewport.removeEventListener('resize', onAppleResize, listenOpts.passiveCapture);
          window.visualViewport.removeEventListener('scroll', onAppleResize, listenOpts.passiveCapture);
        }
        else {
          window.removeEventListener('scroll', onAppleScroll, listenOpts.passiveCapture);
        }
      }

      body.classList.remove('q-body--prevent-scroll');
      body.classList.remove('q-body--force-scrollbar-x');
      body.classList.remove('q-body--force-scrollbar-y');

      document.qScrollPrevented = false;

      body.style.left = bodyLeft;
      body.style.top = bodyTop;

      window.scrollTo(scrollPositionX, scrollPositionY);
      maxScrollTop = void 0;
    }
  }

  function preventScroll (state) {
    let action = 'add';

    if (state === true) {
      registered++;

      if (closeTimer !== void 0) {
        clearTimeout(closeTimer);
        closeTimer = void 0;
        return
      }

      if (registered > 1) {
        return
      }
    }
    else {
      if (registered === 0) {
        return
      }

      registered--;

      if (registered > 0) {
        return
      }

      action = 'remove';

      if (client.is.ios === true && client.is.nativeMobile === true) {
        clearTimeout(closeTimer);

        closeTimer = setTimeout(() => {
          apply$1(action);
          closeTimer = void 0;
        }, 100);
        return
      }
    }

    apply$1(action);
  }

  function usePreventScroll () {
    let currentState;

    return {
      preventBodyScroll (state) {
        if (
          state !== currentState
          && (currentState !== void 0 || state === true)
        ) {
          currentState = state;
          preventScroll(state);
        }
      }
    }
  }

  let maximizedModals = 0;

  const positionClass$1 = {
    standard: 'fixed-full flex-center',
    top: 'fixed-top justify-center',
    bottom: 'fixed-bottom justify-center',
    right: 'fixed-right items-center',
    left: 'fixed-left items-center'
  };

  const transitions = {
    standard: [ 'scale', 'scale' ],
    top: [ 'slide-down', 'slide-up' ],
    bottom: [ 'slide-up', 'slide-down' ],
    right: [ 'slide-left', 'slide-right' ],
    left: [ 'slide-right', 'slide-left' ]
  };

  var QDialog = vue.defineComponent({
    name: 'QDialog',

    inheritAttrs: false,

    props: {
      ...useModelToggleProps,
      ...useTransitionProps,

      transitionShow: String,
      transitionHide: String,

      persistent: Boolean,
      autoClose: Boolean,

      noEscDismiss: Boolean,
      noBackdropDismiss: Boolean,
      noRouteDismiss: Boolean,
      noRefocus: Boolean,
      noFocus: Boolean,

      seamless: Boolean,

      maximized: Boolean,
      fullWidth: Boolean,
      fullHeight: Boolean,

      square: Boolean,

      position: {
        type: String,
        default: 'standard',
        validator: val => val === 'standard'
          || [ 'top', 'bottom', 'left', 'right' ].includes(val)
      }
    },

    emits: [
      ...useModelToggleEmits,
      'shake', 'click', 'escape-key'
    ],

    setup (props, { slots, emit, attrs }) {
      const vm = vue.getCurrentInstance();

      const innerRef = vue.ref(null);
      const showing = vue.ref(false);
      const transitionState = vue.ref(false);
      const animating = vue.ref(false);

      let shakeTimeout, refocusTarget = null, isMaximized, avoidAutoClose;

      const hideOnRouteChange = vue.computed(() =>
        props.persistent !== true
        && props.noRouteDismiss !== true
        && props.seamless !== true
      );

      const { preventBodyScroll } = usePreventScroll();
      const { registerTimeout, removeTimeout } = useTimeout();
      const { registerTick, removeTick, prepareTick } = useTick();

      const { showPortal, hidePortal, portalIsActive, renderPortal } = usePortal(
        vm, innerRef, renderPortalContent, /* pls do check if on a global dialog */ true
      );

      const { hide } = useModelToggle({
        showing,
        hideOnRouteChange,
        handleShow,
        handleHide,
        processOnMount: true
      });

      const { addToHistory, removeFromHistory } = useHistory(showing, hide, hideOnRouteChange);

      const classes = vue.computed(() =>
        'q-dialog__inner flex no-pointer-events'
        + ` q-dialog__inner--${ props.maximized === true ? 'maximized' : 'minimized' }`
        + ` q-dialog__inner--${ props.position } ${ positionClass$1[ props.position ] }`
        + (animating.value === true ? ' q-dialog__inner--animating' : '')
        + (props.fullWidth === true ? ' q-dialog__inner--fullwidth' : '')
        + (props.fullHeight === true ? ' q-dialog__inner--fullheight' : '')
        + (props.square === true ? ' q-dialog__inner--square' : '')
      );

      const transitionShow = vue.computed(() =>
        'q-transition--'
        + (props.transitionShow === void 0 ? transitions[ props.position ][ 0 ] : props.transitionShow)
      );

      const transitionHide = vue.computed(() =>
        'q-transition--'
        + (props.transitionHide === void 0 ? transitions[ props.position ][ 1 ] : props.transitionHide)
      );

      const transition = vue.computed(() => (
        transitionState.value === true
          ? transitionHide.value
          : transitionShow.value
      ));

      const useBackdrop = vue.computed(() => showing.value === true && props.seamless !== true);

      const onEvents = vue.computed(() => (
        props.autoClose === true
          ? { onClick: onAutoClose }
          : {}
      ));

      const rootClasses = vue.computed(() => [
        'q-dialog fullscreen no-pointer-events '
          + `q-dialog--${ useBackdrop.value === true ? 'modal' : 'seamless' }`,
        attrs.class
      ]);

      vue.watch(showing, val => {
        vue.nextTick(() => {
          transitionState.value = val;
        });
      });

      vue.watch(() => props.maximized, state => {
        showing.value === true && updateMaximized(state);
      });

      vue.watch(useBackdrop, val => {
        preventBodyScroll(val);

        if (val === true) {
          addFocusout(onFocusChange);
          addEscapeKey(onEscapeKey);
        }
        else {
          removeFocusout(onFocusChange);
          removeEscapeKey(onEscapeKey);
        }
      });

      function handleShow (evt) {
        removeTimeout();
        removeTick();
        addToHistory();

        refocusTarget = props.noRefocus === false && document.activeElement !== null
          ? document.activeElement
          : null;

        updateMaximized(props.maximized);
        showPortal();
        animating.value = true;

        if (props.noFocus !== true) {
          document.activeElement !== null && document.activeElement.blur();
          registerTick(focus);
          prepareTick();
        }

        registerTimeout(() => {
          if (vm.proxy.$q.platform.is.ios === true) {
            if (props.seamless !== true && document.activeElement) {
              const
                { top, bottom } = document.activeElement.getBoundingClientRect(),
                { innerHeight } = window,
                height = window.visualViewport !== void 0
                  ? window.visualViewport.height
                  : innerHeight;

              if (top > 0 && bottom > height / 2) {
                document.scrollingElement.scrollTop = Math.min(
                  document.scrollingElement.scrollHeight - height,
                  bottom >= innerHeight
                    ? Infinity
                    : Math.ceil(document.scrollingElement.scrollTop + bottom - height / 2)
                );
              }

              document.activeElement.scrollIntoView();
            }

            // required in order to avoid the "double-tap needed" issue
            avoidAutoClose = true;
            innerRef.value.click();
            avoidAutoClose = false;
          }

          showPortal(true); // done showing portal
          animating.value = false;
          emit('show', evt);
        }, props.transitionDuration);
      }

      function handleHide (evt) {
        removeTimeout();
        removeTick();
        removeFromHistory();
        cleanup(true);
        animating.value = true;

        if (refocusTarget !== null) {
          refocusTarget.focus();
        }

        registerTimeout(() => {
          hidePortal();
          animating.value = false;
          emit('hide', evt);
        }, props.transitionDuration);
      }

      function focus () {
        addFocusFn(() => {
          let node = innerRef.value;

          if (node === null || node.contains(document.activeElement) === true) {
            return
          }

          node = node.querySelector('[autofocus], [data-autofocus]') || node;
          node.focus();
        });
      }

      function shake () {
        focus();
        emit('shake');

        const node = innerRef.value;

        if (node !== null) {
          node.classList.remove('q-animate--scale');
          node.classList.add('q-animate--scale');
          clearTimeout(shakeTimeout);
          shakeTimeout = setTimeout(() => {
            if (innerRef.value !== null) {
              node.classList.remove('q-animate--scale');
              // some platforms (like desktop Chrome)
              // require calling focus() again
              focus();
            }
          }, 170);
        }
      }

      function onEscapeKey () {
        if (props.seamless !== true) {
          if (props.persistent === true || props.noEscDismiss === true) {
            props.maximized !== true && shake();
          }
          else {
            emit('escape-key');
            hide();
          }
        }
      }

      function cleanup (hiding) {
        clearTimeout(shakeTimeout);

        if (hiding === true || showing.value === true) {
          updateMaximized(false);

          if (props.seamless !== true) {
            preventBodyScroll(false);
            removeFocusout(onFocusChange);
            removeEscapeKey(onEscapeKey);
          }
        }
      }

      function updateMaximized (active) {
        if (active === true) {
          if (isMaximized !== true) {
            maximizedModals < 1 && document.body.classList.add('q-body--dialog');
            maximizedModals++;

            isMaximized = true;
          }
        }
        else if (isMaximized === true) {
          if (maximizedModals < 2) {
            document.body.classList.remove('q-body--dialog');
          }

          maximizedModals--;
          isMaximized = false;
        }
      }

      function onAutoClose (e) {
        if (avoidAutoClose !== true) {
          hide(e);
          emit('click', e);
        }
      }

      function onBackdropClick (e) {
        if (props.persistent !== true && props.noBackdropDismiss !== true) {
          hide(e);
        }
        else {
          shake();
        }
      }

      function onFocusChange (evt) {
        // the focus is not in a vue child component
        if (
          showing.value === true
          && portalIsActive.value === true
          && childHasFocus(innerRef.value, evt.target) !== true
        ) {
          focus();
        }
      }

      Object.assign(vm.proxy, {
        // expose public methods
        focus, shake,

        // private but needed by QSelect
        __updateRefocusTarget (target) {
          refocusTarget = target || null;
        }
      });

      vue.onBeforeUnmount(() => {
        cleanup();
      });

      function renderPortalContent () {
        return vue.h('div', {
          ...attrs,
          class: rootClasses.value
        }, [
          vue.h(vue.Transition, {
            name: 'q-transition--fade',
            appear: true
          }, () => (
            useBackdrop.value === true
              ? vue.h('div', {
                  class: 'q-dialog__backdrop fixed-full',
                  'aria-hidden': 'true',
                  onMousedown: onBackdropClick
                })
              : null
          )),

          vue.h(
            vue.Transition,
            { name: transition.value, appear: true },
            () => (
              showing.value === true
                ? vue.h('div', {
                    ref: innerRef,
                    class: classes.value,
                    tabindex: -1,
                    ...onEvents.value
                  }, hSlot(slots.default))
                : null
            )
          )
        ])
      }

      return renderPortal
    }
  });

  const duration = 150;

  var QDrawer = vue.defineComponent({
    name: 'QDrawer',

    inheritAttrs: false,

    props: {
      ...useModelToggleProps,
      ...useDarkProps,

      side: {
        type: String,
        default: 'left',
        validator: v => [ 'left', 'right' ].includes(v)
      },

      width: {
        type: Number,
        default: 300
      },

      mini: Boolean,
      miniToOverlay: Boolean,
      miniWidth: {
        type: Number,
        default: 57
      },

      breakpoint: {
        type: Number,
        default: 1023
      },
      showIfAbove: Boolean,

      behavior: {
        type: String,
        validator: v => [ 'default', 'desktop', 'mobile' ].includes(v),
        default: 'default'
      },

      bordered: Boolean,
      elevated: Boolean,

      overlay: Boolean,
      persistent: Boolean,
      noSwipeOpen: Boolean,
      noSwipeClose: Boolean,
      noSwipeBackdrop: Boolean
    },

    emits: [
      ...useModelToggleEmits,
      'on-layout', 'mini-state'
    ],

    setup (props, { slots, emit, attrs }) {
      const vm = vue.getCurrentInstance();
      const { proxy: { $q } } = vm;

      const isDark = useDark(props, $q);
      const { preventBodyScroll } = usePreventScroll();
      const { registerTimeout } = useTimeout();

      const $layout = vue.inject(layoutKey, () => {
        console.error('QDrawer needs to be child of QLayout');
      });

      let lastDesktopState, timerMini, layoutTotalWidthWatcher;

      const belowBreakpoint = vue.ref(
        props.behavior === 'mobile'
        || (props.behavior !== 'desktop' && $layout.totalWidth.value <= props.breakpoint)
      );

      const isMini = vue.computed(() =>
        props.mini === true && belowBreakpoint.value !== true
      );

      const size = vue.computed(() => (
        isMini.value === true
          ? props.miniWidth
          : props.width
      ));

      const showing = vue.ref(
        props.showIfAbove === true && belowBreakpoint.value === false
          ? true
          : props.modelValue === true
      );

      const hideOnRouteChange = vue.computed(() =>
        props.persistent !== true
        && (belowBreakpoint.value === true || onScreenOverlay.value === true)
      );

      function handleShow (evt, noEvent) {
        addToHistory();

        evt !== false && $layout.animate();
        applyPosition(0);

        if (belowBreakpoint.value === true) {
          const otherInstance = $layout.instances[ otherSide.value ];
          if (otherInstance !== void 0 && otherInstance.belowBreakpoint === true) {
            otherInstance.hide(false);
          }

          applyBackdrop(1);
          $layout.isContainer.value !== true && preventBodyScroll(true);
        }
        else {
          applyBackdrop(0);
          evt !== false && setScrollable(false);
        }

        registerTimeout(() => {
          evt !== false && setScrollable(true);
          noEvent !== true && emit('show', evt);
        }, duration);
      }

      function handleHide (evt, noEvent) {
        removeFromHistory();

        evt !== false && $layout.animate();

        applyBackdrop(0);
        applyPosition(stateDirection.value * size.value);

        cleanup();

        noEvent !== true && registerTimeout(() => {
          emit('hide', evt);
        }, duration);
      }

      const { show, hide } = useModelToggle({
        showing,
        hideOnRouteChange,
        handleShow,
        handleHide
      });

      const { addToHistory, removeFromHistory } = useHistory(showing, hide, hideOnRouteChange);

      const instance = {
        belowBreakpoint,
        hide
      };

      const rightSide = vue.computed(() => props.side === 'right');

      const stateDirection = vue.computed(() =>
        ($q.lang.rtl === true ? -1 : 1) * (rightSide.value === true ? 1 : -1)
      );

      const flagBackdropBg = vue.ref(0);
      const flagPanning = vue.ref(false);
      const flagMiniAnimate = vue.ref(false);
      const flagContentPosition = vue.ref( // starting with "hidden" for SSR
        size.value * stateDirection.value
      );

      const otherSide = vue.computed(() => (rightSide.value === true ? 'left' : 'right'));
      const offset = vue.computed(() => (
        showing.value === true && belowBreakpoint.value === false && props.overlay === false
          ? (props.miniToOverlay === true ? props.miniWidth : size.value)
          : 0
      ));

      const fixed = vue.computed(() =>
        props.overlay === true
        || props.miniToOverlay === true
        || $layout.view.value.indexOf(rightSide.value ? 'R' : 'L') > -1
        || ($q.platform.is.ios === true && $layout.isContainer.value === true)
      );

      const onLayout = vue.computed(() =>
        props.overlay === false
        && showing.value === true
        && belowBreakpoint.value === false
      );

      const onScreenOverlay = vue.computed(() =>
        props.overlay === true
        && showing.value === true
        && belowBreakpoint.value === false
      );

      const backdropClass = vue.computed(() =>
        'fullscreen q-drawer__backdrop'
        + (showing.value === false && flagPanning.value === false ? ' hidden' : '')
      );

      const backdropStyle = vue.computed(() => ({
        backgroundColor: `rgba(0,0,0,${ flagBackdropBg.value * 0.4 })`
      }));

      const headerSlot = vue.computed(() => (
        rightSide.value === true
          ? $layout.rows.value.top[ 2 ] === 'r'
          : $layout.rows.value.top[ 0 ] === 'l'
      ));

      const footerSlot = vue.computed(() => (
        rightSide.value === true
          ? $layout.rows.value.bottom[ 2 ] === 'r'
          : $layout.rows.value.bottom[ 0 ] === 'l'
      ));

      const aboveStyle = vue.computed(() => {
        const css = {};

        if ($layout.header.space === true && headerSlot.value === false) {
          if (fixed.value === true) {
            css.top = `${ $layout.header.offset }px`;
          }
          else if ($layout.header.space === true) {
            css.top = `${ $layout.header.size }px`;
          }
        }

        if ($layout.footer.space === true && footerSlot.value === false) {
          if (fixed.value === true) {
            css.bottom = `${ $layout.footer.offset }px`;
          }
          else if ($layout.footer.space === true) {
            css.bottom = `${ $layout.footer.size }px`;
          }
        }

        return css
      });

      const style = vue.computed(() => {
        const style = {
          width: `${ size.value }px`,
          transform: `translateX(${ flagContentPosition.value }px)`
        };

        return belowBreakpoint.value === true
          ? style
          : Object.assign(style, aboveStyle.value)
      });

      const contentClass = vue.computed(() =>
        'q-drawer__content fit '
        + ($layout.isContainer.value !== true ? 'scroll' : 'overflow-auto')
      );

      const classes = vue.computed(() =>
        `q-drawer q-drawer--${ props.side }`
        + (flagMiniAnimate.value === true ? ' q-drawer--mini-animate' : '')
        + (props.bordered === true ? ' q-drawer--bordered' : '')
        + (isDark.value === true ? ' q-drawer--dark q-dark' : '')
        + (
          flagPanning.value === true
            ? ' no-transition'
            : (showing.value === true ? '' : ' q-layout--prevent-focus')
        )
        + (
          belowBreakpoint.value === true
            ? ' fixed q-drawer--on-top q-drawer--mobile q-drawer--top-padding'
            : ` q-drawer--${ isMini.value === true ? 'mini' : 'standard' }`
            + (fixed.value === true || onLayout.value !== true ? ' fixed' : '')
            + (props.overlay === true || props.miniToOverlay === true ? ' q-drawer--on-top' : '')
            + (headerSlot.value === true ? ' q-drawer--top-padding' : '')
        )
      );

      const openDirective = vue.computed(() => {
        // if props.noSwipeOpen !== true
        const dir = $q.lang.rtl === true ? props.side : otherSide.value;

        return [ [
          TouchPan,
          onOpenPan,
          void 0,
          {
            [ dir ]: true,
            mouse: true
          }
        ] ]
      });

      const contentCloseDirective = vue.computed(() => {
        // if belowBreakpoint.value === true && props.noSwipeClose !== true
        const dir = $q.lang.rtl === true ? otherSide.value : props.side;

        return [ [
          TouchPan,
          onClosePan,
          void 0,
          {
            [ dir ]: true,
            mouse: true
          }
        ] ]
      });

      const backdropCloseDirective = vue.computed(() => {
        // if showing.value === true && props.noSwipeBackdrop !== true
        const dir = $q.lang.rtl === true ? otherSide.value : props.side;

        return [ [
          TouchPan,
          onClosePan,
          void 0,
          {
            [ dir ]: true,
            mouse: true,
            mouseAllDir: true
          }
        ] ]
      });

      vue.watch(belowBreakpoint, val => {
        if (val === true) { // from lg to xs
          lastDesktopState = showing.value;
          showing.value === true && hide(false);
        }
        else if (
          props.overlay === false
          && props.behavior !== 'mobile'
          && lastDesktopState !== false
        ) { // from xs to lg
          if (showing.value === true) {
            applyPosition(0);
            applyBackdrop(0);
            cleanup();
          }
          else {
            show(false);
          }
        }
      });

      vue.watch($layout.totalWidth, val => {
        updateLocal(belowBreakpoint, (
          props.behavior === 'mobile'
          || (props.behavior !== 'desktop' && val <= props.breakpoint)
        ));
      });

      vue.watch(() => props.side, (newSide, oldSide) => {
        if ($layout.instances[ oldSide ] === instance) {
          $layout.instances[ oldSide ] = void 0;
          $layout[ oldSide ].space = false;
          $layout[ oldSide ].offset = 0;
        }

        $layout.instances[ newSide ] = instance;
        $layout[ newSide ].size = size.value;
        $layout[ newSide ].space = onLayout.value;
        $layout[ newSide ].offset = offset.value;
      });

      vue.watch(() => props.behavior + props.breakpoint, updateBelowBreakpoint);

      vue.watch($layout.isContainer, val => {
        showing.value === true && preventBodyScroll(val !== true);
      });

      vue.watch($layout.scrollbarWidth, () => {
        applyPosition(showing.value === true ? 0 : void 0);
      });

      vue.watch(offset, val => { updateLayout('offset', val); });

      vue.watch(onLayout, val => {
        emit('on-layout', val);
        updateLayout('space', val);
      });

      vue.watch(rightSide, () => { applyPosition(); });

      vue.watch(size, val => {
        applyPosition();
        updateSizeOnLayout(props.miniToOverlay, val);
      });

      vue.watch(() => props.miniToOverlay, val => {
        updateSizeOnLayout(val, size.value);
      });

      vue.watch(() => $q.lang.rtl, () => { applyPosition(); });

      vue.watch(() => props.mini, () => {
        if (props.modelValue === true) {
          animateMini();
          $layout.animate();
        }
      });

      vue.watch(isMini, val => { emit('mini-state', val); });

      function applyPosition (position) {
        if (position === void 0) {
          vue.nextTick(() => {
            position = showing.value === true ? 0 : size.value;
            applyPosition(stateDirection.value * position);
          });
        }
        else {
          if (
            $layout.isContainer.value === true
            && rightSide.value === true
            && (belowBreakpoint.value === true || Math.abs(position) === size.value)
          ) {
            position += stateDirection.value * $layout.scrollbarWidth.value;
          }

          flagContentPosition.value = position;
        }
      }

      function updateBelowBreakpoint () {
        updateLocal(belowBreakpoint, (
          props.behavior === 'mobile'
          || (props.behavior !== 'desktop' && $layout.totalWidth.value <= props.breakpoint)
        ));
      }

      function applyBackdrop (x) {
        flagBackdropBg.value = x;
      }

      function setScrollable (v) {
        const action = v === true
          ? 'remove'
          : ($layout.isContainer.value !== true ? 'add' : '');

        action !== '' && document.body.classList[ action ]('q-body--drawer-toggle');
      }

      function animateMini () {
        clearTimeout(timerMini);

        if (vm.proxy && vm.proxy.$el) {
          // need to speed it up and apply it immediately,
          // even faster than Vue's nextTick!
          vm.proxy.$el.classList.add('q-drawer--mini-animate');
        }

        flagMiniAnimate.value = true;
        timerMini = setTimeout(() => {
          flagMiniAnimate.value = false;
        }, 150);
      }

      function onOpenPan (evt) {
        if (showing.value !== false) {
          // some browsers might capture and trigger this
          // even if Drawer has just been opened (but animation is still pending)
          return
        }

        const
          width = size.value,
          position = between(evt.distance.x, 0, width);

        if (evt.isFinal === true) {
          const opened = position >= Math.min(75, width);

          if (opened === true) {
            show();
          }
          else {
            $layout.animate();
            applyBackdrop(0);
            applyPosition(stateDirection.value * width);
          }

          flagPanning.value = false;
          return
        }

        applyPosition(
          ($q.lang.rtl === true ? rightSide.value !== true : rightSide.value)
            ? Math.max(width - position, 0)
            : Math.min(0, position - width)
        );
        applyBackdrop(
          between(position / width, 0, 1)
        );

        if (evt.isFirst === true) {
          flagPanning.value = true;
        }
      }

      function onClosePan (evt) {
        if (showing.value !== true) {
          // some browsers might capture and trigger this
          // even if Drawer has just been closed (but animation is still pending)
          return
        }

        const
          width = size.value,
          dir = evt.direction === props.side,
          position = ($q.lang.rtl === true ? dir !== true : dir)
            ? between(evt.distance.x, 0, width)
            : 0;

        if (evt.isFinal === true) {
          const opened = Math.abs(position) < Math.min(75, width);

          if (opened === true) {
            $layout.animate();
            applyBackdrop(1);
            applyPosition(0);
          }
          else {
            hide();
          }

          flagPanning.value = false;
          return
        }

        applyPosition(stateDirection.value * position);
        applyBackdrop(between(1 - position / width, 0, 1));

        if (evt.isFirst === true) {
          flagPanning.value = true;
        }
      }

      function cleanup () {
        preventBodyScroll(false);
        setScrollable(true);
      }

      function updateLayout (prop, val) {
        $layout.update(props.side, prop, val);
      }

      function updateLocal (prop, val) {
        if (prop.value !== val) {
          prop.value = val;
        }
      }

      function updateSizeOnLayout (miniToOverlay, size) {
        updateLayout('size', miniToOverlay === true ? props.miniWidth : size);
      }

      $layout.instances[ props.side ] = instance;
      updateSizeOnLayout(props.miniToOverlay, size.value);
      updateLayout('space', onLayout.value);
      updateLayout('offset', offset.value);

      if (
        props.showIfAbove === true
        && props.modelValue !== true
        && showing.value === true
        && props[ 'onUpdate:modelValue' ] !== void 0
      ) {
        emit('update:modelValue', true);
      }

      vue.onMounted(() => {
        emit('on-layout', onLayout.value);
        emit('mini-state', isMini.value);

        lastDesktopState = props.showIfAbove === true;

        const fn = () => {
          const action = showing.value === true ? handleShow : handleHide;
          action(false, true);
        };

        if ($layout.totalWidth.value !== 0) {
          // make sure that all computed properties
          // have been updated before calling handleShow/handleHide()
          vue.nextTick(fn);
          return
        }

        layoutTotalWidthWatcher = vue.watch($layout.totalWidth, () => {
          layoutTotalWidthWatcher();
          layoutTotalWidthWatcher = void 0;

          if (showing.value === false && props.showIfAbove === true && belowBreakpoint.value === false) {
            show(false);
          }
          else {
            fn();
          }
        });
      });

      vue.onBeforeUnmount(() => {
        layoutTotalWidthWatcher !== void 0 && layoutTotalWidthWatcher();
        clearTimeout(timerMini);

        showing.value === true && cleanup();

        if ($layout.instances[ props.side ] === instance) {
          $layout.instances[ props.side ] = void 0;
          updateLayout('size', 0);
          updateLayout('offset', 0);
          updateLayout('space', false);
        }
      });

      return () => {
        const child = [];

        if (belowBreakpoint.value === true) {
          props.noSwipeOpen === false && child.push(
            vue.withDirectives(
              vue.h('div', {
                key: 'open',
                class: `q-drawer__opener fixed-${ props.side }`,
                'aria-hidden': 'true'
              }),
              openDirective.value
            )
          );

          child.push(
            hDir(
              'div',
              {
                ref: 'backdrop',
                class: backdropClass.value,
                style: backdropStyle.value,
                'aria-hidden': 'true',
                onClick: hide
              },
              void 0,
              'backdrop',
              props.noSwipeBackdrop !== true && showing.value === true,
              () => backdropCloseDirective.value
            )
          );
        }

        const mini = isMini.value === true && slots.mini !== void 0;
        const content = [
          vue.h('div', {
            ...attrs,
            key: '' + mini, // required otherwise Vue will not diff correctly
            class: [
              contentClass.value,
              attrs.class
            ]
          }, mini === true
            ? slots.mini()
            : hSlot(slots.default)
          )
        ];

        if (props.elevated === true && showing.value === true) {
          content.push(
            vue.h('div', {
              class: 'q-layout__shadow absolute-full overflow-hidden no-pointer-events'
            })
          );
        }

        child.push(
          hDir(
            'aside',
            { ref: 'content', class: classes.value, style: style.value },
            content,
            'contentclose',
            props.noSwipeClose !== true && belowBreakpoint.value === true,
            () => contentCloseDirective.value
          )
        );

        return vue.h('div', { class: 'q-drawer-container' }, child)
      }
    }
  });

  function getBlockElement (el, parent) {
    if (parent && el === parent) {
      return null
    }

    const nodeName = el.nodeName.toLowerCase();

    if ([ 'div', 'li', 'ul', 'ol', 'blockquote' ].includes(nodeName) === true) {
      return el
    }

    const
      style = window.getComputedStyle
        ? window.getComputedStyle(el)
        : el.currentStyle,
      display = style.display;

    if (display === 'block' || display === 'table') {
      return el
    }

    return getBlockElement(el.parentNode)
  }

  function isChildOf (el, parent, orSame) {
    return !el || el === document.body
      ? false
      : (orSame === true && el === parent) || (parent === document ? document.body : parent).contains(el.parentNode)
  }

  function createRange (node, chars, range) {
    if (!range) {
      range = document.createRange();
      range.selectNode(node);
      range.setStart(node, 0);
    }

    if (chars.count === 0) {
      range.setEnd(node, chars.count);
    }
    else if (chars.count > 0) {
      if (node.nodeType === Node.TEXT_NODE) {
        if (node.textContent.length < chars.count) {
          chars.count -= node.textContent.length;
        }
        else {
          range.setEnd(node, chars.count);
          chars.count = 0;
        }
      }
      else {
        for (let lp = 0; chars.count !== 0 && lp < node.childNodes.length; lp++) {
          range = createRange(node.childNodes[ lp ], chars, range);
        }
      }
    }

    return range
  }

  const urlRegex = /^https?:\/\//;

  class Caret {
    constructor (el, eVm) {
      this.el = el;
      this.eVm = eVm;
      this._range = null;
    }

    get selection () {
      if (this.el) {
        const sel = document.getSelection();

        // only when the selection in element
        if (isChildOf(sel.anchorNode, this.el, true) && isChildOf(sel.focusNode, this.el, true)) {
          return sel
        }
      }

      return null
    }

    get hasSelection () {
      return this.selection !== null
        ? this.selection.toString().length > 0
        : false
    }

    get range () {
      const sel = this.selection;

      if (sel !== null && sel.rangeCount) {
        return sel.getRangeAt(0)
      }

      return this._range
    }

    get parent () {
      const range = this.range;

      if (range !== null) {
        const node = range.startContainer;

        return node.nodeType === document.ELEMENT_NODE
          ? node
          : node.parentNode
      }

      return null
    }

    get blockParent () {
      const parent = this.parent;

      if (parent !== null) {
        return getBlockElement(parent, this.el)
      }

      return null
    }

    save (range = this.range) {
      if (range !== null) {
        this._range = range;
      }
    }

    restore (range = this._range) {
      const
        r = document.createRange(),
        sel = document.getSelection();

      if (range !== null) {
        r.setStart(range.startContainer, range.startOffset);
        r.setEnd(range.endContainer, range.endOffset);
        sel.removeAllRanges();
        sel.addRange(r);
      }
      else {
        sel.selectAllChildren(this.el);
        sel.collapseToEnd();
      }
    }

    savePosition () {
      let charCount = -1, node;
      const
        selection = document.getSelection(),
        parentEl = this.el.parentNode;

      if (selection.focusNode && isChildOf(selection.focusNode, parentEl)) {
        node = selection.focusNode;
        charCount = selection.focusOffset;

        while (node && node !== parentEl) {
          if (node !== this.el && node.previousSibling) {
            node = node.previousSibling;
            charCount += node.textContent.length;
          }
          else {
            node = node.parentNode;
          }
        }
      }

      this.savedPos = charCount;
    }

    restorePosition (length = 0) {
      if (this.savedPos > 0 && this.savedPos < length) {
        const
          selection = window.getSelection(),
          range = createRange(this.el, { count: this.savedPos });

        if (range) {
          range.collapse(false);
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }
    }

    hasParent (name, spanLevel) {
      const el = spanLevel
        ? this.parent
        : this.blockParent;

      return el !== null
        ? el.nodeName.toLowerCase() === name.toLowerCase()
        : false
    }

    hasParents (list, recursive, el = this.parent) {
      if (el === null) {
        return false
      }

      if (el !== null && list.includes(el.nodeName.toLowerCase()) === true) {
        return true
      }

      return recursive === true
        ? this.hasParents(list, recursive, el.parentNode)
        : false
    }

    is (cmd, param) {
      if (this.selection === null) {
        return false
      }

      switch (cmd) {
        case 'formatBlock':
          return (param === 'DIV' && this.parent === this.el)
            || this.hasParent(param, param === 'PRE')
        case 'link':
          return this.hasParent('A', true)
        case 'fontSize':
          return document.queryCommandValue(cmd) === param
        case 'fontName':
          const res = document.queryCommandValue(cmd);
          return res === `"${ param }"` || res === param
        case 'fullscreen':
          return this.eVm.inFullscreen.value
        case 'viewsource':
          return this.eVm.isViewingSource.value
        case void 0:
          return false
        default:
          const state = document.queryCommandState(cmd);
          return param !== void 0 ? state === param : state
      }
    }

    getParentAttribute (attrib) {
      if (this.parent !== null) {
        return this.parent.getAttribute(attrib)
      }

      return null
    }

    can (name) {
      if (name === 'outdent') {
        return this.hasParents([ 'blockquote', 'li' ], true)
      }

      if (name === 'indent') {
        return this.hasParents([ 'li' ], true)
      }

      if (name === 'link') {
        return this.selection !== null || this.is('link')
      }
    }

    apply (cmd, param, done = noop) {
      if (cmd === 'formatBlock') {
        if ([ 'BLOCKQUOTE', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6' ].includes(param) && this.is(cmd, param)) {
          cmd = 'outdent';
          param = null;
        }

        if (param === 'PRE' && this.is(cmd, 'PRE')) {
          param = 'P';
        }
      }
      else if (cmd === 'print') {
        done();

        const win = window.open();

        win.document.write(`
        <!doctype html>
        <html>
          <head>
            <title>Print - ${ document.title }</title>
          </head>
          <body>
            <div>${ this.el.innerHTML }</div>
          </body>
        </html>
      `);
        win.print();
        win.close();

        return
      }
      else if (cmd === 'link') {
        const link = this.getParentAttribute('href');

        if (link === null) {
          const selection = this.selectWord(this.selection);
          const url = selection ? selection.toString() : '';

          if (!url.length) {
            if (!this.range || !this.range.cloneContents().querySelector('img')) {
              return
            }
          }

          this.eVm.editLinkUrl.value = urlRegex.test(url) ? url : 'https://';
          document.execCommand('createLink', false, this.eVm.editLinkUrl.value);

          this.save(selection.getRangeAt(0));
        }
        else {
          this.eVm.editLinkUrl.value = link;

          this.range.selectNodeContents(this.parent);
          this.save();
        }

        return
      }
      else if (cmd === 'fullscreen') {
        this.eVm.toggleFullscreen();
        done();

        return
      }
      else if (cmd === 'viewsource') {
        this.eVm.isViewingSource.value = this.eVm.isViewingSource.value === false;
        this.eVm.setContent(this.eVm.props.modelValue);
        done();

        return
      }

      document.execCommand(cmd, false, param);

      done();
    }

    selectWord (sel) {
      if (sel === null || sel.isCollapsed !== true || /* IE 11 */ sel.modify === void 0) {
        return sel
      }

      // Detect if selection is backwards
      const range = document.createRange();
      range.setStart(sel.anchorNode, sel.anchorOffset);
      range.setEnd(sel.focusNode, sel.focusOffset);
      const direction = range.collapsed ? [ 'backward', 'forward' ] : [ 'forward', 'backward' ];
      range.detach();

      // modify() works on the focus of the selection
      const
        endNode = sel.focusNode,
        endOffset = sel.focusOffset;
      sel.collapse(sel.anchorNode, sel.anchorOffset);
      sel.modify('move', direction[ 0 ], 'character');
      sel.modify('move', direction[ 1 ], 'word');
      sel.extend(endNode, endOffset);
      sel.modify('extend', direction[ 1 ], 'character');
      sel.modify('extend', direction[ 0 ], 'word');

      return sel
    }
  }

  var QTooltip = vue.defineComponent({
    name: 'QTooltip',

    inheritAttrs: false,

    props: {
      ...useAnchorProps,
      ...useModelToggleProps,
      ...useTransitionProps,

      maxHeight: {
        type: String,
        default: null
      },
      maxWidth: {
        type: String,
        default: null
      },

      transitionShow: {
        default: 'jump-down'
      },
      transitionHide: {
        default: 'jump-up'
      },

      anchor: {
        type: String,
        default: 'bottom middle',
        validator: validatePosition
      },
      self: {
        type: String,
        default: 'top middle',
        validator: validatePosition
      },
      offset: {
        type: Array,
        default: () => [ 14, 14 ],
        validator: validateOffset
      },

      scrollTarget: {
        default: void 0
      },

      delay: {
        type: Number,
        default: 0
      },

      hideDelay: {
        type: Number,
        default: 0
      }
    },

    emits: [
      ...useModelToggleEmits
    ],

    setup (props, { slots, emit, attrs }) {
      let unwatchPosition, observer;

      const vm = vue.getCurrentInstance();
      const { proxy: { $q } } = vm;

      const innerRef = vue.ref(null);
      const showing = vue.ref(false);

      const anchorOrigin = vue.computed(() => parsePosition(props.anchor, $q.lang.rtl));
      const selfOrigin = vue.computed(() => parsePosition(props.self, $q.lang.rtl));
      const hideOnRouteChange = vue.computed(() => props.persistent !== true);

      const { registerTick, removeTick, prepareTick } = useTick();
      const { registerTimeout, removeTimeout } = useTimeout();
      const { transition, transitionStyle } = useTransition(props, showing);
      const { localScrollTarget, changeScrollEvent, unconfigureScrollTarget } = useScrollTarget(props, configureScrollTarget);

      const { anchorEl, canShow, anchorEvents } = useAnchor({ showing, configureAnchorEl });

      const { show, hide } = useModelToggle({
        showing, canShow, handleShow, handleHide,
        hideOnRouteChange,
        processOnMount: true
      });

      Object.assign(anchorEvents, { delayShow, delayHide });

      const { showPortal, hidePortal, renderPortal } = usePortal(vm, innerRef, renderPortalContent);

      // if we're on mobile, let's improve the experience
      // by closing it when user taps outside of it
      if ($q.platform.is.mobile === true) {
        const clickOutsideProps = {
          anchorEl,
          innerRef,
          onClickOutside (e) {
            hide(e);

            // prevent click if it's on a dialog backdrop
            if (e.target.classList.contains('q-dialog__backdrop')) {
              stopAndPrevent(e);
            }

            return true
          }
        };

        const hasClickOutside = vue.computed(() =>
          // it doesn't has external model
          // (null is the default value)
          props.modelValue === null
          // and it's not persistent
          && props.persistent !== true
          && showing.value === true
        );

        vue.watch(hasClickOutside, val => {
          const fn = val === true ? addClickOutside : removeClickOutside;
          fn(clickOutsideProps);
        });

        vue.onBeforeUnmount(() => {
          removeClickOutside(clickOutsideProps);
        });
      }

      function handleShow (evt) {
        removeTick();
        removeTimeout();

        showPortal();

        registerTick(() => {
          observer = new MutationObserver(() => updatePosition());
          observer.observe(innerRef.value, { attributes: false, childList: true, characterData: true, subtree: true });
          updatePosition();
          configureScrollTarget();
        });
        prepareTick();

        if (unwatchPosition === void 0) {
          unwatchPosition = vue.watch(
            () => $q.screen.width + '|' + $q.screen.height + '|' + props.self + '|' + props.anchor + '|' + $q.lang.rtl,
            updatePosition
          );
        }

        registerTimeout(() => {
          showPortal(true); // done showing portal
          emit('show', evt);
        }, props.transitionDuration);
      }

      function handleHide (evt) {
        removeTick();
        removeTimeout();

        anchorCleanup();

        registerTimeout(() => {
          hidePortal();
          emit('hide', evt);
        }, props.transitionDuration);
      }

      function anchorCleanup () {
        if (observer !== void 0) {
          observer.disconnect();
          observer = void 0;
        }

        if (unwatchPosition !== void 0) {
          unwatchPosition();
          unwatchPosition = void 0;
        }

        unconfigureScrollTarget();
        cleanEvt(anchorEvents, 'tooltipTemp');
      }

      function updatePosition () {
        const el = innerRef.value;

        if (anchorEl.value === void 0 || !el) {
          return
        }

        setPosition({
          el,
          offset: props.offset,
          anchorEl: anchorEl.value,
          anchorOrigin: anchorOrigin.value,
          selfOrigin: selfOrigin.value,
          maxHeight: props.maxHeight,
          maxWidth: props.maxWidth
        });
      }

      function delayShow (evt) {
        if ($q.platform.is.mobile === true) {
          clearSelection();
          document.body.classList.add('non-selectable');

          const target = getTouchTarget(anchorEl.value);
          const evts = [ 'touchmove', 'touchcancel', 'touchend', 'click' ]
            .map(e => ([ target, e, '__delayHide', 'passiveCapture' ]));

          addEvt(anchorEvents, 'tooltipTemp', evts);
        }

        registerTimeout(() => {
          show(evt);
        }, props.delay);
      }

      function delayHide (evt) {
        removeTimeout();

        if ($q.platform.is.mobile === true) {
          cleanEvt(anchorEvents, 'tooltipTemp');
          clearSelection();
          // delay needed otherwise selection still occurs
          setTimeout(() => {
            document.body.classList.remove('non-selectable');
          }, 10);
        }

        registerTimeout(() => {
          hide(evt);
        }, props.hideDelay);
      }

      function configureAnchorEl () {
        if (props.noParentEvent === true || anchorEl.value === void 0) { return }

        const evts = $q.platform.is.mobile === true
          ? [
              [ anchorEl.value, 'touchstart', 'delayShow', 'passive' ]
            ]
          : [
              [ anchorEl.value, 'mouseenter', 'delayShow', 'passive' ],
              [ anchorEl.value, 'mouseleave', 'delayHide', 'passive' ]
            ];

        addEvt(anchorEvents, 'anchor', evts);
      }

      function configureScrollTarget () {
        if (anchorEl.value !== void 0 || props.scrollTarget !== void 0) {
          localScrollTarget.value = getScrollTarget(anchorEl.value, props.scrollTarget);
          const fn = props.noParentEvent === true
            ? updatePosition
            : hide;

          changeScrollEvent(localScrollTarget.value, fn);
        }
      }

      function getTooltipContent () {
        return showing.value === true
          ? vue.h('div', {
              ...attrs,
              ref: innerRef,
              class: [
                'q-tooltip q-tooltip--style q-position-engine no-pointer-events',
                attrs.class
              ],
              style: transitionStyle.value,
              role: 'complementary'
            }, hSlot(slots.default))
          : null
      }

      function renderPortalContent () {
        return vue.h(vue.Transition, {
          name: transition.value,
          appear: true
        }, getTooltipContent)
      }

      vue.onBeforeUnmount(anchorCleanup);

      // expose public methods
      Object.assign(vm.proxy, { updatePosition });

      return renderPortal
    }
  });

  var QItem = vue.defineComponent({
    name: 'QItem',

    props: {
      ...useDarkProps,
      ...useRouterLinkProps,

      tag: {
        type: String,
        default: 'div'
      },

      active: Boolean,

      clickable: Boolean,
      dense: Boolean,
      insetLevel: Number,

      tabindex: [ String, Number ],

      focused: Boolean,
      manualFocus: Boolean
    },

    emits: [ 'click', 'keyup' ],

    setup (props, { slots, emit }) {
      const { proxy: { $q } } = vue.getCurrentInstance();

      const isDark = useDark(props, $q);
      const { hasLink, linkProps, linkClass, linkTag, navigateToLink } = useRouterLink();

      const rootRef = vue.ref(null);
      const blurTargetRef = vue.ref(null);

      const isActionable = vue.computed(() =>
        props.clickable === true
          || hasLink.value === true
          || props.tag === 'a'
          || props.tag === 'label'
      );

      const isClickable = vue.computed(() =>
        props.disable !== true && isActionable.value === true
      );

      const classes = vue.computed(() =>
        'q-item q-item-type row no-wrap'
        + (props.dense === true ? ' q-item--dense' : '')
        + (isDark.value === true ? ' q-item--dark' : '')
        + (
          hasLink.value === true
            ? linkClass.value
            : (
                props.active === true
                  ? `${ props.activeClass !== void 0 ? ` ${ props.activeClass }` : '' } q-item--active`
                  : ''
              )
        )
        + (props.disable === true ? ' disabled' : '')
        + (
          isClickable.value === true
            ? ' q-item--clickable q-link cursor-pointer '
              + (props.manualFocus === true ? 'q-manual-focusable' : 'q-focusable q-hoverable')
              + (props.focused === true ? ' q-manual-focusable--focused' : '')
            : ''
        )
      );

      const style = vue.computed(() => {
        if (props.insetLevel === void 0) {
          return null
        }

        const dir = $q.lang.rtl === true ? 'Right' : 'Left';
        return {
          [ 'padding' + dir ]: (16 + props.insetLevel * 56) + 'px'
        }
      });

      function onClick (e) {
        if (isClickable.value === true) {
          if (blurTargetRef.value !== null) {
            if (e.qKeyEvent !== true && document.activeElement === rootRef.value) {
              blurTargetRef.value.focus();
            }
            else if (document.activeElement === blurTargetRef.value) {
              rootRef.value.focus();
            }
          }

          hasLink.value === true && navigateToLink(e);
          emit('click', e);
        }
      }

      function onKeyup (e) {
        if (isClickable.value === true && isKeyCode(e, 13) === true) {
          stopAndPrevent(e);

          // for ripple
          e.qKeyEvent = true;

          // for click trigger
          const evt = new MouseEvent('click', e);
          evt.qKeyEvent = true;
          rootRef.value.dispatchEvent(evt);
        }

        emit('keyup', e);
      }

      function getContent () {
        const child = hUniqueSlot(slots.default, []);

        isClickable.value === true && child.unshift(
          vue.h('div', { class: 'q-focus-helper', tabindex: -1, ref: blurTargetRef })
        );

        return child
      }

      return () => {
        const data = {
          ref: rootRef,
          class: classes.value,
          style: style.value,
          onClick,
          onKeyup
        };

        if (isClickable.value === true) {
          data.tabindex = props.tabindex || '0';
          Object.assign(data, linkProps.value);
        }
        else if (isActionable.value === true) {
          data[ 'aria-disabled' ] = 'true';
        }

        return vue.h(
          linkTag.value,
          data,
          getContent()
        )
      }
    }
  });

  var QItemSection = vue.defineComponent({
    name: 'QItemSection',

    props: {
      avatar: Boolean,
      thumbnail: Boolean,
      side: Boolean,
      top: Boolean,
      noWrap: Boolean
    },

    setup (props, { slots }) {
      const classes = vue.computed(() =>
        'q-item__section column'
        + ` q-item__section--${ props.avatar === true || props.side === true || props.thumbnail === true ? 'side' : 'main' }`
        + (props.top === true ? ' q-item__section--top justify-start' : ' justify-center')
        + (props.avatar === true ? ' q-item__section--avatar' : '')
        + (props.thumbnail === true ? ' q-item__section--thumbnail' : '')
        + (props.noWrap === true ? ' q-item__section--nowrap' : '')
      );

      return () => vue.h('div', { class: classes.value }, hSlot(slots.default))
    }
  });

  function run (e, btn, eVm) {
    if (btn.handler) {
      btn.handler(e, eVm, eVm.caret);
    }
    else {
      eVm.runCmd(btn.cmd, btn.param);
    }
  }

  function getGroup (children) {
    return vue.h('div', { class: 'q-editor__toolbar-group' }, children)
  }

  function getBtn (eVm, btn, clickHandler, active = false) {
    const
      toggled = active || (btn.type === 'toggle'
        ? (btn.toggled ? btn.toggled(eVm) : btn.cmd && eVm.caret.is(btn.cmd, btn.param))
        : false),
      child = [];

    if (btn.tip && eVm.$q.platform.is.desktop) {
      const Key = btn.key
        ? vue.h('div', [
            vue.h('small', `(CTRL + ${ String.fromCharCode(btn.key) })`)
          ])
        : null;
      child.push(
        vue.h(QTooltip, { delay: 1000 }, () => [
          vue.h('div', { innerHTML: btn.tip }),
          Key
        ])
      );
    }

    return vue.h(QBtn, {
      ...eVm.buttonProps.value,
      icon: btn.icon !== null ? btn.icon : void 0,
      color: toggled ? btn.toggleColor || eVm.props.toolbarToggleColor : btn.color || eVm.props.toolbarColor,
      textColor: toggled && !eVm.props.toolbarPush ? null : btn.textColor || eVm.props.toolbarTextColor,
      label: btn.label,
      disable: btn.disable ? (typeof btn.disable === 'function' ? btn.disable(eVm) : true) : false,
      size: 'sm',
      onClick (e) {
        clickHandler && clickHandler();
        run(e, btn, eVm);
      }
    }, () => child)
  }

  function getDropdown (eVm, btn) {
    const onlyIcons = btn.list === 'only-icons';
    let
      label = btn.label,
      icon = btn.icon !== null ? btn.icon : void 0,
      contentClass,
      Items;

    function closeDropdown () {
      Dropdown.component.proxy.hide();
    }

    if (onlyIcons) {
      Items = btn.options.map(btn => {
        const active = btn.type === void 0
          ? eVm.caret.is(btn.cmd, btn.param)
          : false;

        if (active) {
          label = btn.tip;
          icon = btn.icon !== null ? btn.icon : void 0;
        }
        return getBtn(eVm, btn, closeDropdown, active)
      });
      contentClass = eVm.toolbarBackgroundClass.value;
      Items = [
        getGroup(Items)
      ];
    }
    else {
      const activeClass = eVm.props.toolbarToggleColor !== void 0
        ? `text-${ eVm.props.toolbarToggleColor }`
        : null;
      const inactiveClass = eVm.props.toolbarTextColor !== void 0
        ? `text-${ eVm.props.toolbarTextColor }`
        : null;

      const noIcons = btn.list === 'no-icons';

      Items = btn.options.map(btn => {
        const disable = btn.disable ? btn.disable(eVm) : false;
        const active = btn.type === void 0
          ? eVm.caret.is(btn.cmd, btn.param)
          : false;

        if (active) {
          label = btn.tip;
          icon = btn.icon !== null ? btn.icon : void 0;
        }

        const htmlTip = btn.htmlTip;

        return vue.h(QItem, {
          active,
          activeClass,
          clickable: true,
          disable,
          dense: true,
          onClick (e) {
            closeDropdown();
            eVm.contentRef.value !== null && eVm.contentRef.value.focus();
            eVm.caret.restore();
            run(e, btn, eVm);
          }
        }, () => [
          noIcons === true
            ? null
            : vue.h(
              QItemSection,
              {
                class: active ? activeClass : inactiveClass,
                side: true
              },
              () => vue.h(QIcon, { name: btn.icon !== null ? btn.icon : void 0 })
            ),

          vue.h(
            QItemSection,
            htmlTip
              ? () => vue.h('div', { class: 'text-no-wrap', innerHTML: btn.htmlTip })
              : (btn.tip ? () => vue.h('div', { class: 'text-no-wrap' }, btn.tip) : void 0)
          )
        ])
      });
      contentClass = [ eVm.toolbarBackgroundClass.value, inactiveClass ];
    }

    const highlight = btn.highlight && label !== btn.label;
    const Dropdown = vue.h(QBtnDropdown, {
      ...eVm.buttonProps.value,
      noCaps: true,
      noWrap: true,
      color: highlight ? eVm.props.toolbarToggleColor : eVm.props.toolbarColor,
      textColor: highlight && !eVm.props.toolbarPush ? null : eVm.props.toolbarTextColor,
      label: btn.fixedLabel ? btn.label : label,
      icon: btn.fixedIcon ? (btn.icon !== null ? btn.icon : void 0) : icon,
      contentClass
    }, () => Items);

    return Dropdown
  }

  function getToolbar (eVm) {
    if (eVm.caret) {
      return eVm.buttons.value
        .filter(f => {
          return !eVm.isViewingSource.value || f.find(fb => fb.cmd === 'viewsource')
        })
        .map(group => getGroup(
          group.map(btn => {
            if (eVm.isViewingSource.value && btn.cmd !== 'viewsource') {
              return false
            }

            if (btn.type === 'slot') {
              return hSlot(eVm.slots[ btn.slot ])
            }

            if (btn.type === 'dropdown') {
              return getDropdown(eVm, btn)
            }

            return getBtn(eVm, btn)
          })
        ))
    }
  }

  function getFonts (defaultFont, defaultFontLabel, defaultFontIcon, fonts = {}) {
    const aliases = Object.keys(fonts);
    if (aliases.length === 0) {
      return {}
    }

    const def = {
      default_font: {
        cmd: 'fontName',
        param: defaultFont,
        icon: defaultFontIcon,
        tip: defaultFontLabel
      }
    };

    aliases.forEach(alias => {
      const name = fonts[ alias ];
      def[ alias ] = {
        cmd: 'fontName',
        param: name,
        icon: defaultFontIcon,
        tip: name,
        htmlTip: `<font face="${ name }">${ name }</font>`
      };
    });

    return def
  }

  function getLinkEditor (eVm) {
    if (eVm.caret) {
      const color = eVm.props.toolbarColor || eVm.props.toolbarTextColor;
      let link = eVm.editLinkUrl.value;
      const updateLink = () => {
        eVm.caret.restore();

        if (link !== eVm.editLinkUrl.value) {
          document.execCommand('createLink', false, link === '' ? ' ' : link);
        }

        eVm.editLinkUrl.value = null;
      };

      return [
        vue.h('div', { class: `q-mx-xs text-${ color }` }, `${ eVm.$q.lang.editor.url }: `),
        vue.h('input', {
          key: 'qedt_btm_input',
          class: 'col q-editor__link-input',
          value: link,
          onInput: evt => {
            stop(evt);
            link = evt.target.value;
          },
          onKeydown: evt => {
            if (shouldIgnoreKey(evt) === true) {
              return
            }

            switch (evt.keyCode) {
              case 13: // ENTER key
                prevent(evt);
                return updateLink()
              case 27: // ESCAPE key
                prevent(evt);
                eVm.caret.restore();
                if (!eVm.editLinkUrl.value || eVm.editLinkUrl.value === 'https://') {
                  document.execCommand('unlink');
                }
                eVm.editLinkUrl.value = null;
                break
            }
          }
        }),
        getGroup([
          vue.h(QBtn, {
            key: 'qedt_btm_rem',
            tabindex: -1,
            ...eVm.buttonProps.value,
            label: eVm.$q.lang.label.remove,
            noCaps: true,
            onClick: () => {
              eVm.caret.restore();
              document.execCommand('unlink');
              eVm.editLinkUrl.value = null;
            }
          }),
          vue.h(QBtn, {
            key: 'qedt_btm_upd',
            ...eVm.buttonProps.value,
            label: eVm.$q.lang.label.update,
            noCaps: true,
            onClick: updateLink
          })
        ])
      ]
    }
  }

  const listenerRE = /^on[A-Z]/;

  function useSplitAttrs (attrs) {
    const acc = {
      listeners: vue.ref({}),
      attributes: vue.ref({})
    };

    function update () {
      const listeners = {};
      const attributes = {};

      Object.keys(attrs).forEach(key => {
        if (listenerRE.test(key) === true) {
          listeners[ key ] = attrs[ key ];
        }
        else if (key !== 'class' && key !== 'style') {
          attributes[ key ] = attrs[ key ];
        }
      });

      acc.listeners.value = listeners;
      acc.attributes.value = attributes;
    }

    vue.onBeforeUpdate(update);

    update();

    return acc
  }

  const
    toString = Object.prototype.toString,
    hasOwn = Object.prototype.hasOwnProperty,
    class2type = {};

  'Boolean Number String Function Array Date RegExp Object'.split(' ').forEach(name => {
    class2type[ '[object ' + name + ']' ] = name.toLowerCase();
  });

  function type (obj) {
    return obj === null ? String(obj) : class2type[ toString.call(obj) ] || 'object'
  }

  function isPlainObject (obj) {
    if (!obj || type(obj) !== 'object') {
      return false
    }

    if (obj.constructor
      && !hasOwn.call(obj, 'constructor')
      && !hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
      return false
    }

    let key;
    for (key in obj) {} // eslint-disable-line

    return key === undefined || hasOwn.call(obj, key)
  }

  function extend () {
    let
      options, name, src, copy, copyIsArray, clone,
      target = arguments[ 0 ] || {},
      i = 1,
      deep = false;
    const length = arguments.length;

    if (typeof target === 'boolean') {
      deep = target;
      target = arguments[ 1 ] || {};
      i = 2;
    }

    if (Object(target) !== target && type(target) !== 'function') {
      target = {};
    }

    if (length === i) {
      target = this;
      i--;
    }

    for (; i < length; i++) {
      if ((options = arguments[ i ]) !== null) {
        for (name in options) {
          src = target[ name ];
          copy = options[ name ];

          if (target === copy) {
            continue
          }

          if (deep && copy && (isPlainObject(copy) || (copyIsArray = type(copy) === 'array'))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && type(src) === 'array' ? src : [];
            }
            else {
              clone = src && isPlainObject(src) ? src : {};
            }

            target[ name ] = extend(deep, clone, copy);
          }
          else if (copy !== undefined) {
            target[ name ] = copy;
          }
        }
      }
    }

    return target
  }

  var QEditor = vue.defineComponent({
    name: 'QEditor',

    props: {
      ...useDarkProps,
      ...useFullscreenProps,

      modelValue: {
        type: String,
        required: true
      },
      readonly: Boolean,
      disable: Boolean,
      minHeight: {
        type: String,
        default: '10rem'
      },
      maxHeight: String,
      height: String,
      definitions: Object,
      fonts: Object,
      placeholder: String,

      toolbar: {
        type: Array,
        validator: v => v.length === 0 || v.every(group => group.length),
        default () {
          return [
            [ 'left', 'center', 'right', 'justify' ],
            [ 'bold', 'italic', 'underline', 'strike' ],
            [ 'undo', 'redo' ]
          ]
        }
      },
      toolbarColor: String,
      toolbarBg: String,
      toolbarTextColor: String,
      toolbarToggleColor: {
        type: String,
        default: 'primary'
      },
      toolbarOutline: Boolean,
      toolbarPush: Boolean,
      toolbarRounded: Boolean,

      paragraphTag: {
        type: String,
        validator: v => [ 'div', 'p' ].includes(v),
        default: 'div'
      },

      contentStyle: Object,
      contentClass: [ Object, Array, String ],

      square: Boolean,
      flat: Boolean,
      dense: Boolean
    },

    emits: [
      ...useFullscreenEmits,
      'update:modelValue',
      'keydown', 'click', 'mouseup', 'keyup', 'touchend',
      'focus', 'blur'
    ],

    setup (props, { slots, emit, attrs }) {
      const { proxy } = vue.getCurrentInstance();
      const { $q } = proxy;

      const isDark = useDark(props, $q);
      const { inFullscreen, toggleFullscreen } = useFullscreen();
      const splitAttrs = useSplitAttrs(attrs);

      const rootRef = vue.ref(null);
      const contentRef = vue.ref(null);

      const editLinkUrl = vue.ref(null);
      const isViewingSource = vue.ref(false);

      const editable = vue.computed(() => !props.readonly && !props.disable);

      let defaultFont, offsetBottom;
      let lastEmit = props.modelValue; // eslint-disable-line

      {
        document.execCommand('defaultParagraphSeparator', false, props.paragraphTag);
        defaultFont = window.getComputedStyle(document.body).fontFamily;
      }

      const toolbarBackgroundClass = vue.computed(() => (
        props.toolbarBg ? ` bg-${ props.toolbarBg }` : ''
      ));

      const buttonProps = vue.computed(() => {
        const flat = props.toolbarOutline !== true
          && props.toolbarPush !== true;

        return {
          type: 'a',
          flat,
          noWrap: true,
          outline: props.toolbarOutline,
          push: props.toolbarPush,
          rounded: props.toolbarRounded,
          dense: true,
          color: props.toolbarColor,
          disable: !editable.value,
          size: 'sm'
        }
      });

      const buttonDef = vue.computed(() => {
        const
          e = $q.lang.editor,
          i = $q.iconSet.editor;

        return {
          bold: { cmd: 'bold', icon: i.bold, tip: e.bold, key: 66 },
          italic: { cmd: 'italic', icon: i.italic, tip: e.italic, key: 73 },
          strike: { cmd: 'strikeThrough', icon: i.strikethrough, tip: e.strikethrough, key: 83 },
          underline: { cmd: 'underline', icon: i.underline, tip: e.underline, key: 85 },
          unordered: { cmd: 'insertUnorderedList', icon: i.unorderedList, tip: e.unorderedList },
          ordered: { cmd: 'insertOrderedList', icon: i.orderedList, tip: e.orderedList },
          subscript: { cmd: 'subscript', icon: i.subscript, tip: e.subscript, htmlTip: 'x<subscript>2</subscript>' },
          superscript: { cmd: 'superscript', icon: i.superscript, tip: e.superscript, htmlTip: 'x<superscript>2</superscript>' },
          link: { cmd: 'link', disable: eVm => eVm.caret && !eVm.caret.can('link'), icon: i.hyperlink, tip: e.hyperlink, key: 76 },
          fullscreen: { cmd: 'fullscreen', icon: i.toggleFullscreen, tip: e.toggleFullscreen, key: 70 },
          viewsource: { cmd: 'viewsource', icon: i.viewSource, tip: e.viewSource },

          quote: { cmd: 'formatBlock', param: 'BLOCKQUOTE', icon: i.quote, tip: e.quote, key: 81 },
          left: { cmd: 'justifyLeft', icon: i.left, tip: e.left },
          center: { cmd: 'justifyCenter', icon: i.center, tip: e.center },
          right: { cmd: 'justifyRight', icon: i.right, tip: e.right },
          justify: { cmd: 'justifyFull', icon: i.justify, tip: e.justify },

          print: { type: 'no-state', cmd: 'print', icon: i.print, tip: e.print, key: 80 },
          outdent: { type: 'no-state', disable: eVm => eVm.caret && !eVm.caret.can('outdent'), cmd: 'outdent', icon: i.outdent, tip: e.outdent },
          indent: { type: 'no-state', disable: eVm => eVm.caret && !eVm.caret.can('indent'), cmd: 'indent', icon: i.indent, tip: e.indent },
          removeFormat: { type: 'no-state', cmd: 'removeFormat', icon: i.removeFormat, tip: e.removeFormat },
          hr: { type: 'no-state', cmd: 'insertHorizontalRule', icon: i.hr, tip: e.hr },
          undo: { type: 'no-state', cmd: 'undo', icon: i.undo, tip: e.undo, key: 90 },
          redo: { type: 'no-state', cmd: 'redo', icon: i.redo, tip: e.redo, key: 89 },

          h1: { cmd: 'formatBlock', param: 'H1', icon: i.heading1 || i.heading, tip: e.heading1, htmlTip: `<h1 class="q-ma-none">${ e.heading1 }</h1>` },
          h2: { cmd: 'formatBlock', param: 'H2', icon: i.heading2 || i.heading, tip: e.heading2, htmlTip: `<h2 class="q-ma-none">${ e.heading2 }</h2>` },
          h3: { cmd: 'formatBlock', param: 'H3', icon: i.heading3 || i.heading, tip: e.heading3, htmlTip: `<h3 class="q-ma-none">${ e.heading3 }</h3>` },
          h4: { cmd: 'formatBlock', param: 'H4', icon: i.heading4 || i.heading, tip: e.heading4, htmlTip: `<h4 class="q-ma-none">${ e.heading4 }</h4>` },
          h5: { cmd: 'formatBlock', param: 'H5', icon: i.heading5 || i.heading, tip: e.heading5, htmlTip: `<h5 class="q-ma-none">${ e.heading5 }</h5>` },
          h6: { cmd: 'formatBlock', param: 'H6', icon: i.heading6 || i.heading, tip: e.heading6, htmlTip: `<h6 class="q-ma-none">${ e.heading6 }</h6>` },
          p: { cmd: 'formatBlock', param: props.paragraphTag, icon: i.heading, tip: e.paragraph },
          code: { cmd: 'formatBlock', param: 'PRE', icon: i.code, htmlTip: `<code>${ e.code }</code>` },

          'size-1': { cmd: 'fontSize', param: '1', icon: i.size1 || i.size, tip: e.size1, htmlTip: `<font size="1">${ e.size1 }</font>` },
          'size-2': { cmd: 'fontSize', param: '2', icon: i.size2 || i.size, tip: e.size2, htmlTip: `<font size="2">${ e.size2 }</font>` },
          'size-3': { cmd: 'fontSize', param: '3', icon: i.size3 || i.size, tip: e.size3, htmlTip: `<font size="3">${ e.size3 }</font>` },
          'size-4': { cmd: 'fontSize', param: '4', icon: i.size4 || i.size, tip: e.size4, htmlTip: `<font size="4">${ e.size4 }</font>` },
          'size-5': { cmd: 'fontSize', param: '5', icon: i.size5 || i.size, tip: e.size5, htmlTip: `<font size="5">${ e.size5 }</font>` },
          'size-6': { cmd: 'fontSize', param: '6', icon: i.size6 || i.size, tip: e.size6, htmlTip: `<font size="6">${ e.size6 }</font>` },
          'size-7': { cmd: 'fontSize', param: '7', icon: i.size7 || i.size, tip: e.size7, htmlTip: `<font size="7">${ e.size7 }</font>` }
        }
      });

      const buttons = vue.computed(() => {
        const userDef = props.definitions || {};
        const def = props.definitions || props.fonts
          ? extend(
              true,
              {},
              buttonDef.value,
              userDef,
              getFonts(
                defaultFont,
                $q.lang.editor.defaultFont,
                $q.iconSet.editor.font,
                props.fonts
              )
            )
          : buttonDef.value;

        return props.toolbar.map(
          group => group.map(token => {
            if (token.options) {
              return {
                type: 'dropdown',
                icon: token.icon,
                label: token.label,
                size: 'sm',
                dense: true,
                fixedLabel: token.fixedLabel,
                fixedIcon: token.fixedIcon,
                highlight: token.highlight,
                list: token.list,
                options: token.options.map(item => def[ item ])
              }
            }

            const obj = def[ token ];

            if (obj) {
              return obj.type === 'no-state' || (userDef[ token ] && (
                obj.cmd === void 0 || (buttonDef.value[ obj.cmd ] && buttonDef.value[ obj.cmd ].type === 'no-state')
              ))
                ? obj
                : Object.assign({ type: 'toggle' }, obj)
            }
            else {
              return {
                type: 'slot',
                slot: token
              }
            }
          })
        )
      });

      const eVm = {
        $q,
        props,
        slots,
        // caret (will get injected after mount)
        inFullscreen,
        toggleFullscreen,
        runCmd,
        isViewingSource,
        editLinkUrl,
        toolbarBackgroundClass,
        buttonProps,
        contentRef,
        buttons,
        setContent
      };

      vue.watch(() => props.modelValue, v => {
        if (lastEmit !== v) {
          lastEmit = v;
          setContent(v, true);
        }
      });

      const hasToolbar = vue.computed(() => props.toolbar && props.toolbar.length > 0);

      const keys = vue.computed(() => {
        const
          k = {},
          add = btn => {
            if (btn.key) {
              k[ btn.key ] = {
                cmd: btn.cmd,
                param: btn.param
              };
            }
          };

        buttons.value.forEach(group => {
          group.forEach(token => {
            if (token.options) {
              token.options.forEach(add);
            }
            else {
              add(token);
            }
          });
        });
        return k
      });

      const innerStyle = vue.computed(() => (
        inFullscreen.value
          ? props.contentStyle
          : [
              {
                minHeight: props.minHeight,
                height: props.height,
                maxHeight: props.maxHeight
              },
              props.contentStyle
            ]
      ));

      const classes = vue.computed(() =>
        `q-editor q-editor--${ isViewingSource.value === true ? 'source' : 'default' }`
        + (props.disable === true ? ' disabled' : '')
        + (inFullscreen.value === true ? ' fullscreen column' : '')
        + (props.square === true ? ' q-editor--square no-border-radius' : '')
        + (props.flat === true ? ' q-editor--flat' : '')
        + (props.dense === true ? ' q-editor--dense' : '')
        + (isDark.value === true ? ' q-editor--dark q-dark' : '')
      );

      const innerClass = vue.computed(() => ([
        props.contentClass,
        'q-editor__content',
        { col: inFullscreen.value, 'overflow-auto': inFullscreen.value || props.maxHeight }
      ]));

      const attributes = vue.computed(() => (
        props.disable === true
          ? { 'aria-disabled': 'true' }
          : (props.readonly === true ? { 'aria-readonly': 'true' } : {})
      ));

      function onInput () {
        if (contentRef.value !== null) {
          const prop = `inner${ isViewingSource.value === true ? 'Text' : 'HTML' }`;
          const val = contentRef.value[ prop ];

          if (val !== props.modelValue) {
            lastEmit = val;
            emit('update:modelValue', val);
          }
        }
      }

      function onKeydown (e) {
        emit('keydown', e);

        if (e.ctrlKey !== true || shouldIgnoreKey(e) === true) {
          refreshToolbar();
          return
        }

        const key = e.keyCode;
        const target = keys.value[ key ];
        if (target !== void 0) {
          const { cmd, param } = target;
          stopAndPrevent(e);
          runCmd(cmd, param, false);
        }
      }

      function onClick (e) {
        refreshToolbar();
        emit('click', e);
      }

      function onBlur (e) {
        if (contentRef.value !== null) {
          const { scrollTop, scrollHeight } = contentRef.value;
          offsetBottom = scrollHeight - scrollTop;
        }
        eVm.caret.save();
        emit('blur', e);
      }

      function onFocus (e) {
        vue.nextTick(() => {
          if (contentRef.value !== null && offsetBottom !== void 0) {
            contentRef.value.scrollTop = contentRef.value.scrollHeight - offsetBottom;
          }
        });
        emit('focus', e);
      }

      function onFocusin (e) {
        if (
          rootRef.value.contains(e.target) === true
          && (
            e.relatedTarget === null
            || rootRef.value.contains(e.relatedTarget) !== true
          )
        ) {
          const prop = `inner${ isViewingSource.value === true ? 'Text' : 'HTML' }`;
          eVm.caret.restorePosition(contentRef.value[ prop ].length);
          refreshToolbar();
        }
      }

      function onFocusout (e) {
        if (
          rootRef.value.contains(e.target) === true
          && (
            e.relatedTarget === null
            || rootRef.value.contains(e.relatedTarget) !== true
          )
        ) {
          eVm.caret.savePosition();
          refreshToolbar();
        }
      }

      function onMousedown () {
        offsetBottom = void 0;
      }

      function onMouseup (e) {
        eVm.caret.save();
        emit('mouseup', e);
      }

      function onTouchstartPassive () {
        offsetBottom = void 0;
      }

      function onKeyup (e) {
        eVm.caret.save();
        emit('keyup', e);
      }

      function onTouchend (e) {
        eVm.caret.save();
        emit('touchend', e);
      }

      function setContent (v, restorePosition) {
        if (contentRef.value !== null) {
          if (restorePosition === true) {
            eVm.caret.savePosition();
          }

          const prop = `inner${ isViewingSource.value === true ? 'Text' : 'HTML' }`;
          contentRef.value[ prop ] = v;

          if (restorePosition === true) {
            eVm.caret.restorePosition(contentRef.value[ prop ].length);
            refreshToolbar();
          }
        }
      }

      function runCmd (cmd, param, update = true) {
        focus();
        eVm.caret.restore();
        eVm.caret.apply(cmd, param, () => {
          focus();
          eVm.caret.save();
          if (update) {
            refreshToolbar();
          }
        });
      }

      function refreshToolbar () {
        setTimeout(() => {
          editLinkUrl.value = null;
          proxy.$forceUpdate();
        }, 1);
      }

      function focus () {
        addFocusFn(() => {
          contentRef.value !== null && contentRef.value.focus();
        });
      }

      function getContentEl () {
        return contentRef.value
      }

      // expose public methods
      Object.assign(proxy, {
        runCmd, refreshToolbar, focus, getContentEl
      });

      vue.onMounted(() => {
        eVm.caret = new Caret(contentRef.value, eVm);
        setContent(props.modelValue);
        refreshToolbar();
      });

      return () => {
        let toolbars;

        if (hasToolbar.value) {
          const bars = [
            vue.h('div', {
              key: 'qedt_top',
              class: 'q-editor__toolbar row no-wrap scroll-x'
                + toolbarBackgroundClass.value
            }, getToolbar(eVm))
          ];

          editLinkUrl.value !== null && bars.push(
            vue.h('div', {
              key: 'qedt_btm',
              class: 'q-editor__toolbar row no-wrap items-center scroll-x'
                + toolbarBackgroundClass.value
            }, getLinkEditor(eVm))
          );

          toolbars = vue.h('div', {
            key: 'toolbar_ctainer',
            class: 'q-editor__toolbars-container'
          }, bars);
        }

        return vue.h('div', {
          ref: rootRef,
          class: classes.value,
          style: { height: inFullscreen.value === true ? '100vh' : null },
          ...attributes.value,
          onFocusin,
          onFocusout
        }, [
          toolbars,

          vue.h('div', {
            ref: contentRef,
            style: innerStyle.value,
            class: innerClass.value,
            contenteditable: editable.value,
            placeholder: props.placeholder,
            ...({}),
            ...splitAttrs.listeners.value,
            onInput,
            onKeydown,
            onClick,
            onBlur,
            onFocus,

            // clean saved scroll position
            onMousedown,
            onTouchstartPassive,

            // save caret
            onMouseup,
            onKeyup,
            onTouchend
          })
        ])
      }
    }
  });

  var QItemLabel = vue.defineComponent({
    name: 'QItemLabel',

    props: {
      overline: Boolean,
      caption: Boolean,
      header: Boolean,
      lines: [ Number, String ]
    },

    setup (props, { slots }) {
      const parsedLines = vue.computed(() => parseInt(props.lines, 10));

      const classes = vue.computed(() =>
        'q-item__label'
        + (props.overline === true ? ' q-item__label--overline text-overline' : '')
        + (props.caption === true ? ' q-item__label--caption text-caption' : '')
        + (props.header === true ? ' q-item__label--header' : '')
        + (parsedLines.value === 1 ? ' ellipsis' : '')
      );

      const style = vue.computed(() => {
        return props.lines !== void 0 && parsedLines.value > 1
          ? {
              overflow: 'hidden',
              display: '-webkit-box',
              '-webkit-box-orient': 'vertical',
              '-webkit-line-clamp': parsedLines.value
            }
          : null
      });

      return () => vue.h('div', {
        style: style.value,
        class: classes.value
      }, hSlot(slots.default))
    }
  });

  var QSlideTransition = vue.defineComponent({
    name: 'QSlideTransition',

    props: {
      appear: Boolean,
      duration: {
        type: Number,
        default: 300
      }
    },

    emits: [ 'show', 'hide' ],

    setup (props, { slots, emit }) {
      let animating = false, doneFn, element;
      let timer, timerFallback, animListener, lastEvent;

      function cleanup () {
        doneFn && doneFn();
        doneFn = null;
        animating = false;

        clearTimeout(timer);
        clearTimeout(timerFallback);
        element !== void 0 && element.removeEventListener('transitionend', animListener);
        animListener = null;
      }

      function begin (el, height, done) {
        el.style.overflowY = 'hidden';
        if (height !== void 0) {
          el.style.height = `${ height }px`;
        }
        el.style.transition = `height ${ props.duration }ms cubic-bezier(.25, .8, .50, 1)`;

        animating = true;
        doneFn = done;
      }

      function end (el, event) {
        el.style.overflowY = null;
        el.style.height = null;
        el.style.transition = null;
        cleanup();
        event !== lastEvent && emit(event);
      }

      function onEnter (el, done) {
        let pos = 0;
        element = el;

        if (animating === true) {
          cleanup();
          pos = el.offsetHeight === el.scrollHeight ? 0 : void 0;
        }
        else {
          lastEvent = 'hide';
        }

        begin(el, pos, done);

        timer = setTimeout(() => {
          el.style.height = `${ el.scrollHeight }px`;
          animListener = ev => {
            if (Object(ev) !== ev || ev.target === el) {
              end(el, 'show');
            }
          };
          el.addEventListener('transitionend', animListener);
          timerFallback = setTimeout(animListener, props.duration * 1.1);
        }, 100);
      }

      function onLeave (el, done) {
        let pos;
        element = el;

        if (animating === true) {
          cleanup();
        }
        else {
          lastEvent = 'show';
          pos = el.scrollHeight;
        }

        begin(el, pos, done);

        timer = setTimeout(() => {
          el.style.height = 0;
          animListener = ev => {
            if (Object(ev) !== ev || ev.target === el) {
              end(el, 'hide');
            }
          };
          el.addEventListener('transitionend', animListener);
          timerFallback = setTimeout(animListener, props.duration * 1.1);
        }, 100);
      }

      vue.onBeforeUnmount(() => {
        animating === true && cleanup();
      });

      return () => vue.h(vue.Transition, {
        css: false,
        appear: props.appear,
        onEnter,
        onLeave
      }, slots.default)
    }
  });

  const insetMap = {
    true: 'inset',
    item: 'item-inset',
    'item-thumbnail': 'item-thumbnail-inset'
  };

  const margins = {
    xs: 2,
    sm: 4,
    md: 8,
    lg: 16,
    xl: 24
  };

  var QSeparator = vue.defineComponent({
    name: 'QSeparator',

    props: {
      ...useDarkProps,

      spaced: [ Boolean, String ],
      inset: [ Boolean, String ],
      vertical: Boolean,
      color: String,
      size: String
    },

    setup (props) {
      const vm = vue.getCurrentInstance();
      const isDark = useDark(props, vm.proxy.$q);

      const orientation = vue.computed(() => (
        props.vertical === true
          ? 'vertical'
          : 'horizontal'
      ));

      const orientClass = vue.computed(() => ` q-separator--${ orientation.value }`);

      const insetClass = vue.computed(() => (
        props.inset !== false
          ? `${ orientClass.value }-${ insetMap[ props.inset ] }`
          : ''
      ));

      const classes = vue.computed(() =>
        `q-separator${ orientClass.value }${ insetClass.value }`
        + (props.color !== void 0 ? ` bg-${ props.color }` : '')
        + (isDark.value === true ? ' q-separator--dark' : '')
      );

      const style = vue.computed(() => {
        const acc = {};

        if (props.size !== void 0) {
          acc[ props.vertical === true ? 'width' : 'height' ] = props.size;
        }

        if (props.spaced !== false) {
          const size = props.spaced === true
            ? `${ margins.md }px`
            : props.spaced in margins ? `${ margins[ props.spaced ] }px` : props.spaced;

          const dir = props.vertical === true
            ? [ 'Left', 'Right' ]
            : [ 'Top', 'Bottom' ];

          acc[ `margin${ dir[ 0 ] }` ] = acc[ `margin${ dir[ 1 ] }` ] = size;
        }

        return acc
      });

      return () => vue.h('hr', {
        class: classes.value,
        style: style.value,
        role: 'separator',
        'aria-orientation': orientation.value
      })
    }
  });

  /**
   * Based on the work of https://github.com/jchook/uuid-random
   */

  let
    buf,
    bufIdx = 0;
  const hexBytes = new Array(256);

  // Pre-calculate toString(16) for speed
  for (let i = 0; i < 256; i++) {
    hexBytes[ i ] = (i + 0x100).toString(16).substr(1);
  }

  // Use best available PRNG
  const randomBytes = (() => {
    // Node & Browser support
    const lib = typeof crypto !== 'undefined'
      ? crypto
      : (
          typeof window !== 'undefined'
            ? window.crypto || window.msCrypto
            : void 0
        );

    if (lib !== void 0) {
      if (lib.randomBytes !== void 0) {
        return lib.randomBytes
      }
      if (lib.getRandomValues !== void 0) {
        return n => {
          const bytes = new Uint8Array(n);
          lib.getRandomValues(bytes);
          return bytes
        }
      }
    }

    return n => {
      const r = [];
      for (let i = n; i > 0; i--) {
        r.push(Math.floor(Math.random() * 256));
      }
      return r
    }
  })();

  // Buffer random numbers for speed
  // Reduce memory usage by decreasing this number (min 16)
  // or improve speed by increasing this number (try 16384)
  const BUFFER_SIZE = 4096;

  function uid$2 () {
    // Buffer some random bytes for speed
    if (buf === void 0 || (bufIdx + 16 > BUFFER_SIZE)) {
      bufIdx = 0;
      buf = randomBytes(BUFFER_SIZE);
    }

    const b = Array.prototype.slice.call(buf, bufIdx, (bufIdx += 16));
    b[ 6 ] = (b[ 6 ] & 0x0f) | 0x40;
    b[ 8 ] = (b[ 8 ] & 0x3f) | 0x80;

    return hexBytes[ b[ 0 ] ] + hexBytes[ b[ 1 ] ]
      + hexBytes[ b[ 2 ] ] + hexBytes[ b[ 3 ] ] + '-'
      + hexBytes[ b[ 4 ] ] + hexBytes[ b[ 5 ] ] + '-'
      + hexBytes[ b[ 6 ] ] + hexBytes[ b[ 7 ] ] + '-'
      + hexBytes[ b[ 8 ] ] + hexBytes[ b[ 9 ] ] + '-'
      + hexBytes[ b[ 10 ] ] + hexBytes[ b[ 11 ] ]
      + hexBytes[ b[ 12 ] ] + hexBytes[ b[ 13 ] ]
      + hexBytes[ b[ 14 ] ] + hexBytes[ b[ 15 ] ]
  }

  const itemGroups = vue.shallowReactive({});
  const LINK_PROPS = Object.keys(useRouterLinkProps);

  var QExpansionItem = vue.defineComponent({
    name: 'QExpansionItem',

    props: {
      ...useRouterLinkProps,
      ...useModelToggleProps,
      ...useDarkProps,

      icon: String,

      label: String,
      labelLines: [ Number, String ],

      caption: String,
      captionLines: [ Number, String ],

      dense: Boolean,

      expandIcon: String,
      expandedIcon: String,
      expandIconClass: [ Array, String, Object ],
      duration: Number,

      headerInsetLevel: Number,
      contentInsetLevel: Number,

      expandSeparator: Boolean,
      defaultOpened: Boolean,
      expandIconToggle: Boolean,
      switchToggleSide: Boolean,
      denseToggle: Boolean,
      group: String,
      popup: Boolean,

      headerStyle: [ Array, String, Object ],
      headerClass: [ Array, String, Object ]
    },

    emits: [
      ...useModelToggleEmits,
      'click', 'after-show', 'after-hide'
    ],

    setup (props, { slots, emit }) {
      const { proxy: { $q } } = vue.getCurrentInstance();
      const isDark = useDark(props, $q);

      const showing = vue.ref(
        props.modelValue !== null
          ? props.modelValue
          : props.defaultOpened
      );

      const blurTargetRef = vue.ref(null);

      const { hide, toggle } = useModelToggle({ showing });

      let uniqueId, exitGroup;

      const classes = vue.computed(() =>
        'q-expansion-item q-item-type'
        + ` q-expansion-item--${ showing.value === true ? 'expanded' : 'collapsed' }`
        + ` q-expansion-item--${ props.popup === true ? 'popup' : 'standard' }`
      );

      const contentStyle = vue.computed(() => {
        if (props.contentInsetLevel === void 0) {
          return null
        }

        const dir = $q.lang.rtl === true ? 'Right' : 'Left';
        return {
          [ 'padding' + dir ]: (props.contentInsetLevel * 56) + 'px'
        }
      });

      const hasLink = vue.computed(() =>
        props.disable !== true && props.to !== void 0 && props.to !== null && props.to !== ''
      );

      const linkProps = vue.computed(() => {
        const acc = {};
        LINK_PROPS.forEach(key => {
          acc[ key ] = props[ key ];
        });
        return acc
      });

      const isClickable = vue.computed(() =>
        hasLink.value === true || props.expandIconToggle !== true
      );

      const expansionIcon = vue.computed(() => (
        props.expandedIcon !== void 0 && showing.value === true
          ? props.expandedIcon
          : props.expandIcon || $q.iconSet.expansionItem[ props.denseToggle === true ? 'denseIcon' : 'icon' ]
      ));

      const activeToggleIcon = vue.computed(() =>
        props.disable !== true && (hasLink.value === true || props.expandIconToggle === true)
      );

      vue.watch(() => props.group, name => {
        exitGroup !== void 0 && exitGroup();
        name !== void 0 && enterGroup();
      });

      function onHeaderClick (e) {
        hasLink.value !== true && toggle(e);
        emit('click', e);
      }

      function toggleIconKeyboard (e) {
        e.keyCode === 13 && toggleIcon(e, true);
      }

      function toggleIcon (e, keyboard) {
        keyboard !== true && blurTargetRef.value !== null && blurTargetRef.value.focus();
        toggle(e);
        stopAndPrevent(e);
      }

      function onShow () {
        emit('after-show');
      }

      function onHide () {
        emit('after-hide');
      }

      function enterGroup () {
        if (uniqueId === void 0) {
          uniqueId = uid$2();
        }

        if (showing.value === true) {
          itemGroups[ props.group ] = uniqueId;
        }

        const show = vue.watch(showing, val => {
          if (val === true) {
            itemGroups[ props.group ] = uniqueId;
          }
          else if (itemGroups[ props.group ] === uniqueId) {
            delete itemGroups[ props.group ];
          }
        });

        const group = vue.watch(
          () => itemGroups[ props.group ],
          (val, oldVal) => {
            if (oldVal === uniqueId && val !== void 0 && val !== uniqueId) {
              hide();
            }
          }
        );

        exitGroup = () => {
          show();
          group();

          if (itemGroups[ props.group ] === uniqueId) {
            delete itemGroups[ props.group ];
          }

          exitGroup = void 0;
        };
      }

      function getToggleIcon () {
        const data = {
          class: [
            'q-focusable relative-position cursor-pointer'
              + `${ props.denseToggle === true && props.switchToggleSide === true ? ' items-end' : '' }`,
            props.expandIconClass
          ],
          side: props.switchToggleSide !== true,
          avatar: props.switchToggleSide
        };

        const child = [
          vue.h(QIcon, {
            class: 'q-expansion-item__toggle-icon'
              + (props.expandedIcon === void 0 && showing.value === true
                ? ' q-expansion-item__toggle-icon--rotated'
                : ''),
            name: expansionIcon.value
          })
        ];

        if (activeToggleIcon.value === true) {
          Object.assign(data, {
            tabindex: 0,
            onClick: toggleIcon,
            onKeyup: toggleIconKeyboard
          });

          child.unshift(
            vue.h('div', {
              ref: blurTargetRef,
              class: 'q-expansion-item__toggle-focus q-icon q-focus-helper q-focus-helper--rounded',
              tabindex: -1
            })
          );
        }

        return vue.h(QItemSection, data, () => child)
      }

      function getHeaderChild () {
        let child;

        if (slots.header !== void 0) {
          child = slots.header().slice();
        }
        else {
          child = [
            vue.h(QItemSection, () => [
              vue.h(QItemLabel, { lines: props.labelLines }, () => props.label || ''),

              props.caption
                ? vue.h(QItemLabel, { lines: props.captionLines, caption: true }, () => props.caption)
                : null
            ])
          ];

          props.icon && child[ props.switchToggleSide === true ? 'push' : 'unshift' ](
            vue.h(QItemSection, {
              side: props.switchToggleSide === true,
              avatar: props.switchToggleSide !== true
            }, () => vue.h(QIcon, { name: props.icon }))
          );
        }

        props.disable !== true && child[ props.switchToggleSide === true ? 'unshift' : 'push' ](
          getToggleIcon()
        );

        return child
      }

      function getHeader () {
        const data = {
          ref: 'item',
          style: props.headerStyle,
          class: props.headerClass,
          dark: isDark.value,
          disable: props.disable,
          dense: props.dense,
          insetLevel: props.headerInsetLevel
        };

        if (isClickable.value === true) {
          data.clickable = true;
          data.onClick = onHeaderClick;

          hasLink.value === true && Object.assign(
            data,
            linkProps.value
          );
        }

        return vue.h(QItem, data, getHeaderChild)
      }

      function getTransitionChild () {
        return vue.withDirectives(
          vue.h('div', {
            key: 'e-content',
            class: 'q-expansion-item__content relative-position',
            style: contentStyle.value
          }, hSlot(slots.default)),
          [ [
            vue.vShow,
            showing.value
          ] ]
        )
      }

      function getContent () {
        const node = [
          getHeader(),

          vue.h(QSlideTransition, {
            duration: props.duration,
            onShow,
            onHide
          }, getTransitionChild)
        ];

        if (props.expandSeparator === true) {
          node.push(
            vue.h(QSeparator, {
              class: 'q-expansion-item__border q-expansion-item__border--top absolute-top',
              dark: isDark.value
            }),
            vue.h(QSeparator, {
              class: 'q-expansion-item__border q-expansion-item__border--bottom absolute-bottom',
              dark: isDark.value
            })
          );
        }

        return node
      }

      props.group !== void 0 && enterGroup();

      vue.onBeforeUnmount(() => {
        exitGroup !== void 0 && exitGroup();
      });

      return () => vue.h('div', { class: classes.value }, [
        vue.h('div', { class: 'q-expansion-item__container relative-position' }, getContent())
      ])
    }
  });

  const labelPositions = [ 'top', 'right', 'bottom', 'left' ];

  const useFabProps = {
    type: {
      type: String,
      default: 'a'
    },

    outline: Boolean,
    push: Boolean,
    flat: Boolean,
    unelevated: Boolean,

    color: String,
    textColor: String,
    glossy: Boolean,

    square: Boolean,
    padding: String,

    label: {
      type: [ String, Number ],
      default: ''
    },
    labelPosition: {
      type: String,
      default: 'right',
      validator: v => labelPositions.includes(v)
    },
    externalLabel: Boolean,
    hideLabel: {
      type: Boolean
    },
    labelClass: [ Array, String, Object ],
    labelStyle: [ Array, String, Object ],

    disable: Boolean,

    tabindex: [ Number, String ]
  };

  function useFab (props, showing) {
    return {
      formClass: vue.computed(() =>
        `q-fab--form-${ props.square === true ? 'square' : 'rounded' }`
      ),

      stacked: vue.computed(() =>
        props.externalLabel === false
        && [ 'top', 'bottom' ].includes(props.labelPosition)
      ),

      labelProps: vue.computed(() => {
        if (props.externalLabel === true) {
          const hideLabel = props.hideLabel === null
            ? showing.value === false
            : props.hideLabel;

          return {
            action: 'push',
            data: {
              class: [
                props.labelClass,
                'q-fab__label q-tooltip--style q-fab__label--external'
                + ` q-fab__label--external-${ props.labelPosition }`
                + (hideLabel === true ? ' q-fab__label--external-hidden' : '')
              ],
              style: props.labelStyle
            }
          }
        }

        return {
          action: [ 'left', 'top' ].includes(props.labelPosition)
            ? 'unshift'
            : 'push',
          data: {
            class: [
              props.labelClass,
              `q-fab__label q-fab__label--internal q-fab__label--internal-${ props.labelPosition }`
              + (props.hideLabel === true ? ' q-fab__label--internal-hidden' : '')
            ],
            style: props.labelStyle
          }
        }
      })
    }
  }

  const directions = [ 'up', 'right', 'down', 'left' ];
  const alignValues = [ 'left', 'center', 'right' ];

  var QFab = vue.defineComponent({
    name: 'QFab',

    props: {
      ...useFabProps,
      ...useModelToggleProps,

      icon: String,
      activeIcon: String,

      hideIcon: Boolean,
      hideLabel: {
        default: null
      },

      direction: {
        type: String,
        default: 'right',
        validator: v => directions.includes(v)
      },

      persistent: Boolean,

      verticalActionsAlign: {
        type: String,
        default: 'center',
        validator: v => alignValues.includes(v)
      }
    },

    emits: useModelToggleEmits,

    setup (props, { slots }) {
      const triggerRef = vue.ref(null);
      const showing = vue.ref(props.modelValue === true);

      const { proxy: { $q } } = vue.getCurrentInstance();
      const { formClass, labelProps } = useFab(props, showing);

      const hideOnRouteChange = vue.computed(() => props.persistent !== true);

      const { hide, toggle } = useModelToggle({
        showing,
        hideOnRouteChange
      });

      const classes = vue.computed(() =>
        'q-fab z-fab row inline justify-center'
        + ` q-fab--align-${ props.verticalActionsAlign } ${ formClass.value }`
        + (showing.value === true ? ' q-fab--opened' : '')
      );

      const actionClass = vue.computed(() =>
        'q-fab__actions flex no-wrap inline'
        + ` q-fab__actions--${ props.direction }`
      );

      function getTriggerContent () {
        const child = [];

        props.hideIcon !== true && child.push(
          vue.h('div', { class: 'q-fab__icon-holder' }, [
            vue.h(QIcon, {
              class: 'q-fab__icon absolute-full',
              name: props.icon || $q.iconSet.fab.icon
            }),

            vue.h(QIcon, {
              class: 'q-fab__active-icon absolute-full',
              name: props.activeIcon || $q.iconSet.fab.activeIcon
            })
          ])
        );

        props.label !== '' && child[ labelProps.value.action ](
          vue.h('div', labelProps.value.data, [ props.label ])
        );

        return hMergeSlot(slots.tooltip, child)
      }

      vue.provide(fabKey, {
        showing,

        onChildClick (evt) {
          hide(evt);

          if (triggerRef.value !== null) {
            triggerRef.value.$el.focus();
          }
        }
      });

      return () => vue.h('div', {
        class: classes.value
      }, [
        vue.h(QBtn, {
          ref: triggerRef,
          class: formClass.value,
          ...props,
          noWrap: true,
          stack: props.stacked,
          align: void 0,
          icon: void 0,
          label: void 0,
          noCaps: true,
          fab: true,
          'aria-expanded': showing.value === true ? 'true' : 'false',
          'aria-haspopup': 'true',
          onClick: toggle
        }, getTriggerContent),

        vue.h('div', { class: actionClass.value }, hSlot(slots.default))
      ])
    }
  });

  const anchorMap = {
    start: 'self-end',
    center: 'self-center',
    end: 'self-start'
  };

  const anchorValues = Object.keys(anchorMap);

  var QFabAction = vue.defineComponent({
    name: 'QFabAction',

    props: {
      ...useFabProps,

      icon: {
        type: String,
        default: ''
      },

      anchor: {
        type: String,
        validator: v => anchorValues.includes(v)
      },

      to: [ String, Object ],
      replace: Boolean
    },

    emits: [ 'click' ],

    setup (props, { slots, emit }) {
      const $fab = vue.inject(fabKey, () => ({
        showing: { value: true },
        onChildClick: noop
      }));

      const { formClass, labelProps } = useFab(props, $fab.showing);

      const classes = vue.computed(() => {
        const align = anchorMap[ props.anchor ];
        return formClass.value + (align !== void 0 ? ` ${ align }` : '')
      });

      const isDisabled = vue.computed(() =>
        props.disable === true
        || $fab.showing.value !== true
      );

      function click (e) {
        $fab.onChildClick(e);
        emit('click', e);
      }

      function getContent () {
        const child = [];

        props.icon !== '' && child.push(
          vue.h(QIcon, { name: props.icon })
        );

        props.label !== '' && child[ labelProps.value.action ](
          vue.h('div', labelProps.value.data, [ props.label ])
        );

        return hMergeSlot(slots.default, child)
      }

      // expose public methods
      const vm = vue.getCurrentInstance();
      Object.assign(vm.proxy, { click });

      return () => vue.h(QBtn, {
        class: classes.value,
        ...props,
        noWrap: true,
        stack: props.stacked,
        icon: void 0,
        label: void 0,
        noCaps: true,
        fabMini: true,
        disable: isDisabled.value,
        onClick: click
      }, getContent)
    }
  });

  function useFormChild ({ validate, resetValidation, requiresQForm }) {
    const $form = vue.inject(formKey, false);

    if ($form !== false) {
      const { props, proxy } = vue.getCurrentInstance();

      // export public method (so it can be used in QForm)
      Object.assign(proxy, validate);

      vue.watch(() => props.disable, val => {
        if (val === true) {
          typeof resetValidation === 'function' && resetValidation();
          $form.unbindComponent(proxy);
        }
        else {
          $form.bindComponent(proxy);
        }
      });

      // register component to parent QForm
      props.disable !== true && $form.bindComponent(proxy);

      vue.onBeforeUnmount(() => {
        // unregister component
        props.disable !== true && $form.unbindComponent(proxy);
      });
    }
    else if (requiresQForm !== true) {
      console.error('Parent QForm not found on useFormChild()!');
    }
  }

  const lazyRulesValues = [ true, false, 'ondemand' ];

  const useValidateProps = {
    modelValue: {},

    error: {
      type: Boolean,
      default: null
    },
    errorMessage: String,
    noErrorIcon: Boolean,

    rules: Array,
    reactiveRules: Boolean,
    lazyRules: {
      type: [ Boolean, String ],
      validator: v => lazyRulesValues.includes(v)
    }
  };

  function useValidate (focused, innerLoading) {
    const { props, proxy } = vue.getCurrentInstance();

    const innerError = vue.ref(false);
    const innerErrorMessage = vue.ref(null);
    const isDirtyModel = vue.ref(null);

    useFormChild({ validate, resetValidation, requiresQForm: true });

    let validateIndex = 0, unwatchRules;

    const hasRules = vue.computed(() =>
      props.rules !== void 0
      && props.rules !== null
      && props.rules.length > 0
    );

    const hasError = vue.computed(() =>
      props.error === true || innerError.value === true
    );

    const computedErrorMessage = vue.computed(() => (
      typeof props.errorMessage === 'string' && props.errorMessage.length > 0
        ? props.errorMessage
        : innerErrorMessage.value
    ));

    vue.watch(() => props.modelValue, () => {
      validateIfNeeded();
    });

    vue.watch(() => props.reactiveRules, val => {
      if (val === true) {
        if (unwatchRules === void 0) {
          unwatchRules = vue.watch(() => props.rules, () => {
            validateIfNeeded(true);
          });
        }
      }
      else if (unwatchRules !== void 0) {
        unwatchRules();
        unwatchRules = void 0;
      }
    }, { immediate: true });

    vue.watch(focused, val => {
      if (props.lazyRules !== 'ondemand') {
        if (val === true) {
          if (isDirtyModel.value === null) {
            isDirtyModel.value = false;
          }
        }
        else if (isDirtyModel.value === false && hasRules.value === true) {
          isDirtyModel.value = true;
          validate();
        }
      }
    });

    function resetValidation () {
      validateIndex++;
      innerLoading.value = false;
      isDirtyModel.value = null;
      innerError.value = false;
      innerErrorMessage.value = null;
    }

    /*
     * Return value
     *   - true (validation succeeded)
     *   - false (validation failed)
     *   - Promise (pending async validation)
     */
    function validate (val = props.modelValue) {
      if (hasRules.value !== true) {
        return true
      }

      validateIndex++;

      if (innerLoading.value !== true && props.lazyRules !== true) {
        isDirtyModel.value = true;
      }

      const update = (err, msg) => {
        if (innerError.value !== err) {
          innerError.value = err;
        }

        const m = msg || void 0;

        if (innerErrorMessage.value !== m) {
          innerErrorMessage.value = m;
        }

        if (innerLoading.value !== false) {
          innerLoading.value = false;
        }
      };

      const promises = [];

      for (let i = 0; i < props.rules.length; i++) {
        const rule = props.rules[ i ];
        let res;

        if (typeof rule === 'function') {
          res = rule(val);
        }
        else if (typeof rule === 'string' && testPattern[ rule ] !== void 0) {
          res = testPattern[ rule ](val);
        }

        if (res === false || typeof res === 'string') {
          update(true, res);
          return false
        }
        else if (res !== true && res !== void 0) {
          promises.push(res);
        }
      }

      if (promises.length === 0) {
        update(false);
        return true
      }

      if (innerLoading.value !== true) {
        innerLoading.value = true;
      }

      const index = validateIndex;

      return Promise.all(promises).then(
        res => {
          if (index !== validateIndex) {
            return true
          }

          if (res === void 0 || Array.isArray(res) === false || res.length === 0) {
            update(false);
            return true
          }

          const msg = res.find(r => r === false || typeof r === 'string');
          update(msg !== void 0, msg);
          return msg === void 0
        },
        e => {
          if (index === validateIndex) {
            console.error(e);
            update(true);
            return false
          }

          return true
        }
      )
    }

    function validateIfNeeded (changedRules) {
      if (
        hasRules.value === true
        && props.lazyRules !== 'ondemand'
        && (isDirtyModel.value === true || (props.lazyRules !== true && changedRules !== true))
      ) {
        validate();
      }
    }

    vue.onBeforeUnmount(() => {
      unwatchRules !== void 0 && unwatchRules();
    });

    // expose public methods & props
    Object.assign(proxy, { resetValidation, validate });
    Object.defineProperty(proxy, 'hasError', {
      get: () => hasError.value
    });

    return {
      isDirtyModel,
      hasRules,
      hasError,
      computedErrorMessage,

      validate,
      resetValidation
    }
  }

  function getTargetUid (val) {
    return val === void 0 ? `f_${ uid$2() }` : val
  }

  function fieldValueIsFilled (val) {
    return val !== void 0
      && val !== null
      && ('' + val).length > 0
  }

  const useFieldProps = {
    ...useDarkProps,
    ...useValidateProps,

    label: String,
    stackLabel: Boolean,
    hint: String,
    hideHint: Boolean,
    prefix: String,
    suffix: String,

    labelColor: String,
    color: String,
    bgColor: String,

    filled: Boolean,
    outlined: Boolean,
    borderless: Boolean,
    standout: [ Boolean, String ],

    square: Boolean,

    loading: Boolean,

    labelSlot: Boolean,

    bottomSlots: Boolean,
    hideBottomSpace: Boolean,

    rounded: Boolean,
    dense: Boolean,
    itemAligned: Boolean,

    counter: Boolean,

    clearable: Boolean,
    clearIcon: String,

    disable: Boolean,
    readonly: Boolean,

    autofocus: Boolean,

    for: String,

    maxlength: [ Number, String ]
  };

  const useFieldEmits = [ 'update:modelValue', 'clear', 'focus', 'blur', 'popup-show', 'popup-hide' ];

  function useFieldState () {
    const { props, attrs, proxy } = vue.getCurrentInstance();

    const isDark = useDark(props, proxy.$q);

    return {
      isDark,

      editable: vue.computed(() =>
        props.disable !== true && props.readonly !== true
      ),

      innerLoading: vue.ref(false),
      focused: vue.ref(false),
      hasPopupOpen: vue.ref(false),

      splitAttrs: useSplitAttrs(attrs),
      targetUid: vue.ref(getTargetUid(props.for)),

      rootRef: vue.ref(null),
      targetRef: vue.ref(null),
      controlRef: vue.ref(null)

      /**
       * user supplied additionals:

       * innerValue - computed
       * floatingLabel - computed
       * inputRef - computed

       * fieldClass - computed
       * hasShadow - computed

       * controlEvents - Object with fn(e)

       * getControl - fn
       * getInnerAppend - fn
       * getControlChild - fn
       * getShadowControl - fn
       * showPopup - fn
       */
    }
  }

  function useField (state) {
    const { props, emit, slots, attrs, proxy } = vue.getCurrentInstance();
    const { $q } = proxy;

    let focusoutTimer;

    if (state.hasValue === void 0) {
      state.hasValue = vue.computed(() => fieldValueIsFilled(props.modelValue));
    }

    if (state.emitValue === void 0) {
      state.emitValue = value => {
        emit('update:modelValue', value);
      };
    }

    if (state.controlEvents === void 0) {
      state.controlEvents = {
        onFocusin: onControlFocusin,
        onFocusout: onControlFocusout
      };
    }

    Object.assign(state, {
      clearValue,
      onControlFocusin,
      onControlFocusout,
      focus
    });

    if (state.computedCounter === void 0) {
      state.computedCounter = vue.computed(() => {
        if (props.counter !== false) {
          const len = typeof props.modelValue === 'string' || typeof props.modelValue === 'number'
            ? ('' + props.modelValue).length
            : (Array.isArray(props.modelValue) === true ? props.modelValue.length : 0);

          const max = props.maxlength !== void 0
            ? props.maxlength
            : props.maxValues;

          return len + (max !== void 0 ? ' / ' + max : '')
        }
      });
    }

    const {
      isDirtyModel,
      hasRules,
      hasError,
      computedErrorMessage,
      resetValidation
    } = useValidate(state.focused, state.innerLoading);

    const floatingLabel = state.floatingLabel !== void 0
      ? vue.computed(() => props.stackLabel === true || state.focused.value === true || state.floatingLabel.value === true)
      : vue.computed(() => props.stackLabel === true || state.focused.value === true || state.hasValue.value === true);

    const shouldRenderBottom = vue.computed(() =>
      props.bottomSlots === true
      || props.hint !== void 0
      || hasRules.value === true
      || props.counter === true
      || props.error !== null
    );

    const styleType = vue.computed(() => {
      if (props.filled === true) { return 'filled' }
      if (props.outlined === true) { return 'outlined' }
      if (props.borderless === true) { return 'borderless' }
      if (props.standout) { return 'standout' }
      return 'standard'
    });

    const classes = vue.computed(() =>
      `q-field row no-wrap items-start q-field--${ styleType.value }`
      + (state.fieldClass !== void 0 ? ` ${ state.fieldClass.value }` : '')
      + (props.rounded === true ? ' q-field--rounded' : '')
      + (props.square === true ? ' q-field--square' : '')
      + (floatingLabel.value === true ? ' q-field--float' : '')
      + (hasLabel.value === true ? ' q-field--labeled' : '')
      + (props.dense === true ? ' q-field--dense' : '')
      + (props.itemAligned === true ? ' q-field--item-aligned q-item-type' : '')
      + (state.isDark.value === true ? ' q-field--dark' : '')
      + (state.getControl === void 0 ? ' q-field--auto-height' : '')
      + (state.focused.value === true ? ' q-field--focused' : '')
      + (hasError.value === true ? ' q-field--error' : '')
      + (hasError.value === true || state.focused.value === true ? ' q-field--highlighted' : '')
      + (props.hideBottomSpace !== true && shouldRenderBottom.value === true ? ' q-field--with-bottom' : '')
      + (props.disable === true ? ' q-field--disabled' : (props.readonly === true ? ' q-field--readonly' : ''))
    );

    const contentClass = vue.computed(() =>
      'q-field__control relative-position row no-wrap'
      + (props.bgColor !== void 0 ? ` bg-${ props.bgColor }` : '')
      + (
        hasError.value === true
          ? ' text-negative'
          : (
              typeof props.standout === 'string' && props.standout.length > 0 && state.focused.value === true
                ? ` ${ props.standout }`
                : (props.color !== void 0 ? ` text-${ props.color }` : '')
            )
      )
    );

    const hasLabel = vue.computed(() =>
      props.labelSlot === true || props.label !== void 0
    );

    const labelClass = vue.computed(() =>
      'q-field__label no-pointer-events absolute ellipsis'
      + (props.labelColor !== void 0 && hasError.value !== true ? ` text-${ props.labelColor }` : '')
    );

    const controlSlotScope = vue.computed(() => ({
      id: state.targetUid.value,
      editable: state.editable.value,
      focused: state.focused.value,
      floatingLabel: floatingLabel.value,
      modelValue: props.modelValue,
      emitValue: state.emitValue
    }));

    const attributes = vue.computed(() => {
      const acc = {
        for: state.targetUid.value
      };

      if (props.disable === true) {
        acc[ 'aria-disabled' ] = 'true';
      }
      else if (props.readonly === true) {
        acc[ 'aria-readonly' ] = 'true';
      }

      return acc
    });

    vue.watch(() => props.for, val => {
      // don't transform targetUid into a computed
      // prop as it will break SSR
      state.targetUid.value = getTargetUid(val);
    });

    let focusFn;

    function focus () {
      focusFn !== void 0 && removeFocusFn(focusFn);
      focusFn = addFocusFn(() => {
        focusFn = void 0;
        const el = document.activeElement;
        let target = state.targetRef !== void 0 && state.targetRef.value;

        if (target && (el === null || el.id !== state.targetUid.value)) {
          target.hasAttribute('tabindex') === true || (target = target.querySelector('[tabindex]'));
          if (target && target !== el) {
            target.focus();
          }
        }
      });
    }

    function blur () {
      focusFn !== void 0 && removeFocusFn(focusFn);
      const el = document.activeElement;
      if (el !== null && state.rootRef.value.contains(el)) {
        el.blur();
      }
    }

    function onControlFocusin (e) {
      if (state.editable.value === true && state.focused.value === false) {
        state.focused.value = true;
        emit('focus', e);
      }
    }

    function onControlFocusout (e, then) {
      clearTimeout(focusoutTimer);
      focusoutTimer = setTimeout(() => {
        if (
          document.hasFocus() === true && (
            state.hasPopupOpen.value === true
            || (
              state.controlRef !== void 0
              && (
                state.controlRef.value === null
                || state.controlRef.value.contains(document.activeElement) !== false
              )
            )
          )
        ) {
          return
        }

        if (state.focused.value === true) {
          state.focused.value = false;
          emit('blur', e);
        }

        then !== void 0 && then();
      });
    }

    function clearValue (e) {
      // prevent activating the field but keep focus on desktop
      stopAndPrevent(e);

      if ($q.platform.is.mobile !== true) {
        const el = (state.targetRef !== void 0 && state.targetRef.value) || state.rootRef.value;
        el.focus();
      }
      else if (state.rootRef.value.contains(document.activeElement) === true) {
        document.activeElement.blur();
      }

      if (props.type === 'file') { // TODO vue3
        // do not let focus be triggered
        // as it will make the native file dialog
        // appear for another selection
        state.inputRef.value.value = null;
      }

      emit('update:modelValue', null);
      emit('clear', props.modelValue);

      vue.nextTick(() => {
        resetValidation();

        if (props.lazyRules !== 'ondemand' && $q.platform.is.mobile !== true) {
          isDirtyModel.value = false;
        }
      });
    }

    function getContent () {
      const node = [];

      slots.prepend !== void 0 && node.push(
        vue.h('div', {
          class: 'q-field__prepend q-field__marginal row no-wrap items-center',
          key: 'prepend',
          onClick: prevent
        }, slots.prepend())
      );

      node.push(
        vue.h('div', {
          class: 'q-field__control-container col relative-position row no-wrap q-anchor--skip'
        }, getControlContainer())
      );

      slots.append !== void 0 && node.push(
        vue.h('div', {
          class: 'q-field__append q-field__marginal row no-wrap items-center',
          key: 'append',
          onClick: prevent
        }, slots.append())
      );

      hasError.value === true && props.noErrorIcon === false && node.push(
        getInnerAppendNode('error', [
          vue.h(QIcon, { name: $q.iconSet.field.error, color: 'negative' })
        ])
      );

      if (props.loading === true || state.innerLoading.value === true) {
        node.push(
          getInnerAppendNode(
            'inner-loading-append',
            slots.loading !== void 0
              ? slots.loading()
              : [ vue.h(QSpinner, { color: props.color }) ]
          )
        );
      }
      else if (props.clearable === true && state.hasValue.value === true && state.editable.value === true) {
        node.push(
          getInnerAppendNode('inner-clearable-append', [
            vue.h(QIcon, {
              class: 'q-field__focusable-action',
              tag: 'button',
              name: props.clearIcon || $q.iconSet.field.clear,
              tabindex: 0,
              type: 'button',
              onClick: clearValue
            })
          ])
        );
      }

      state.getInnerAppend !== void 0 && node.push(
        getInnerAppendNode('inner-append', state.getInnerAppend())
      );

      state.getControlChild !== void 0 && node.push(
        state.getControlChild()
      );

      return node
    }

    function getControlContainer () {
      const node = [];

      props.prefix !== void 0 && props.prefix !== null && node.push(
        vue.h('div', {
          class: 'q-field__prefix no-pointer-events row items-center'
        }, props.prefix)
      );

      if (state.getShadowControl !== void 0 && state.hasShadow.value === true) {
        node.push(
          state.getShadowControl()
        );
      }

      if (state.getControl !== void 0) {
        node.push(state.getControl());
      }
      // internal usage only:
      else if (slots.rawControl !== void 0) {
        node.push(slots.rawControl());
      }
      else if (slots.control !== void 0) {
        node.push(
          vue.h('div', {
            ref: state.targetRef,
            class: 'q-field__native row',
            ...state.splitAttrs.attributes.value,
            'data-autofocus': props.autofocus === true || void 0
          }, slots.control(controlSlotScope.value))
        );
      }

      hasLabel.value === true && node.push(
        vue.h('div', {
          class: labelClass.value
        }, hSlot(slots.label, props.label))
      );

      props.suffix !== void 0 && props.suffix !== null && node.push(
        vue.h('div', {
          class: 'q-field__suffix no-pointer-events row items-center'
        }, props.suffix)
      );

      return node.concat(hSlot(slots.default))
    }

    function getBottom () {
      let msg, key;

      if (hasError.value === true) {
        if (computedErrorMessage.value !== null) {
          msg = [ vue.h('div', computedErrorMessage.value) ];
          key = `q--slot-error-${ computedErrorMessage.value }`;
        }
        else {
          msg = hSlot(slots.error);
          key = 'q--slot-error';
        }
      }
      else if (props.hideHint !== true || state.focused.value === true) {
        if (props.hint !== void 0) {
          msg = [ vue.h('div', props.hint) ];
          key = `q--slot-hint-${ props.hint }`;
        }
        else {
          msg = hSlot(slots.hint);
          key = 'q--slot-hint';
        }
      }

      const hasCounter = props.counter === true || slots.counter !== void 0;

      if (props.hideBottomSpace === true && hasCounter === false && msg === void 0) {
        return
      }

      const main = vue.h('div', {
        key,
        class: 'q-field__messages col'
      }, msg);

      return vue.h('div', {
        class: 'q-field__bottom row items-start q-field__bottom--'
          + (props.hideBottomSpace !== true ? 'animated' : 'stale')
      }, [
        props.hideBottomSpace === true
          ? main
          : vue.h(vue.Transition, { name: 'q-transition--field-message' }, () => main),

        hasCounter === true
          ? vue.h('div', {
              class: 'q-field__counter'
            }, slots.counter !== void 0 ? slots.counter() : state.computedCounter.value)
          : null
      ])
    }

    function getInnerAppendNode (key, content) {
      return content === null
        ? null
        : vue.h('div', {
          key,
          class: 'q-field__append q-field__marginal row no-wrap items-center q-anchor--skip'
        }, content)
    }

    // expose public methods
    Object.assign(proxy, { focus, blur });

    vue.onMounted(() => {
      if (isRuntimeSsrPreHydration.value === true && props.for === void 0) {
        state.targetUid.value = getTargetUid();
      }

      props.autofocus === true && proxy.focus();
    });

    vue.onBeforeUnmount(() => {
      clearTimeout(focusoutTimer);
    });

    return function renderField () {
      return vue.h('label', {
        ref: state.rootRef,
        class: [
          classes.value,
          attrs.class
        ],
        style: attrs.style,
        ...attributes.value
      }, [
        slots.before !== void 0
          ? vue.h('div', {
              class: 'q-field__before q-field__marginal row no-wrap items-center',
              onClick: prevent
            }, slots.before())
          : null,

        vue.h('div', {
          class: 'q-field__inner relative-position col self-stretch'
        }, [
          vue.h('div', {
            ref: state.controlRef,
            class: contentClass.value,
            tabindex: -1,
            ...state.controlEvents
          }, getContent()),

          shouldRenderBottom.value === true
            ? getBottom()
            : null
        ]),

        slots.after !== void 0
          ? vue.h('div', {
              class: 'q-field__after q-field__marginal row no-wrap items-center',
              onClick: prevent
            }, slots.after())
          : null
      ])
    }
  }

  var QField = vue.defineComponent({
    name: 'QField',

    inheritAttrs: false,

    props: useFieldProps,

    emits: useFieldEmits,

    setup () {
      return useField(useFieldState())
    }
  });

  function filterFiles (files, rejectedFiles, failedPropValidation, filterFn) {
    const acceptedFiles = [];

    files.forEach(file => {
      if (filterFn(file) === true) {
        acceptedFiles.push(file);
      }
      else {
        rejectedFiles.push({ failedPropValidation, file });
      }
    });

    return acceptedFiles
  }

  function stopAndPreventDrag (e) {
    e && e.dataTransfer && (e.dataTransfer.dropEffect = 'copy');
    stopAndPrevent(e);
  }

  const useFileProps = {
    multiple: Boolean,
    accept: String,
    capture: String,
    maxFileSize: [ Number, String ],
    maxTotalSize: [ Number, String ],
    maxFiles: [ Number, String ],
    filter: Function
  };

  const useFileEmits = [ 'rejected' ];

  function useFile ({
    editable,
    dnd,
    getFileInput,
    addFilesToQueue
  }) {
    const { props, emit, proxy } = vue.getCurrentInstance();

    const extensions = vue.computed(() => (
      props.accept !== void 0
        ? props.accept.split(',').map(ext => {
            ext = ext.trim();
            if (ext === '*') { // support "*"
              return '*/'
            }
            else if (ext.endsWith('/*')) { // support "image/*" or "*/*"
              ext = ext.slice(0, ext.length - 1);
            }
            return ext.toUpperCase()
          })
        : null
    ));

    const maxFilesNumber = vue.computed(() => parseInt(props.maxFiles, 10));
    const maxTotalSizeNumber = vue.computed(() => parseInt(props.maxTotalSize, 10));

    function pickFiles (e) {
      if (editable.value) {
        const input = getFileInput();
        input && input.click(e);
      }
    }

    function addFiles (files) {
      if (editable.value && files) {
        addFilesToQueue(null, files);
      }
    }

    function processFiles (e, filesToProcess, currentFileList, append) {
      let files = Array.from(filesToProcess || e.target.files);
      const rejectedFiles = [];

      const done = () => {
        if (rejectedFiles.length > 0) {
          emit('rejected', rejectedFiles);
        }
      };

      // filter file types
      if (props.accept !== void 0 && extensions.value.indexOf('*/') === -1) {
        files = filterFiles(files, rejectedFiles, 'accept', file => {
          return extensions.value.some(ext => (
            file.type.toUpperCase().startsWith(ext)
            || file.name.toUpperCase().endsWith(ext)
          ))
        });

        if (files.length === 0) { return done() }
      }

      // filter max file size
      if (props.maxFileSize !== void 0) {
        const maxFileSize = parseInt(props.maxFileSize, 10);
        files = filterFiles(files, rejectedFiles, 'max-file-size', file => {
          return file.size <= maxFileSize
        });

        if (files.length === 0) { return done() }
      }

      // Cordova/iOS allows selecting multiple files even when the
      // multiple attribute is not specified. We also normalize drag'n'dropped
      // files here:
      if (props.multiple !== true) {
        files = [ files[ 0 ] ];
      }

      if (props.maxTotalSize !== void 0) {
        let size = append === true
          ? currentFileList.reduce((total, file) => total + file.size, 0)
          : 0;

        files = filterFiles(files, rejectedFiles, 'max-total-size', file => {
          size += file.size;
          return size <= maxTotalSizeNumber.value
        });

        if (files.length === 0) { return done() }
      }

      // do we have custom filter function?
      if (typeof props.filter === 'function') {
        const filteredFiles = props.filter(files);
        files = filterFiles(files, rejectedFiles, 'filter', file => {
          return filteredFiles.includes(file)
        });
      }

      if (props.maxFiles !== void 0) {
        let filesNumber = append === true
          ? currentFileList.length
          : 0;

        files = filterFiles(files, rejectedFiles, 'max-files', () => {
          filesNumber++;
          return filesNumber <= maxFilesNumber.value
        });

        if (files.length === 0) { return done() }
      }

      done();

      if (files.length > 0) {
        return files
      }
    }

    function onDragover (e) {
      stopAndPreventDrag(e);
      dnd.value !== true && (dnd.value = true);
    }

    function onDragleave (e) {
      stopAndPrevent(e);
      dnd.value = false;
    }

    function onDrop (e) {
      stopAndPreventDrag(e);
      const files = e.dataTransfer.files;

      if (files.length > 0) {
        addFilesToQueue(null, files);
      }

      dnd.value = false;
    }

    function getDndNode (type) {
      if (dnd.value === true) {
        return vue.h('div', {
          class: `q-${ type }__dnd absolute-full`,
          onDragenter: stopAndPreventDrag,
          onDragover: stopAndPreventDrag,
          onDragleave,
          onDrop
        })
      }
    }

    // expose public methods
    Object.assign(proxy, { pickFiles, addFiles });

    return {
      pickFiles,
      addFiles,
      onDragover,
      processFiles,
      getDndNode,
      maxFilesNumber,
      maxTotalSizeNumber
    }
  }

  function useFileFormDomProps (props, typeGuard) {
    function getFormDomProps () {
      const model = props.modelValue;

      try {
        const dt = 'DataTransfer' in window
          ? new DataTransfer()
          : ('ClipboardEvent' in window
              ? new ClipboardEvent('').clipboardData
              : void 0
            );

        if (Object(model) === model) {
          ('length' in model
            ? Array.from(model)
            : [ model ]
          ).forEach(file => {
            dt.items.add(file);
          });
        }

        return {
          files: dt.files
        }
      }
      catch (e) {
        return {
          files: void 0
        }
      }
    }

    return typeGuard === true
      ? vue.computed(() => {
          if (props.type !== 'file') {
            return
          }

          return getFormDomProps()
        })
      : vue.computed(getFormDomProps)
  }

  var QFile = vue.defineComponent({
    name: 'QFile',

    props: {
      ...useFieldProps,
      ...useFormProps,
      ...useFileProps,

      /* SSR does not know about File & FileList */
      modelValue: [ File, FileList, Array ],

      append: Boolean,
      useChips: Boolean,
      displayValue: [ String, Number ],

      tabindex: {
        type: [ String, Number ],
        default: 0
      },

      counterLabel: Function,

      inputClass: [ Array, String, Object ],
      inputStyle: [ Array, String, Object ]
    },

    emits: [
      ...useFieldEmits,
      ...useFileEmits
    ],

    setup (props, { slots, emit, attrs }) {
      const { proxy } = vue.getCurrentInstance();

      const state = useFieldState();

      const inputRef = vue.ref(null);
      const dnd = vue.ref(false);
      const nameProp = useFormInputNameAttr(props);

      const {
        pickFiles,
        onDragover,
        processFiles,
        getDndNode
      } = useFile({ editable: state.editable, dnd, getFileInput, addFilesToQueue });

      const formDomProps = useFileFormDomProps(props);

      const innerValue = vue.computed(() => (
        Object(props.modelValue) === props.modelValue
          ? ('length' in props.modelValue ? Array.from(props.modelValue) : [ props.modelValue ])
          : []
      ));

      const hasValue = vue.computed(() => fieldValueIsFilled(innerValue.value));

      const selectedString = vue.computed(() =>
        innerValue.value
          .map(file => file.name)
          .join(', ')
      );

      const totalSize = vue.computed(() =>
        humanStorageSize(
          innerValue.value.reduce((acc, file) => acc + file.size, 0)
        )
      );

      const counterProps = vue.computed(() => ({
        totalSize: totalSize.value,
        filesNumber: innerValue.value.length,
        maxFiles: props.maxFiles
      }));

      const inputAttrs = vue.computed(() => ({
        tabindex: -1,
        type: 'file',
        title: '', // try to remove default tooltip,
        accept: props.accept,
        capture: props.capture,
        name: nameProp.value,
        ...attrs,
        id: state.targetUid.value,
        disabled: state.editable.value !== true
      }));

      const isAppending = vue.computed(() =>
        props.multiple === true && props.append === true
      );

      function removeAtIndex (index) {
        const files = innerValue.value.slice();
        files.splice(index, 1);
        emitValue(files);
      }

      function removeFile (file) {
        const index = innerValue.value.findIndex(file);
        if (index > -1) {
          removeAtIndex(index);
        }
      }

      function emitValue (files) {
        emit('update:modelValue', props.multiple === true ? files : files[ 0 ]);
      }

      function onKeyup (e) {
        // only on ENTER
        e.keyCode === 13 && pickFiles(e);
      }

      function getFileInput () {
        return inputRef.value
      }

      function addFilesToQueue (e, fileList) {
        const files = processFiles(e, fileList, innerValue.value, isAppending.value);

        files !== void 0 && emitValue(
          isAppending.value === true
            ? innerValue.value.concat(files)
            : files
        );
      }

      function getSelection () {
        if (slots.file !== void 0) {
          return innerValue.value.map(
            (file, index) => slots.file({ index, file, ref: this })
          )
        }

        if (slots.selected !== void 0) {
          return slots.selected({ files: innerValue.value, ref: this })
        }

        if (props.useChips === true) {
          return innerValue.value.map((file, i) => vue.h(QChip, {
            key: 'file-' + i,
            removable: state.editable.value,
            dense: true,
            textColor: props.color,
            tabindex: props.tabindex,
            onRemove: () => { removeAtIndex(i); }
          }, () => vue.h('span', {
            class: 'ellipsis',
            textContent: file.name
          })))
        }

        return [
          vue.h('div', {
            class: props.inputClass,
            style: props.inputStyle,
            textContent: props.displayValue !== void 0
              ? props.displayValue
              : selectedString.value
          })
        ]
      }

      function getInput () {
        const data = {
          ref: inputRef,
          class: 'q-field__input fit absolute-full cursor-pointer',
          ...inputAttrs.value,
          ...formDomProps.value,
          onChange: addFilesToQueue
        };

        if (props.multiple === true) {
          data.multiple = true;
        }

        return vue.h('input', data)
      }

      Object.assign(state, {
        fieldClass: { value: 'q-file q-field--auto-height' },
        emitValue,
        hasValue,
        inputRef,
        innerValue,

        floatingLabel: vue.computed(() =>
          hasValue.value === true
          || fieldValueIsFilled(props.displayValue)
        ),

        computedCounter: vue.computed(() => {
          if (props.counterLabel !== void 0) {
            return props.counterLabel(counterProps.value)
          }

          const max = props.maxFiles;
          return `${ innerValue.value.length }${ max !== void 0 ? ' / ' + max : '' } (${ totalSize.value })`
        }),

        getControlChild: () => getDndNode('file'),
        getControl: () => {
          const data = {
            ref: state.targetRef,
            class: 'q-field__native row items-center cursor-pointer',
            tabindex: props.tabindex
          };

          if (state.editable.value === true) {
            Object.assign(data, { onDragover, onKeyup });
          }

          return vue.h('div', data, [ getInput() ].concat(getSelection()))
        }
      });

      // expose public methods
      Object.assign(proxy, {
        removeAtIndex,
        removeFile
      });

      return useField(state)
    }
  });

  var QFooter = vue.defineComponent({
    name: 'QFooter',

    props: {
      modelValue: {
        type: Boolean,
        default: true
      },
      reveal: Boolean,
      bordered: Boolean,
      elevated: Boolean,

      heightHint: {
        type: [ String, Number ],
        default: 50
      }
    },

    emits: [ 'reveal', 'focusin' ],

    setup (props, { slots, emit }) {
      const { proxy: { $q } } = vue.getCurrentInstance();

      const $layout = vue.inject(layoutKey, () => {
        console.error('QFooter needs to be child of QLayout');
      });

      const size = vue.ref(parseInt(props.heightHint, 10));
      const revealed = vue.ref(true);
      const windowHeight = vue.ref(
        isRuntimeSsrPreHydration.value === true || $layout.isContainer.value === true
          ? 0
          : window.innerHeight
      );

      const fixed = vue.computed(() =>
        props.reveal === true
        || $layout.view.value.indexOf('F') > -1
        || $layout.isContainer.value === true
      );

      const containerHeight = vue.computed(() => (
        $layout.isContainer.value === true
          ? $layout.containerHeight.value
          : windowHeight.value
      ));

      const offset = vue.computed(() => {
        if (props.modelValue !== true) {
          return 0
        }
        if (fixed.value === true) {
          return revealed.value === true ? size.value : 0
        }
        const offset = $layout.scroll.value.position + containerHeight.value + size.value - $layout.height.value;
        return offset > 0 ? offset : 0
      });

      const hidden = vue.computed(() =>
        props.modelValue !== true || (fixed.value === true && revealed.value !== true)
      );

      const revealOnFocus = vue.computed(() =>
        props.modelValue === true && hidden.value === true && props.reveal === true
      );

      const classes = vue.computed(() =>
        'q-footer q-layout__section--marginal '
        + (fixed.value === true ? 'fixed' : 'absolute') + '-bottom'
        + (props.bordered === true ? ' q-footer--bordered' : '')
        + (hidden.value === true ? ' q-footer--hidden' : '')
        + (
          props.modelValue !== true
            ? ' q-layout--prevent-focus' + (fixed.value !== true ? ' hidden' : '')
            : ''
        )
      );

      const style = vue.computed(() => {
        const
          view = $layout.rows.value.bottom,
          css = {};

        if (view[ 0 ] === 'l' && $layout.left.space === true) {
          css[ $q.lang.rtl === true ? 'right' : 'left' ] = `${ $layout.left.size }px`;
        }
        if (view[ 2 ] === 'r' && $layout.right.space === true) {
          css[ $q.lang.rtl === true ? 'left' : 'right' ] = `${ $layout.right.size }px`;
        }

        return css
      });

      function updateLayout (prop, val) {
        $layout.update('footer', prop, val);
      }

      function updateLocal (prop, val) {
        if (prop.value !== val) {
          prop.value = val;
        }
      }

      function onResize ({ height }) {
        updateLocal(size, height);
        updateLayout('size', height);
      }

      function updateRevealed () {
        if (props.reveal !== true) { return }

        const { direction, position, inflectionPoint } = $layout.scroll.value;

        updateLocal(revealed, (
          direction === 'up'
          || position - inflectionPoint < 100
          || $layout.height.value - containerHeight.value - position - size.value < 300
        ));
      }

      function onFocusin (evt) {
        if (revealOnFocus.value === true) {
          updateLocal(revealed, true);
        }

        emit('focusin', evt);
      }

      vue.watch(() => props.modelValue, val => {
        updateLayout('space', val);
        updateLocal(revealed, true);
        $layout.animate();
      });

      vue.watch(offset, val => {
        updateLayout('offset', val);
      });

      vue.watch(() => props.reveal, val => {
        val === false && updateLocal(revealed, props.modelValue);
      });

      vue.watch(revealed, val => {
        $layout.animate();
        emit('reveal', val);
      });

      vue.watch([ size, $layout.scroll, $layout.height ], updateRevealed);

      vue.watch(() => $q.screen.height, val => {
        $layout.isContainer.value !== true && updateLocal(windowHeight, val);
      });

      const instance = {};

      $layout.instances.footer = instance;
      props.modelValue === true && updateLayout('size', size.value);
      updateLayout('space', props.modelValue);
      updateLayout('offset', offset.value);

      vue.onBeforeUnmount(() => {
        if ($layout.instances.footer === instance) {
          $layout.instances.footer = void 0;
          updateLayout('size', 0);
          updateLayout('offset', 0);
          updateLayout('space', false);
        }
      });

      return () => {
        const child = hMergeSlot(slots.default, [
          vue.h(QResizeObserver, {
            debounce: 0,
            onResize
          })
        ]);

        props.elevated === true && child.push(
          vue.h('div', {
            class: 'q-layout__shadow absolute-full overflow-hidden no-pointer-events'
          })
        );

        return vue.h('footer', {
          class: classes.value,
          style: style.value,
          onFocusin
        }, child)
      }
    }
  });

  var QForm = vue.defineComponent({
    name: 'QForm',

    props: {
      autofocus: Boolean,
      noErrorFocus: Boolean,
      noResetFocus: Boolean,
      greedy: Boolean,

      onSubmit: Function
    },

    emits: [ 'reset', 'validation-success', 'validation-error' ],

    setup (props, { slots, emit }) {
      const vm = vue.getCurrentInstance();
      const rootRef = vue.ref(null);

      let validateIndex = 0;
      const registeredComponents = [];

      function validate (shouldFocus) {
        const promises = [];
        const focus = typeof shouldFocus === 'boolean'
          ? shouldFocus
          : props.noErrorFocus !== true;

        validateIndex++;

        const emitEvent = (res, ref) => {
          emit('validation-' + (res === true ? 'success' : 'error'), ref);
        };

        for (let i = 0; i < registeredComponents.length; i++) {
          const comp = registeredComponents[ i ];
          const valid = comp.validate();

          if (typeof valid.then === 'function') {
            promises.push(
              valid.then(
                valid => ({ valid, comp }),
                error => ({ valid: false, comp, error })
              )
            );
          }
          else if (valid !== true) {
            if (props.greedy === false) {
              emitEvent(false, comp);

              if (focus === true && typeof comp.focus === 'function') {
                comp.focus();
              }

              return Promise.resolve(false)
            }

            promises.push({ valid: false, comp });
          }
        }

        if (promises.length === 0) {
          emitEvent(true);
          return Promise.resolve(true)
        }

        const index = validateIndex;

        return Promise.all(promises).then(
          res => {
            if (index === validateIndex) {
              const errors = res.filter(r => r.valid !== true);

              if (errors.length === 0) {
                emitEvent(true);
                return true
              }

              const { valid, comp } = errors[ 0 ];

              emitEvent(false, comp);

              if (
                focus === true
                && valid !== true
                && typeof comp.focus === 'function'
              ) {
                comp.focus();
              }

              return false
            }
          }
        )
      }

      function resetValidation () {
        validateIndex++;

        registeredComponents.forEach(comp => {
          typeof comp.resetValidation === 'function' && comp.resetValidation();
        });
      }

      function submit (evt) {
        evt !== void 0 && stopAndPrevent(evt);

        validate().then(val => {
          if (val === true) {
            if (props.onSubmit !== void 0) {
              emit('submit', evt);
            }
            else if (evt !== void 0 && evt.target !== void 0 && typeof evt.target.submit === 'function') {
              evt.target.submit();
            }
          }
        });
      }

      function reset (evt) {
        evt !== void 0 && stopAndPrevent(evt);

        emit('reset');

        vue.nextTick(() => { // allow userland to reset values before
          resetValidation();
          if (props.autofocus === true && props.noResetFocus !== true) {
            focus();
          }
        });
      }

      function focus () {
        addFocusFn(() => {
          if (rootRef.value === null) { return }

          const target = rootRef.value.querySelector('[autofocus], [data-autofocus]')
            || Array.prototype.find.call(rootRef.value.querySelectorAll('[tabindex]'), el => el.tabIndex > -1);

          target !== null && target !== void 0 && target.focus();
        });
      }

      vue.provide(formKey, {
        bindComponent (vmProxy) {
          registeredComponents.push(vmProxy);
        },

        unbindComponent (vmProxy) {
          const index = registeredComponents.indexOf(vmProxy);
          if (index > -1) {
            registeredComponents.splice(index, 1);
          }
        }
      });

      vue.onMounted(() => {
        props.autofocus === true && focus();
      });

      // expose public methods
      Object.assign(vm.proxy, {
        validate,
        resetValidation,
        submit,
        reset,
        focus,
        getValidationComponents: () => registeredComponents
      });

      return () => vue.h('form', {
        class: 'q-form',
        ref: rootRef,
        onSubmit: submit,
        onReset: reset
      }, hSlot(slots.default))
    }
  });

  var QFormChildMixin = {
    inject: {
      [ formKey ]: {
        default: noop
      }
    },

    watch: {
      disable (val) {
        const $form = this.$.provides[ formKey ];
        if ($form !== void 0) {
          if (val === true) {
            this.resetValidation();
            $form.unbindComponent(this);
          }
          else {
            $form.bindComponent(this);
          }
        }
      }
    },

    methods: {
      validate () {},
      resetValidation () {}
    },

    created () {
      const $form = this.$.provides[ formKey ];
      $form !== void 0 && this.disable !== true && $form.bindComponent(this);
    },

    beforeUnmount () {
      const $form = this.$.provides[ formKey ];
      $form !== void 0 && this.disable !== true && $form.unbindComponent(this);
    }
  };

  var QHeader = vue.defineComponent({
    name: 'QHeader',

    props: {
      modelValue: {
        type: Boolean,
        default: true
      },
      reveal: Boolean,
      revealOffset: {
        type: Number,
        default: 250
      },
      bordered: Boolean,
      elevated: Boolean,

      heightHint: {
        type: [ String, Number ],
        default: 50
      }
    },

    emits: [ 'reveal', 'focusin' ],

    setup (props, { slots, emit }) {
      const { proxy: { $q } } = vue.getCurrentInstance();

      const $layout = vue.inject(layoutKey, () => {
        console.error('QHeader needs to be child of QLayout');
      });

      const size = vue.ref(parseInt(props.heightHint, 10));
      const revealed = vue.ref(true);

      const fixed = vue.computed(() =>
        props.reveal === true
        || $layout.view.value.indexOf('H') > -1
        || $layout.isContainer.value === true
      );

      const offset = vue.computed(() => {
        if (props.modelValue !== true) {
          return 0
        }
        if (fixed.value === true) {
          return revealed.value === true ? size.value : 0
        }
        const offset = size.value - $layout.scroll.value.position;
        return offset > 0 ? offset : 0
      });

      const hidden = vue.computed(() => props.modelValue !== true
        || (fixed.value === true && revealed.value !== true)
      );

      const revealOnFocus = vue.computed(() =>
        props.modelValue === true && hidden.value === true && props.reveal === true
      );

      const classes = vue.computed(() =>
        'q-header q-layout__section--marginal '
        + (fixed.value === true ? 'fixed' : 'absolute') + '-top'
        + (props.bordered === true ? ' q-header--bordered' : '')
        + (hidden.value === true ? ' q-header--hidden' : '')
        + (props.modelValue !== true ? ' q-layout--prevent-focus' : '')
      );

      const style = vue.computed(() => {
        const
          view = $layout.rows.value.top,
          css = {};

        if (view[ 0 ] === 'l' && $layout.left.space === true) {
          css[ $q.lang.rtl === true ? 'right' : 'left' ] = `${ $layout.left.size }px`;
        }
        if (view[ 2 ] === 'r' && $layout.right.space === true) {
          css[ $q.lang.rtl === true ? 'left' : 'right' ] = `${ $layout.right.size }px`;
        }

        return css
      });

      function updateLayout (prop, val) {
        $layout.update('header', prop, val);
      }

      function updateLocal (prop, val) {
        if (prop.value !== val) {
          prop.value = val;
        }
      }

      function onResize ({ height }) {
        updateLocal(size, height);
        updateLayout('size', height);
      }

      function onFocusin (evt) {
        if (revealOnFocus.value === true) {
          updateLocal(revealed, true);
        }

        emit('focusin', evt);
      }

      vue.watch(() => props.modelValue, val => {
        updateLayout('space', val);
        updateLocal(revealed, true);
        $layout.animate();
      });

      vue.watch(offset, val => {
        updateLayout('offset', val);
      });

      vue.watch(() => props.reveal, val => {
        val === false && updateLocal(revealed, props.modelValue);
      });

      vue.watch(revealed, val => {
        $layout.animate();
        emit('reveal', val);
      });

      vue.watch($layout.scroll, scroll => {
        props.reveal === true && updateLocal(revealed,
          scroll.direction === 'up'
          || scroll.position <= props.revealOffset
          || scroll.position - scroll.inflectionPoint < 100
        );
      });

      const instance = {};

      $layout.instances.header = instance;
      props.modelValue === true && updateLayout('size', size.value);
      updateLayout('space', props.modelValue);
      updateLayout('offset', offset.value);

      vue.onBeforeUnmount(() => {
        if ($layout.instances.header === instance) {
          $layout.instances.header = void 0;
          updateLayout('size', 0);
          updateLayout('offset', 0);
          updateLayout('space', false);
        }
      });

      return () => {
        const child = hUniqueSlot(slots.default, []);

        props.elevated === true && child.push(
          vue.h('div', {
            class: 'q-layout__shadow absolute-full overflow-hidden no-pointer-events'
          })
        );

        child.push(
          vue.h(QResizeObserver, {
            debounce: 0,
            onResize
          })
        );

        return vue.h('header', {
          class: classes.value,
          style: style.value,
          onFocusin
        }, child)
      }
    }
  });

  const useRatioProps = {
    ratio: [ String, Number ]
  };

  function useRatio (props, naturalRatio) {
    // return ratioStyle
    return vue.computed(() => {
      const ratio = Number(
        props.ratio || (naturalRatio !== void 0 ? naturalRatio.value : void 0)
      );

      return isNaN(ratio) !== true && ratio > 0
        ? { paddingBottom: `${ 100 / ratio }%` }
        : null
    })
  }

  const crossoriginValues = [ 'anonymous', 'use-credentials' ];
  const loadingValues = [ 'eager', 'lazy' ];
  const fitValues = [ 'cover', 'fill', 'contain', 'none', 'scale-down' ];

  var QImg = vue.defineComponent({
    name: 'QImg',

    props: {
      ...useRatioProps,

      src: String,
      srcset: String,
      sizes: String,
      alt: String,
      crossorigin: {
        type: String,
        validator: val => crossoriginValues.includes(val)
      },
      loading: {
        type: String,
        default: 'lazy',
        validator: val => loadingValues.includes(val)
      },
      width: String,
      height: String,

      placeholderSrc: String,

      fit: {
        type: String,
        default: 'cover',
        validator: val => fitValues.includes(val)
      },
      position: {
        type: String,
        default: '50% 50%'
      },

      imgClass: [ Array, String, Object ],
      imgStyle: Object,

      noSpinner: Boolean,
      noNativeMenu: Boolean,
      noTransition: Boolean,

      spinnerColor: String,
      spinnerSize: String
    },

    emits: [ 'load', 'error' ],

    setup (props, { slots, emit }) {
      const naturalRatio = vue.ref(0.5);
      const ratioStyle = useRatio(props, naturalRatio);

      let loadTimer;

      const images = [
        vue.ref(null),
        vue.ref(props.placeholderSrc !== void 0 ? { src: props.placeholderSrc } : null)
      ];

      const position = vue.ref(0);

      const isLoading = vue.ref(false);
      const hasError = vue.ref(false);

      const classes = vue.computed(() =>
        `q-img q-img--${ props.noNativeMenu === true ? 'no-' : '' }menu`
      );

      const style = vue.computed(() => ({
        width: props.width,
        height: props.height
      }));

      const imgClass = vue.computed(() =>
        `q-img__image q-img__image--with${ props.noTransition === true ? 'out' : '' }-transition`
      );

      const imgStyle = vue.computed(() => ({
        ...props.imgStyle,
        objectFit: props.fit,
        objectPosition: props.position
      }));

      vue.watch(() => getCurrentSrc(), addImage);

      function getCurrentSrc () {
        return props.src || props.srcset || props.sizes
          ? {
              src: props.src,
              srcset: props.srcset,
              sizes: props.sizes
            }
          : null
      }

      function addImage (imgProps) {
        clearTimeout(loadTimer);
        hasError.value = false;

        if (imgProps === null) {
          isLoading.value = false;
          images[ 0 ].value = null;
          images[ 1 ].value = null;
          return
        }

        isLoading.value = true;
        images[ position.value ].value = imgProps;
      }

      function onLoad ({ target }) {
        // if component has been already destroyed
        if (loadTimer === null) { return }

        clearTimeout(loadTimer);

        naturalRatio.value = target.naturalHeight === 0
          ? 0.5
          : target.naturalWidth / target.naturalHeight;

        waitForCompleteness(target, 1);
      }

      function waitForCompleteness (target, count) {
        // protect against running forever
        if (loadTimer === null || count === 1000) { return }

        if (target.complete === true) {
          onReady(target);
        }
        else {
          loadTimer = setTimeout(() => {
            waitForCompleteness(target, count + 1);
          }, 50);
        }
      }

      function onReady (img) {
        // if component has been already destroyed
        if (loadTimer === null) { return }

        position.value = position.value === 1 ? 0 : 1;
        images[ position.value ].value = null;
        isLoading.value = false;
        hasError.value = false;
        emit('load', img.currentSrc || img.src);
      }

      function onError (err) {
        clearTimeout(loadTimer);
        isLoading.value = false;
        hasError.value = true;
        images[ 0 ].value = null;
        images[ 1 ].value = null;
        emit('error', err);
      }

      function getContainer (key, child) {
        return vue.h(
          'div',
          { class: 'q-img__container absolute-full', key },
          child
        )
      }

      function getImage (index) {
        const img = images[ index ].value;

        const data = {
          key: 'img_' + index,
          class: imgClass.value,
          style: imgStyle.value,
          crossorigin: props.crossorigin,
          height: props.height,
          width: props.width,
          loading: props.loading,
          'aria-hidden': 'true',
          ...img
        };

        if (position.value === index) {
          data.class += ' q-img__image--waiting';
          Object.assign(data, { onLoad, onError });
        }
        else {
          data.class += ' q-img__image--loaded';
        }

        return getContainer('img' + index, vue.h('img', data))
      }

      function getContent () {
        if (isLoading.value !== true) {
          return vue.h('div', {
            key: 'content',
            class: 'q-img__content absolute-full q-anchor--skip'
          }, hSlot(slots[ hasError.value === true ? 'error' : 'default' ]))
        }

        return vue.h('div', {
          key: 'loading',
          class: 'q-img__loading absolute-full flex flex-center'
        }, (
          slots.loading !== void 0
            ? slots.loading()
            : (
                props.noSpinner === true
                  ? void 0
                  : [
                      vue.h(QSpinner, {
                        color: props.spinnerColor,
                        size: props.spinnerSize
                      })
                    ]
              )
        ))
      }

      {
        {
          addImage(getCurrentSrc());
        }

        vue.onBeforeUnmount(() => {
          clearTimeout(loadTimer);
          loadTimer = null;
        });
      }

      return () => {
        const content = [];

        if (ratioStyle.value !== null) {
          content.push(
            vue.h('div', { key: 'filler', style: ratioStyle.value })
          );
        }

        if (hasError.value !== true) {
          if (images[ 0 ].value !== null) {
            content.push(getImage(0));
          }

          if (images[ 1 ].value !== null) {
            content.push(getImage(1));
          }
        }

        content.push(
          vue.h(vue.Transition, { name: 'q-transition--fade' }, getContent)
        );

        return vue.h('div', {
          class: classes.value,
          style: style.value,
          role: 'img',
          'aria-label': props.alt
        }, content)
      }
    }
  });

  var QInfiniteScroll = vue.defineComponent({
    name: 'QInfiniteScroll',

    props: {
      offset: {
        type: Number,
        default: 500
      },

      debounce: {
        type: [ String, Number ],
        default: 100
      },

      scrollTarget: {
        default: void 0
      },

      initialIndex: Number,

      disable: Boolean,
      reverse: Boolean
    },

    emits: [ 'load' ],

    setup (props, { slots, emit }) {
      const fetching = vue.ref(false);
      const rootRef = vue.ref(null);

      let index = props.initialIndex || 0;
      let isWorking = true;
      let localScrollTarget, poll;

      const classes = vue.computed(() =>
        'q-infinite-scroll__loading'
        + (fetching.value === true ? '' : ' invisible')
      );

      function immediatePoll () {
        if (props.disable === true || fetching.value === true || isWorking === false) {
          return
        }

        const
          scrollHeight = getScrollHeight(localScrollTarget),
          scrollPosition = getVerticalScrollPosition(localScrollTarget),
          containerHeight = height(localScrollTarget);

        if (props.reverse === false) {
          if (scrollPosition + containerHeight + props.offset >= scrollHeight) {
            trigger();
          }
        }
        else {
          if (scrollPosition < props.offset) {
            trigger();
          }
        }
      }

      function trigger () {
        if (props.disable === true || fetching.value === true || isWorking === false) {
          return
        }

        index++;
        fetching.value = true;

        const heightBefore = getScrollHeight(localScrollTarget);

        emit('load', index, isDone => {
          if (isWorking === true) {
            fetching.value = false;
            vue.nextTick(() => {
              if (props.reverse === true) {
                const
                  heightAfter = getScrollHeight(localScrollTarget),
                  scrollPosition = getVerticalScrollPosition(localScrollTarget),
                  heightDifference = heightAfter - heightBefore;

                setVerticalScrollPosition(localScrollTarget, scrollPosition + heightDifference);
              }

              if (isDone === true) {
                stop();
              }
              else if (rootRef.value) {
                rootRef.value.closest('body') && poll();
              }
            });
          }
        });
      }

      function reset () {
        index = 0;
      }

      function resume () {
        if (isWorking === false) {
          isWorking = true;
          localScrollTarget.addEventListener('scroll', poll, listenOpts.passive);
        }

        immediatePoll();
      }

      function stop () {
        if (isWorking === true) {
          isWorking = false;
          fetching.value = false;
          localScrollTarget.removeEventListener('scroll', poll, listenOpts.passive);
        }
      }

      function updateScrollTarget () {
        if (localScrollTarget && isWorking === true) {
          localScrollTarget.removeEventListener('scroll', poll, listenOpts.passive);
        }

        localScrollTarget = getScrollTarget(rootRef.value, props.scrollTarget);

        if (isWorking === true) {
          localScrollTarget.addEventListener('scroll', poll, listenOpts.passive);
        }
      }

      function setIndex (newIndex) {
        index = newIndex;
      }

      // expose public methods
      const vm = vue.getCurrentInstance();
      Object.assign(vm.proxy, {
        poll: () => poll.apply(null, arguments),
        trigger, stop, reset, resume, setIndex
      });

      function setDebounce (val) {
        val = parseInt(val, 10);

        const oldPoll = poll;

        poll = val <= 0
          ? immediatePoll
          : debounce(immediatePoll, isNaN(val) === true ? 100 : val);

        if (localScrollTarget && isWorking === true) {
          if (oldPoll !== void 0) {
            localScrollTarget.removeEventListener('scroll', oldPoll, listenOpts.passive);
          }

          localScrollTarget.addEventListener('scroll', poll, listenOpts.passive);
        }
      }

      vue.watch(() => props.disable, val => {
        if (val === true) {
          stop();
        }
        else {
          resume();
        }
      });

      vue.watch(() => props.scrollTarget, updateScrollTarget);
      vue.watch(() => props.debounce, setDebounce);

      vue.onBeforeUnmount(() => {
        if (isWorking === true) {
          localScrollTarget.removeEventListener('scroll', poll, listenOpts.passive);
        }
      });

      vue.onMounted(() => {
        setDebounce(props.debounce);

        updateScrollTarget();

        if (props.reverse === true) {
          const
            scrollHeight = getScrollHeight(localScrollTarget),
            containerHeight = height(localScrollTarget);

          setVerticalScrollPosition(localScrollTarget, scrollHeight - containerHeight);
        }

        immediatePoll();
      });

      return () => {
        const child = hUniqueSlot(slots.default, []);

        if (props.disable !== true && isWorking === true) {
          child[ props.reverse === false ? 'push' : 'unshift' ](
            vue.h('div', { class: classes.value }, hSlot(slots.loading))
          );
        }

        return vue.h('div', {
          class: 'q-infinite-scroll',
          ref: rootRef
        }, child)
      }
    }
  });

  var QInnerLoading = vue.defineComponent({
    name: 'QInnerLoading',

    props: {
      ...useDarkProps,
      ...useTransitionProps,

      showing: Boolean,
      color: String,

      size: {
        type: [ String, Number ],
        default: 42
      }
    },

    setup (props, { slots }) {
      const vm = vue.getCurrentInstance();
      const isDark = useDark(props, vm.proxy.$q);

      const { transition, transitionStyle } = useTransition(props, vue.computed(() => props.showing));

      const classes = vue.computed(() =>
        'q-inner-loading absolute-full column flex-center'
        + (isDark.value === true ? ' q-inner-loading--dark' : '')
      );

      function getContent () {
        return props.showing === true
          ? vue.h(
              'div',
              { class: classes.value, style: transitionStyle.value },
              slots.default !== void 0
                ? slots.default()
                : [
                    vue.h(QSpinner, {
                      size: props.size,
                      color: props.color
                    })
                  ]
            )
          : null
      }

      return () => vue.h(vue.Transition, {
        name: transition.value,
        appear: true
      }, getContent)
    }
  });

  // leave NAMED_MASKS at top of file (code referenced from docs)
  const NAMED_MASKS = {
    date: '####/##/##',
    datetime: '####/##/## ##:##',
    time: '##:##',
    fulltime: '##:##:##',
    phone: '(###) ### - ####',
    card: '#### #### #### ####'
  };

  const TOKENS = {
    '#': { pattern: '[\\d]', negate: '[^\\d]' },

    S: { pattern: '[a-zA-Z]', negate: '[^a-zA-Z]' },
    N: { pattern: '[0-9a-zA-Z]', negate: '[^0-9a-zA-Z]' },

    A: { pattern: '[a-zA-Z]', negate: '[^a-zA-Z]', transform: v => v.toLocaleUpperCase() },
    a: { pattern: '[a-zA-Z]', negate: '[^a-zA-Z]', transform: v => v.toLocaleLowerCase() },

    X: { pattern: '[0-9a-zA-Z]', negate: '[^0-9a-zA-Z]', transform: v => v.toLocaleUpperCase() },
    x: { pattern: '[0-9a-zA-Z]', negate: '[^0-9a-zA-Z]', transform: v => v.toLocaleLowerCase() }
  };

  const KEYS = Object.keys(TOKENS);
  KEYS.forEach(key => {
    TOKENS[ key ].regex = new RegExp(TOKENS[ key ].pattern);
  });

  const
    tokenRegexMask = new RegExp('\\\\([^.*+?^${}()|([\\]])|([.*+?^${}()|[\\]])|([' + KEYS.join('') + '])|(.)', 'g'),
    escRegex = /[.*+?^${}()|[\]\\]/g;

  const MARKER = String.fromCharCode(1);

  const useMaskProps = {
    mask: String,
    reverseFillMask: Boolean,
    fillMask: [ Boolean, String ],
    unmaskedValue: Boolean
  };

  function useMask (props, emit, emitValue, inputRef) {
    let maskMarked, maskReplaced, computedMask, computedUnmask;

    const hasMask = vue.ref(null);
    const innerValue = vue.ref(getInitialMaskedValue());

    vue.watch(() => props.type, updateMaskInternals);

    vue.watch(() => props.mask, v => {
      if (v !== void 0) {
        updateMaskValue(innerValue.value, true);
      }
      else {
        const val = unmaskValue(innerValue.value);
        updateMaskInternals();
        props.modelValue !== val && emit('update:modelValue', val);
      }
    });

    vue.watch(() => props.fillMask + props.reverseFillMask, () => {
      hasMask.value === true && updateMaskValue(innerValue.value, true);
    });

    vue.watch(() => props.unmaskedValue, () => {
      hasMask.value === true && updateMaskValue(innerValue.value);
    });

    function getInitialMaskedValue () {
      updateMaskInternals();

      if (hasMask.value === true) {
        const masked = maskValue(unmaskValue(props.modelValue));

        return props.fillMask !== false
          ? fillWithMask(masked)
          : masked
      }

      return props.modelValue
    }

    function getPaddedMaskMarked (size) {
      if (size < maskMarked.length) {
        return maskMarked.slice(-size)
      }

      let pad = '', localMaskMarked = maskMarked;
      const padPos = localMaskMarked.indexOf(MARKER);

      if (padPos > -1) {
        for (let i = size - localMaskMarked.length; i > 0; i--) {
          pad += MARKER;
        }

        localMaskMarked = localMaskMarked.slice(0, padPos) + pad + localMaskMarked.slice(padPos);
      }

      return localMaskMarked
    }

    function updateMaskInternals () {
      hasMask.value = props.mask !== void 0
        && props.mask.length > 0
        && [ 'text', 'search', 'url', 'tel', 'password' ].includes(props.type);

      if (hasMask.value === false) {
        computedUnmask = void 0;
        maskMarked = '';
        maskReplaced = '';
        return
      }

      const
        localComputedMask = NAMED_MASKS[ props.mask ] === void 0
          ? props.mask
          : NAMED_MASKS[ props.mask ],
        fillChar = typeof props.fillMask === 'string' && props.fillMask.length > 0
          ? props.fillMask.slice(0, 1)
          : '_',
        fillCharEscaped = fillChar.replace(escRegex, '\\$&'),
        unmask = [],
        extract = [],
        mask = [];

      let
        firstMatch = props.reverseFillMask === true,
        unmaskChar = '',
        negateChar = '';

      localComputedMask.replace(tokenRegexMask, (_, char1, esc, token, char2) => {
        if (token !== void 0) {
          const c = TOKENS[ token ];
          mask.push(c);
          negateChar = c.negate;
          if (firstMatch === true) {
            extract.push('(?:' + negateChar + '+)?(' + c.pattern + '+)?(?:' + negateChar + '+)?(' + c.pattern + '+)?');
            firstMatch = false;
          }
          extract.push('(?:' + negateChar + '+)?(' + c.pattern + ')?');
        }
        else if (esc !== void 0) {
          unmaskChar = '\\' + (esc === '\\' ? '' : esc);
          mask.push(esc);
          unmask.push('([^' + unmaskChar + ']+)?' + unmaskChar + '?');
        }
        else {
          const c = char1 !== void 0 ? char1 : char2;
          unmaskChar = c === '\\' ? '\\\\\\\\' : c.replace(escRegex, '\\\\$&');
          mask.push(c);
          unmask.push('([^' + unmaskChar + ']+)?' + unmaskChar + '?');
        }
      });

      const
        unmaskMatcher = new RegExp(
          '^'
          + unmask.join('')
          + '(' + (unmaskChar === '' ? '.' : '[^' + unmaskChar + ']') + '+)?'
          + '$'
        ),
        extractLast = extract.length - 1,
        extractMatcher = extract.map((re, index) => {
          if (index === 0 && props.reverseFillMask === true) {
            return new RegExp('^' + fillCharEscaped + '*' + re)
          }
          else if (index === extractLast) {
            return new RegExp(
              '^' + re
              + '(' + (negateChar === '' ? '.' : negateChar) + '+)?'
              + (props.reverseFillMask === true ? '$' : fillCharEscaped + '*')
            )
          }

          return new RegExp('^' + re)
        });

      computedMask = mask;
      computedUnmask = val => {
        const unmaskMatch = unmaskMatcher.exec(val);
        if (unmaskMatch !== null) {
          val = unmaskMatch.slice(1).join('');
        }

        const
          extractMatch = [],
          extractMatcherLength = extractMatcher.length;

        for (let i = 0, str = val; i < extractMatcherLength; i++) {
          const m = extractMatcher[ i ].exec(str);

          if (m === null) {
            break
          }

          str = str.slice(m.shift().length);
          extractMatch.push(...m);
        }
        if (extractMatch.length > 0) {
          return extractMatch.join('')
        }

        return val
      };
      maskMarked = mask.map(v => (typeof v === 'string' ? v : MARKER)).join('');
      maskReplaced = maskMarked.split(MARKER).join(fillChar);
    }

    function updateMaskValue (rawVal, updateMaskInternalsFlag, inputType) {
      const
        inp = inputRef.value,
        end = inp.selectionEnd,
        endReverse = inp.value.length - end,
        unmasked = unmaskValue(rawVal);

      // Update here so unmask uses the original fillChar
      updateMaskInternalsFlag === true && updateMaskInternals();

      const
        preMasked = maskValue(unmasked),
        masked = props.fillMask !== false
          ? fillWithMask(preMasked)
          : preMasked,
        changed = innerValue.value !== masked;

      // We want to avoid "flickering" so we set value immediately
      inp.value !== masked && (inp.value = masked);

      changed === true && (innerValue.value = masked);

      document.activeElement === inp && vue.nextTick(() => {
        if (masked === maskReplaced) {
          const cursor = props.reverseFillMask === true ? maskReplaced.length : 0;
          inp.setSelectionRange(cursor, cursor, 'forward');

          return
        }

        if (inputType === 'insertFromPaste' && props.reverseFillMask !== true) {
          const cursor = end - 1;
          moveCursor.right(inp, cursor, cursor);

          return
        }

        if ([ 'deleteContentBackward', 'deleteContentForward' ].indexOf(inputType) > -1) {
          const cursor = props.reverseFillMask === true
            ? (
                end === 0
                  ? (masked.length > preMasked.length ? 1 : 0)
                  : Math.max(0, masked.length - (masked === maskReplaced ? 0 : Math.min(preMasked.length, endReverse) + 1)) + 1
              )
            : end;

          inp.setSelectionRange(cursor, cursor, 'forward');
          return
        }

        if (props.reverseFillMask === true) {
          if (changed === true) {
            const cursor = Math.max(0, masked.length - (masked === maskReplaced ? 0 : Math.min(preMasked.length, endReverse + 1)));

            if (cursor === 1 && end === 1) {
              inp.setSelectionRange(cursor, cursor, 'forward');
            }
            else {
              moveCursor.rightReverse(inp, cursor, cursor);
            }
          }
          else {
            const cursor = masked.length - endReverse;
            inp.setSelectionRange(cursor, cursor, 'backward');
          }
        }
        else {
          if (changed === true) {
            const cursor = Math.max(0, maskMarked.indexOf(MARKER), Math.min(preMasked.length, end) - 1);
            moveCursor.right(inp, cursor, cursor);
          }
          else {
            const cursor = end - 1;
            moveCursor.right(inp, cursor, cursor);
          }
        }
      });

      const val = props.unmaskedValue === true
        ? unmaskValue(masked)
        : masked;

      props.modelValue !== val && emitValue(val, true);
    }

    function moveCursorForPaste (inp, start, end) {
      const preMasked = maskValue(unmaskValue(inp.value));

      start = Math.max(0, maskMarked.indexOf(MARKER), Math.min(preMasked.length, start));

      inp.setSelectionRange(start, end, 'forward');
    }

    const moveCursor = {
      left (inp, start, end, selection) {
        const noMarkBefore = maskMarked.slice(start - 1).indexOf(MARKER) === -1;
        let i = Math.max(0, start - 1);

        for (; i >= 0; i--) {
          if (maskMarked[ i ] === MARKER) {
            start = i;
            noMarkBefore === true && start++;
            break
          }
        }

        if (
          i < 0
          && maskMarked[ start ] !== void 0
          && maskMarked[ start ] !== MARKER
        ) {
          return moveCursor.right(inp, 0, 0)
        }

        start >= 0 && inp.setSelectionRange(
          start,
          selection === true ? end : start, 'backward'
        );
      },

      right (inp, start, end, selection) {
        const limit = inp.value.length;
        let i = Math.min(limit, end + 1);

        for (; i <= limit; i++) {
          if (maskMarked[ i ] === MARKER) {
            end = i;
            break
          }
          else if (maskMarked[ i - 1 ] === MARKER) {
            end = i;
          }
        }

        if (
          i > limit
          && maskMarked[ end - 1 ] !== void 0
          && maskMarked[ end - 1 ] !== MARKER
        ) {
          return moveCursor.left(inp, limit, limit)
        }

        inp.setSelectionRange(selection ? start : end, end, 'forward');
      },

      leftReverse (inp, start, end, selection) {
        const
          localMaskMarked = getPaddedMaskMarked(inp.value.length);
        let i = Math.max(0, start - 1);

        for (; i >= 0; i--) {
          if (localMaskMarked[ i - 1 ] === MARKER) {
            start = i;
            break
          }
          else if (localMaskMarked[ i ] === MARKER) {
            start = i;
            if (i === 0) {
              break
            }
          }
        }

        if (
          i < 0
          && localMaskMarked[ start ] !== void 0
          && localMaskMarked[ start ] !== MARKER
        ) {
          return moveCursor.rightReverse(inp, 0, 0)
        }

        start >= 0 && inp.setSelectionRange(
          start,
          selection === true ? end : start, 'backward'
        );
      },

      rightReverse (inp, start, end, selection) {
        const
          limit = inp.value.length,
          localMaskMarked = getPaddedMaskMarked(limit),
          noMarkBefore = localMaskMarked.slice(0, end + 1).indexOf(MARKER) === -1;
        let i = Math.min(limit, end + 1);

        for (; i <= limit; i++) {
          if (localMaskMarked[ i - 1 ] === MARKER) {
            end = i;
            end > 0 && noMarkBefore === true && end--;
            break
          }
        }

        if (
          i > limit
          && localMaskMarked[ end - 1 ] !== void 0
          && localMaskMarked[ end - 1 ] !== MARKER
        ) {
          return moveCursor.leftReverse(inp, limit, limit)
        }

        inp.setSelectionRange(selection === true ? start : end, end, 'forward');
      }
    };

    function onMaskedKeydown (e) {
      if (shouldIgnoreKey(e) === true) {
        return
      }

      const
        inp = inputRef.value,
        start = inp.selectionStart,
        end = inp.selectionEnd;

      if (e.keyCode === 37 || e.keyCode === 39) { // Left / Right
        const fn = moveCursor[ (e.keyCode === 39 ? 'right' : 'left') + (props.reverseFillMask === true ? 'Reverse' : '') ];

        e.preventDefault();
        fn(inp, start, end, e.shiftKey);
      }
      else if (
        e.keyCode === 8 // Backspace
        && props.reverseFillMask !== true
        && start === end
      ) {
        moveCursor.left(inp, start, end, true);
      }
      else if (
        e.keyCode === 46 // Delete
        && props.reverseFillMask === true
        && start === end
      ) {
        moveCursor.rightReverse(inp, start, end, true);
      }
    }

    function maskValue (val) {
      if (val === void 0 || val === null || val === '') { return '' }

      if (props.reverseFillMask === true) {
        return maskValueReverse(val)
      }

      const mask = computedMask;

      let valIndex = 0, output = '';

      for (let maskIndex = 0; maskIndex < mask.length; maskIndex++) {
        const
          valChar = val[ valIndex ],
          maskDef = mask[ maskIndex ];

        if (typeof maskDef === 'string') {
          output += maskDef;
          valChar === maskDef && valIndex++;
        }
        else if (valChar !== void 0 && maskDef.regex.test(valChar)) {
          output += maskDef.transform !== void 0
            ? maskDef.transform(valChar)
            : valChar;
          valIndex++;
        }
        else {
          return output
        }
      }

      return output
    }

    function maskValueReverse (val) {
      const
        mask = computedMask,
        firstTokenIndex = maskMarked.indexOf(MARKER);

      let valIndex = val.length - 1, output = '';

      for (let maskIndex = mask.length - 1; maskIndex >= 0 && valIndex > -1; maskIndex--) {
        const maskDef = mask[ maskIndex ];

        let valChar = val[ valIndex ];

        if (typeof maskDef === 'string') {
          output = maskDef + output;
          valChar === maskDef && valIndex--;
        }
        else if (valChar !== void 0 && maskDef.regex.test(valChar)) {
          do {
            output = (maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar) + output;
            valIndex--;
            valChar = val[ valIndex ];
          // eslint-disable-next-line no-unmodified-loop-condition
          } while (firstTokenIndex === maskIndex && valChar !== void 0 && maskDef.regex.test(valChar))
        }
        else {
          return output
        }
      }

      return output
    }

    function unmaskValue (val) {
      return typeof val !== 'string' || computedUnmask === void 0
        ? (typeof val === 'number' ? computedUnmask('' + val) : val)
        : computedUnmask(val)
    }

    function fillWithMask (val) {
      if (maskReplaced.length - val.length <= 0) {
        return val
      }

      return props.reverseFillMask === true && val.length > 0
        ? maskReplaced.slice(0, -val.length) + val
        : val + maskReplaced.slice(val.length)
    }

    return {
      innerValue,
      hasMask,
      moveCursorForPaste,
      updateMaskValue,
      onMaskedKeydown
    }
  }

  const isJapanese = /[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\uff00-\uff9f\u4e00-\u9faf\u3400-\u4dbf]/;
  const isChinese = /[\u4e00-\u9fff\u3400-\u4dbf\u{20000}-\u{2a6df}\u{2a700}-\u{2b73f}\u{2b740}-\u{2b81f}\u{2b820}-\u{2ceaf}\uf900-\ufaff\u3300-\u33ff\ufe30-\ufe4f\uf900-\ufaff\u{2f800}-\u{2fa1f}]/u;
  const isKorean = /[\u3131-\u314e\u314f-\u3163\uac00-\ud7a3]/;

  function useKeyComposition (onInput) {
    return function onComposition (e) {
      if (e.type === 'compositionend' || e.type === 'change') {
        if (e.target.composing !== true) { return }
        e.target.composing = false;
        onInput(e);
      }
      else if (e.type === 'compositionupdate') {
        if (
          typeof e.data === 'string'
          && isJapanese.test(e.data) === false
          && isChinese.test(e.data) === false
          && isKorean.test(e.data) === false
        ) {
          e.target.composing = false;
        }
      }
      else {
        e.target.composing = true;
      }
    }
  }

  var QInput = vue.defineComponent({
    name: 'QInput',

    inheritAttrs: false,

    props: {
      ...useFieldProps,
      ...useMaskProps,
      ...useFormProps,

      modelValue: { required: false },

      shadowText: String,

      type: {
        type: String,
        default: 'text'
      },

      debounce: [ String, Number ],

      autogrow: Boolean, // makes a textarea

      inputClass: [ Array, String, Object ],
      inputStyle: [ Array, String, Object ]
    },

    emits: [
      ...useFieldEmits,
      'paste', 'change'
    ],

    setup (props, { emit, attrs }) {
      const temp = {};
      let emitCachedValue = NaN, typedNumber, stopValueWatcher, emitTimer, emitValueFn;

      const inputRef = vue.ref(null);
      const nameProp = useFormInputNameAttr(props);

      const {
        innerValue,
        hasMask,
        moveCursorForPaste,
        updateMaskValue,
        onMaskedKeydown
      } = useMask(props, emit, emitValue, inputRef);

      const formDomProps = useFileFormDomProps(props, /* type guard */ true);
      const hasValue = vue.computed(() => fieldValueIsFilled(innerValue.value));

      const onComposition = useKeyComposition(onInput);

      const state = useFieldState();

      const isTextarea = vue.computed(() =>
        props.type === 'textarea' || props.autogrow === true
      );

      const onEvents = vue.computed(() => {
        const evt = {
          ...state.splitAttrs.listeners.value,
          onInput,
          onPaste,
          // Safari < 10.2 & UIWebView doesn't fire compositionend when
          // switching focus before confirming composition choice
          // this also fixes the issue where some browsers e.g. iOS Chrome
          // fires "change" instead of "input" on autocomplete.
          onChange,
          onBlur: onFinishEditing,
          onFocus: stop
        };

        evt.onCompositionstart = evt.onCompositionupdate = evt.onCompositionend = onComposition;

        if (hasMask.value === true) {
          evt.onKeydown = onMaskedKeydown;
        }

        if (props.autogrow === true) {
          evt.onAnimationend = adjustHeight;
        }

        return evt
      });

      const inputAttrs = vue.computed(() => {
        const attrs = {
          tabindex: 0,
          'data-autofocus': props.autofocus === true || void 0,
          rows: props.type === 'textarea' ? 6 : void 0,
          'aria-label': props.label,
          name: nameProp.value,
          ...state.splitAttrs.attributes.value,
          id: state.targetUid.value,
          maxlength: props.maxlength,
          disabled: props.disable === true,
          readonly: props.readonly === true
        };

        if (isTextarea.value === false) {
          attrs.type = props.type;
        }

        if (props.autogrow === true) {
          attrs.rows = 1;
        }

        return attrs
      });

      vue.watch(() => props.modelValue, v => {
        if (hasMask.value === true) {
          if (stopValueWatcher === true) {
            stopValueWatcher = false;
            return
          }

          updateMaskValue(v);
        }
        else if (innerValue.value !== v) {
          innerValue.value = v;

          if (
            props.type === 'number'
            && temp.hasOwnProperty('value') === true
          ) {
            if (typedNumber === true) {
              typedNumber = false;
            }
            else {
              delete temp.value;
            }
          }
        }

        // textarea only
        props.autogrow === true && vue.nextTick(adjustHeight);
      });

      vue.watch(() => props.autogrow, val => {
        // textarea only
        if (val === true) {
          vue.nextTick(adjustHeight);
        }
        // if it has a number of rows set respect it
        else if (inputRef.value !== null && attrs.rows > 0) {
          inputRef.value.style.height = 'auto';
        }
      });

      vue.watch(() => props.dense, () => {
        props.autogrow === true && vue.nextTick(adjustHeight);
      });

      function focus () {
        addFocusFn(() => {
          const el = document.activeElement;
          if (
            inputRef.value !== null
            && inputRef.value !== el
            && (el === null || el.id !== state.targetUid.value)
          ) {
            inputRef.value.focus();
          }
        });
      }

      function select () {
        inputRef.value !== null && inputRef.value.select();
      }

      function onPaste (e) {
        if (hasMask.value === true && props.reverseFillMask !== true) {
          const inp = e.target;
          moveCursorForPaste(inp, inp.selectionStart, inp.selectionEnd);
        }

        emit('paste', e);
      }

      function onInput (e) {
        if (!e || !e.target || e.target.composing === true) {
          return
        }

        if (props.type === 'file') {
          emit('update:modelValue', e.target.files);
          return
        }

        const val = e.target.value;

        if (hasMask.value === true) {
          updateMaskValue(val, false, e.inputType);
        }
        else {
          emitValue(val);

          if ([ 'text', 'search', 'url', 'tel', 'password' ].includes(props.type) && e.target === document.activeElement) {
            const { selectionStart, selectionEnd } = e.target;

            if (selectionStart !== void 0 && selectionEnd !== void 0) {
              vue.nextTick(() => {
                if (e.target === document.activeElement && val.indexOf(e.target.value) === 0) {
                  e.target.setSelectionRange(selectionStart, selectionEnd);
                }
              });
            }
          }
        }

        // we need to trigger it immediately too,
        // to avoid "flickering"
        props.autogrow === true && adjustHeight();
      }

      function emitValue (val, stopWatcher) {
        emitValueFn = () => {
          if (
            props.type !== 'number'
            && temp.hasOwnProperty('value') === true
          ) {
            delete temp.value;
          }

          if (props.modelValue !== val && emitCachedValue !== val) {
            stopWatcher === true && (stopValueWatcher = true);
            emit('update:modelValue', val);

            vue.nextTick(() => {
              emitCachedValue === val && (emitCachedValue = NaN);
            });
          }

          emitValueFn = void 0;
        };

        if (props.type === 'number') {
          typedNumber = true;
          temp.value = val;
        }

        if (props.debounce !== void 0) {
          clearTimeout(emitTimer);
          temp.value = val;
          emitTimer = setTimeout(emitValueFn, props.debounce);
        }
        else {
          emitValueFn();
        }
      }

      // textarea only
      function adjustHeight () {
        const inp = inputRef.value;
        if (inp !== null) {
          const parentStyle = inp.parentNode.style;

          // reset height of textarea to a small size to detect the real height
          // but keep the total control size the same
          parentStyle.marginBottom = (inp.scrollHeight - 1) + 'px';
          inp.style.height = '1px';

          inp.style.height = inp.scrollHeight + 'px';
          parentStyle.marginBottom = '';
        }
      }

      function onChange (e) {
        onComposition(e);

        clearTimeout(emitTimer);
        emitValueFn !== void 0 && emitValueFn();

        emit('change', e.target.value);
      }

      function onFinishEditing (e) {
        e !== void 0 && stop(e);

        clearTimeout(emitTimer);
        emitValueFn !== void 0 && emitValueFn();

        typedNumber = false;
        stopValueWatcher = false;
        delete temp.value;

        // we need to use setTimeout instead of this.$nextTick
        // to avoid a bug where focusout is not emitted for type date/time/week/...
        props.type !== 'file' && setTimeout(() => {
          if (inputRef.value !== null) {
            inputRef.value.value = innerValue.value !== void 0 ? innerValue.value : '';
          }
        });
      }

      function getCurValue () {
        return temp.hasOwnProperty('value') === true
          ? temp.value
          : (innerValue.value !== void 0 ? innerValue.value : '')
      }

      vue.onBeforeUnmount(() => {
        onFinishEditing();
      });

      vue.onMounted(() => {
        // textarea only
        props.autogrow === true && adjustHeight();
      });

      Object.assign(state, {
        innerValue,

        fieldClass: vue.computed(() =>
          `q-${ isTextarea.value === true ? 'textarea' : 'input' }`
          + (props.autogrow === true ? ' q-textarea--autogrow' : '')
        ),

        hasShadow: vue.computed(() =>
          props.type !== 'file'
          && typeof props.shadowText === 'string'
          && props.shadowText.length > 0
        ),

        inputRef,

        emitValue,

        hasValue,

        floatingLabel: vue.computed(() =>
          hasValue.value === true
          || fieldValueIsFilled(props.displayValue)
        ),

        getControl: () => {
          return vue.h(isTextarea.value === true ? 'textarea' : 'input', {
            ref: inputRef,
            class: [
              'q-field__native q-placeholder',
              props.inputClass
            ],
            style: props.inputStyle,
            ...inputAttrs.value,
            ...onEvents.value,
            ...(
              props.type !== 'file'
                ? { value: getCurValue() }
                : formDomProps.value
            )
          })
        },

        getShadowControl: () => {
          return vue.h('div', {
            class: 'q-field__native q-field__shadow absolute-bottom no-pointer-events'
              + (isTextarea.value === true ? '' : ' text-no-wrap')
          }, [
            vue.h('span', { class: 'invisible' }, getCurValue()),
            vue.h('span', props.shadowText)
          ])
        }
      });

      const renderFn = useField(state);

      // expose public methods
      const vm = vue.getCurrentInstance();
      Object.assign(vm.proxy, {
        focus,
        select,
        getNativeElement: () => inputRef.value
      });

      return renderFn
    }
  });

  const defaultCfg$1 = {
    threshold: 0,
    root: null,
    rootMargin: '0px'
  };

  function update$3 (el, ctx, value) {
    let handler, cfg, changed;

    if (typeof value === 'function') {
      handler = value;
      cfg = defaultCfg$1;
      changed = ctx.cfg === void 0;
    }
    else {
      handler = value.handler;
      cfg = Object.assign({}, defaultCfg$1, value.cfg);
      changed = ctx.cfg === void 0 || isDeepEqual(ctx.cfg, cfg) === false;
    }

    if (ctx.handler !== handler) {
      ctx.handler = handler;
    }

    if (changed === true) {
      ctx.cfg = cfg;
      ctx.observer !== void 0 && ctx.observer.unobserve(el);

      ctx.observer = new IntersectionObserver(([ entry ]) => {
        if (typeof ctx.handler === 'function') {
          // if observed element is part of a vue transition
          // then we need to be careful...
          if (
            entry.rootBounds === null
            && document.body.contains(el) === true
          ) {
            ctx.observer.unobserve(el);
            ctx.observer.observe(el);
            return
          }

          const res = ctx.handler(entry, ctx.observer);

          if (
            res === false
            || (ctx.once === true && entry.isIntersecting === true)
          ) {
            destroy$1(el);
          }
        }
      }, cfg);

      ctx.observer.observe(el);
    }
  }

  function destroy$1 (el) {
    const ctx = el.__qvisible;

    if (ctx !== void 0) {
      ctx.observer !== void 0 && ctx.observer.unobserve(el);
      delete el.__qvisible;
    }
  }

  var Intersection = {
        name: 'intersection',

        mounted (el, { modifiers, value }) {
          const ctx = {
            once: modifiers.once === true
          };

          update$3(el, ctx, value);

          el.__qvisible = ctx;
        },

        updated (el, binding) {
          const ctx = el.__qvisible;
          ctx !== void 0 && update$3(el, ctx, binding.value);
        },

        beforeUnmount: destroy$1
      };

  var QIntersection = vue.defineComponent({
    name: 'QIntersection',

    props: {
      tag: {
        type: String,
        default: 'div'
      },

      once: Boolean,
      transition: String,

      ssrPrerender: Boolean,

      margin: String,
      threshold: [ Number, Array ],
      root: {
        default: null
      },

      disable: Boolean,

      onVisibility: Function
    },

    setup (props, { slots, emit }) {
      const showing = vue.ref(isRuntimeSsrPreHydration.value === true ? props.ssrPrerender : false);

      const intersectionProps = vue.computed(() => (
        props.margin !== void 0 || props.threshold !== void 0
          ? {
              handler: trigger,
              cfg: {
                root: props.root,
                rootMargin: props.margin,
                threshold: props.threshold
              }
            }
          : trigger
      ));

      const hasDirective = vue.computed(() =>
        props.disable !== true
        && (isRuntimeSsrPreHydration.value !== true || props.once !== true || props.ssrPrerender !== true)
      );

      const directives = vue.computed(() => {
        // if hasDirective.value === true
        return [ [
          Intersection,
          intersectionProps.value,
          void 0,
          { once: props.once }
        ] ]
      });

      function trigger (entry) {
        if (showing.value !== entry.isIntersecting) {
          showing.value = entry.isIntersecting;
          props.onVisibility !== void 0 && emit('visibility', showing.value);
        }
      }

      function getContent () {
        return showing.value === true
          ? [ vue.h('div', { key: 'content' }, hSlot(slots.default)) ]
          : void 0
      }

      return () => {
        const child = props.transition
          ? [
              vue.h(vue.Transition, {
                name: 'q-transition--' + props.transition
              }, getContent)
            ]
          : getContent();

        return hDir(
          props.tag,
          { class: 'q-intersection' },
          child,
          'main',
          hasDirective.value,
          () => directives.value
        )
      }
    }
  });

  var QList = vue.defineComponent({
    name: 'QList',

    props: {
      ...useDarkProps,

      bordered: Boolean,
      dense: Boolean,
      separator: Boolean,
      padding: Boolean
    },

    setup (props, { slots }) {
      const vm = vue.getCurrentInstance();
      const isDark = useDark(props, vm.proxy.$q);

      const classes = vue.computed(() =>
        'q-list'
        + (props.bordered === true ? ' q-list--bordered' : '')
        + (props.dense === true ? ' q-list--dense' : '')
        + (props.separator === true ? ' q-list--separator' : '')
        + (isDark.value === true ? ' q-list--dark' : '')
        + (props.padding === true ? ' q-list--padding' : '')
      );

      return () => vue.h('div', { class: classes.value }, hSlot(slots.default))
    }
  });

  // PGDOWN, LEFT, DOWN, PGUP, RIGHT, UP
  const keyCodes$1 = [ 34, 37, 40, 33, 39, 38 ];
  const commonPropsName = Object.keys(useCircularCommonProps);

  var QKnob = vue.defineComponent({
    name: 'QKnob',

    props: {
      ...useFormProps,
      ...useCircularCommonProps,

      modelValue: {
        type: Number,
        required: true
      },

      step: {
        type: Number,
        default: 1,
        validator: v => v >= 0
      },

      tabindex: {
        type: [ Number, String ],
        default: 0
      },

      disable: Boolean,
      readonly: Boolean
    },

    emits: [ 'update:modelValue', 'change', 'drag-value' ],

    setup (props, { slots, emit }) {
      const { proxy } = vue.getCurrentInstance();
      const { $q } = proxy;

      const model = vue.ref(props.modelValue);
      const dragging = vue.ref(false);

      let centerPosition, $el;

      vue.watch(() => props.modelValue, val => {
        if (val < props.min) {
          model.value = props.min;
        }
        else if (val > props.max) {
          model.value = props.max;
        }
        else {
          if (val !== model.value) {
            model.value = val;
          }
          return
        }

        if (model.value !== props.modelValue) {
          emit('update:modelValue', model.value);
          emit('change', model.value);
        }
      });

      const editable = vue.computed(() => props.disable === false && props.readonly === false);

      const classes = vue.computed(() =>
        'q-knob non-selectable' + (
          editable.value === true
            ? ' q-knob--editable'
            : (props.disable === true ? ' disabled' : '')
        )
      );

      const decimals = vue.computed(() => (String(props.step).trim('0').split('.')[ 1 ] || '').length);
      const step = vue.computed(() => (props.step === 0 ? 1 : props.step));
      const instantFeedback = vue.computed(() => props.instantFeedback === true || dragging.value === true);

      const onEvents = $q.platform.is.mobile === true
        ? vue.computed(() => (editable.value === true ? { onClick } : {}))
        : vue.computed(() => (
          editable.value === true
            ? {
                onMousedown,
                onClick,
                onKeydown,
                onKeyup
              }
            : {}
        ));

      const attrs = vue.computed(() => (
        editable.value === true
          ? { tabindex: props.tabindex }
          : { [ `aria-${ props.disable === true ? 'disabled' : 'readonly' }` ]: 'true' }
      ));

      const circularProps = vue.computed(() => {
        const agg = {};
        commonPropsName.forEach(name => {
          agg[ name ] = props[ name ];
        });
        return agg
      });

      function pan (event) {
        if (event.isFinal) {
          updatePosition(event.evt, true);
          dragging.value = false;
        }
        else if (event.isFirst) {
          updateCenterPosition();
          dragging.value = true;
          updatePosition(event.evt);
        }
        else {
          updatePosition(event.evt);
        }
      }

      const directives = vue.computed(() => {
        return [ [
          TouchPan,
          pan,
          void 0,
          { prevent: true, stop: true, mouse: true }
        ] ]
      });

      function updateCenterPosition () {
        const { top, left, width, height } = $el.getBoundingClientRect();
        centerPosition = {
          top: top + height / 2,
          left: left + width / 2
        };
      }

      function onMousedown (evt) {
        updateCenterPosition();
        updatePosition(evt);
      }

      function onClick (evt) {
        updateCenterPosition();
        updatePosition(evt, true);
      }

      function onKeydown (evt) {
        if (!keyCodes$1.includes(evt.keyCode)) {
          return
        }

        stopAndPrevent(evt);

        const
          stepVal = ([ 34, 33 ].includes(evt.keyCode) ? 10 : 1) * step.value,
          offset = [ 34, 37, 40 ].includes(evt.keyCode) ? -stepVal : stepVal;

        model.value = between(
          parseFloat((model.value + offset).toFixed(decimals.value)),
          props.min,
          props.max
        );

        updateValue();
      }

      function updatePosition (evt, change) {
        const
          pos = position(evt),
          height = Math.abs(pos.top - centerPosition.top),
          distance = Math.sqrt(
            height ** 2
            + Math.abs(pos.left - centerPosition.left) ** 2
          );

        let angle = Math.asin(height / distance) * (180 / Math.PI);

        if (pos.top < centerPosition.top) {
          angle = centerPosition.left < pos.left ? 90 - angle : 270 + angle;
        }
        else {
          angle = centerPosition.left < pos.left ? angle + 90 : 270 - angle;
        }

        if (props.angle) {
          angle = normalizeToInterval(angle - props.angle, 0, 360);
        }

        if ($q.lang.rtl === true) {
          angle = 360 - angle;
        }

        let newModel = props.min + (angle / 360) * (props.max - props.min);

        if (step.value !== 0) {
          const modulo = newModel % step.value;

          newModel = newModel - modulo
            + (Math.abs(modulo) >= step.value / 2 ? (modulo < 0 ? -1 : 1) * step.value : 0);

          newModel = parseFloat(newModel.toFixed(decimals.value));
        }

        newModel = between(newModel, props.min, props.max);

        emit('drag-value', newModel);

        if (model.value !== newModel) {
          model.value = newModel;
        }

        updateValue(change);
      }

      function onKeyup (evt) {
        if (keyCodes$1.includes(evt.keyCode)) {
          updateValue(true);
        }
      }

      function updateValue (change) {
        props.modelValue !== model.value && emit('update:modelValue', model.value);
        change === true && emit('change', model.value);
      }

      const formAttrs = useFormAttrs(props);

      function getNameInput () {
        return vue.h('input', formAttrs.value)
      }

      vue.onMounted(() => {
        $el = proxy.$el;
      });

      return () => {
        const data = {
          class: classes.value,
          role: 'slider',
          'aria-valuemin': props.min,
          'aria-valuemax': props.max,
          'aria-valuenow': props.modelValue,
          ...attrs.value,
          ...circularProps.value,
          value: model.value,
          instantFeedback: instantFeedback.value,
          ...onEvents.value
        };

        const child = {
          default: slots.default
        };

        if (editable.value === true) {
          if (props.name !== void 0) {
            child.internal = getNameInput;
          }

          return vue.withDirectives(
            vue.h(QCircularProgress, data, child),
            directives.value
          )
        }

        return vue.h(QCircularProgress, data, child)
      }
    }
  });

  const { passive: passive$2 } = listenOpts;
  const axisValues = [ 'both', 'horizontal', 'vertical' ];

  var QScrollObserver = vue.defineComponent({
    name: 'QScrollObserver',

    props: {
      axis: {
        type: String,
        validator: v => axisValues.includes(v),
        default: 'vertical'
      },

      debounce: [ String, Number ],

      scrollTarget: {
        default: void 0
      }
    },

    emits: [ 'scroll' ],

    setup (props, { emit }) {
      const scroll = {
        position: {
          top: 0,
          left: 0
        },

        direction: 'down',
        directionChanged: false,

        delta: {
          top: 0,
          left: 0
        },

        inflectionPoint: {
          top: 0,
          left: 0
        }
      };

      let timer = null, localScrollTarget, parentEl;

      vue.watch(() => props.scrollTarget, () => {
        unconfigureScrollTarget();
        configureScrollTarget();
      });

      function emitEvent () {
        timer = null;

        const top = Math.max(0, getVerticalScrollPosition(localScrollTarget));
        const left = getHorizontalScrollPosition(localScrollTarget);

        const delta = {
          top: top - scroll.position.top,
          left: left - scroll.position.left
        };

        if (
          (props.axis === 'vertical' && delta.top === 0)
          || (props.axis === 'horizontal' && delta.left === 0)
        ) {
          return
        }

        const curDir = Math.abs(delta.top) >= Math.abs(delta.left)
          ? (delta.top < 0 ? 'up' : 'down')
          : (delta.left < 0 ? 'left' : 'right');

        scroll.position = { top, left };
        scroll.directionChanged = scroll.direction !== curDir;
        scroll.delta = delta;

        if (scroll.directionChanged === true) {
          scroll.direction = curDir;
          scroll.inflectionPoint = scroll.position;
        }

        emit('scroll', { ...scroll });
      }

      function configureScrollTarget () {
        localScrollTarget = getScrollTarget(parentEl, props.scrollTarget);
        localScrollTarget.addEventListener('scroll', trigger, passive$2);
        trigger(true);
      }

      function unconfigureScrollTarget () {
        if (localScrollTarget !== void 0) {
          localScrollTarget.removeEventListener('scroll', trigger, passive$2);
          localScrollTarget = void 0;
        }
      }

      function trigger (immediately) {
        if (immediately === true || props.debounce === 0 || props.debounce === '0') {
          emitEvent();
        }
        else if (timer === null) {
          timer = props.debounce
            ? setTimeout(emitEvent, props.debounce)
            : requestAnimationFrame(emitEvent);
        }
      }

      const vm = vue.getCurrentInstance();

      vue.onMounted(() => {
        parentEl = vm.proxy.$el.parentNode;
        configureScrollTarget();
      });

      vue.onBeforeUnmount(() => {
        clearTimeout(timer);
        cancelAnimationFrame(timer);
        unconfigureScrollTarget();
      });

      // expose public methods
      Object.assign(vm.proxy, {
        trigger,
        getPosition: () => scroll
      });

      return noop
    }
  });

  var QLayout = vue.defineComponent({
    name: 'QLayout',

    props: {
      container: Boolean,
      view: {
        type: String,
        default: 'hhh lpr fff',
        validator: v => /^(h|l)h(h|r) lpr (f|l)f(f|r)$/.test(v.toLowerCase())
      },

      onScroll: Function,
      onScrollHeight: Function,
      onResize: Function
    },

    setup (props, { slots, emit }) {
      const { proxy: { $q } } = vue.getCurrentInstance();

      const rootRef = vue.ref(null);

      // page related
      const height = vue.ref($q.screen.height);
      const width = vue.ref(props.container === true ? 0 : $q.screen.width);
      const scroll = vue.ref({ position: 0, direction: 'down', inflectionPoint: 0 });

      // container only prop
      const containerHeight = vue.ref(0);
      const scrollbarWidth = vue.ref(isRuntimeSsrPreHydration.value === true ? 0 : getScrollbarWidth());

      const classes = vue.computed(() =>
        'q-layout q-layout--'
        + (props.container === true ? 'containerized' : 'standard')
      );

      const style = vue.computed(() => (
        props.container === false
          ? { minHeight: $q.screen.height + 'px' }
          : null
      ));

      // used by container only
      const targetStyle = vue.computed(() => (
        scrollbarWidth.value !== 0
          ? { [ $q.lang.rtl === true ? 'left' : 'right' ]: `${ scrollbarWidth.value }px` }
          : null
      ));

      const targetChildStyle = vue.computed(() => (
        scrollbarWidth.value !== 0
          ? {
              [ $q.lang.rtl === true ? 'right' : 'left' ]: 0,
              [ $q.lang.rtl === true ? 'left' : 'right' ]: `-${ scrollbarWidth.value }px`,
              width: `calc(100% + ${ scrollbarWidth.value }px)`
            }
          : null
      ));

      function onPageScroll (data) {
        if (props.container === true || document.qScrollPrevented !== true) {
          const info = {
            position: data.position.top,
            direction: data.direction,
            directionChanged: data.directionChanged,
            inflectionPoint: data.inflectionPoint.top,
            delta: data.delta.top
          };

          scroll.value = info;
          props.onScroll !== void 0 && emit('scroll', info);
        }
      }

      function onPageResize (data) {
        const { height: newHeight, width: newWidth } = data;
        let resized = false;

        if (height.value !== newHeight) {
          resized = true;
          height.value = newHeight;
          props.onScrollHeight !== void 0 && emit('scroll-height', newHeight);
          updateScrollbarWidth();
        }
        if (width.value !== newWidth) {
          resized = true;
          width.value = newWidth;
        }

        if (resized === true && props.onResize !== void 0) {
          emit('resize', data);
        }
      }

      function onContainerResize ({ height }) {
        if (containerHeight.value !== height) {
          containerHeight.value = height;
          updateScrollbarWidth();
        }
      }

      function updateScrollbarWidth () {
        if (props.container === true) {
          const width = height.value > containerHeight.value
            ? getScrollbarWidth()
            : 0;

          if (scrollbarWidth.value !== width) {
            scrollbarWidth.value = width;
          }
        }
      }

      let timer;

      const $layout = {
        instances: {},
        view: vue.computed(() => props.view),
        isContainer: vue.computed(() => props.container),

        rootRef,

        height,
        containerHeight,
        scrollbarWidth,
        totalWidth: vue.computed(() => width.value + scrollbarWidth.value),

        rows: vue.computed(() => {
          const rows = props.view.toLowerCase().split(' ');
          return {
            top: rows[ 0 ].split(''),
            middle: rows[ 1 ].split(''),
            bottom: rows[ 2 ].split('')
          }
        }),

        header: vue.reactive({ size: 0, offset: 0, space: false }),
        right: vue.reactive({ size: 300, offset: 0, space: false }),
        footer: vue.reactive({ size: 0, offset: 0, space: false }),
        left: vue.reactive({ size: 300, offset: 0, space: false }),

        scroll,

        animate () {
          if (timer !== void 0) {
            clearTimeout(timer);
          }
          else {
            document.body.classList.add('q-body--layout-animate');
          }

          timer = setTimeout(() => {
            document.body.classList.remove('q-body--layout-animate');
            timer = void 0;
          }, 155);
        },

        update (part, prop, val) {
          $layout[ part ][ prop ] = val;
        }
      };

      vue.provide(layoutKey, $layout);

      return () => {
        const content = hMergeSlot(slots.default, [
          vue.h(QScrollObserver, { onScroll: onPageScroll }),
          vue.h(QResizeObserver, { onResize: onPageResize })
        ]);

        const layout = vue.h('div', {
          class: classes.value,
          style: style.value,
          ref: props.container === true ? void 0 : rootRef
        }, content);

        if (props.container === true) {
          return vue.h('div', {
            class: 'q-layout-container overflow-hidden',
            ref: rootRef
          }, [
            vue.h(QResizeObserver, { onResize: onContainerResize }),
            vue.h('div', {
              class: 'absolute-full',
              style: targetStyle.value
            }, [
              vue.h('div', {
                class: 'scroll',
                style: targetChildStyle.value
              }, [ layout ])
            ])
          ])
        }

        return layout
      }
    }
  });

  const separatorValues = [ 'horizontal', 'vertical', 'cell', 'none' ];

  var QMarkupTable = vue.defineComponent({
    name: 'QMarkupTable',

    props: {
      ...useDarkProps,

      dense: Boolean,
      flat: Boolean,
      bordered: Boolean,
      square: Boolean,
      wrapCells: Boolean,

      separator: {
        type: String,
        default: 'horizontal',
        validator: v => separatorValues.includes(v)
      }
    },

    setup (props, { slots }) {
      const vm = vue.getCurrentInstance();
      const isDark = useDark(props, vm.proxy.$q);

      const classes = vue.computed(() =>
        'q-markup-table q-table__container q-table__card'
        + ` q-table--${ props.separator }-separator`
        + (isDark.value === true ? ' q-table--dark q-table__card--dark q-dark' : '')
        + (props.dense === true ? ' q-table--dense' : '')
        + (props.flat === true ? ' q-table--flat' : '')
        + (props.bordered === true ? ' q-table--bordered' : '')
        + (props.square === true ? ' q-table--square' : '')
        + (props.wrapCells === false ? ' q-table--no-wrap' : '')
      );

      return () => vue.h('div', {
        class: classes.value
      }, [
        vue.h('table', { class: 'q-table' }, hSlot(slots.default))
      ])
    }
  });

  var QNoSsr = vue.defineComponent({
    name: 'QNoSsr',

    props: {
      tag: {
        type: String,
        default: 'div'
      },

      placeholder: String
    },

    setup (props, { slots }) {
      const canRender = useCanRender();

      return () => {
        const data = {};

        if (canRender.value === true) {
          const node = hSlot(slots.default);
          return node === void 0
            ? node
            : (node.length > 1 ? vue.h(props.tag, data, node) : node[ 0 ])
        }

        data.class = 'q-no-ssr-placeholder';

        const node = hSlot(slots.placeholder);
        if (node !== void 0) {
          return node.length > 1
            ? vue.h(props.tag, data, node)
            : node[ 0 ]
        }

        if (props.placeholder !== void 0) {
          return vue.h(props.tag, data, props.placeholder)
        }
      }
    }
  });

  const svg$m = vue.h('svg', {
    class: 'q-radio__bg absolute non-selectable',
    viewBox: '0 0 24 24',
    'aria-hidden': 'true'
  }, [
    vue.h('path', {
      d: 'M12,22a10,10 0 0 1 -10,-10a10,10 0 0 1 10,-10a10,10 0 0 1 10,10a10,10 0 0 1 -10,10m0,-22a12,12 0 0 0 -12,12a12,12 0 0 0 12,12a12,12 0 0 0 12,-12a12,12 0 0 0 -12,-12'
    }),

    vue.h('path', {
      class: 'q-radio__check',
      d: 'M12,6a6,6 0 0 0 -6,6a6,6 0 0 0 6,6a6,6 0 0 0 6,-6a6,6 0 0 0 -6,-6'
    })
  ]);

  var QRadio = vue.defineComponent({
    name: 'QRadio',

    props: {
      ...useDarkProps,
      ...useSizeProps,
      ...useFormProps,

      modelValue: {
        required: true
      },
      val: {
        required: true
      },

      label: String,
      leftLabel: Boolean,

      color: String,
      keepColor: Boolean,
      dense: Boolean,

      disable: Boolean,
      tabindex: [ String, Number ]
    },

    emits: [ 'update:modelValue' ],

    setup (props, { slots, emit }) {
      const { proxy } = vue.getCurrentInstance();

      const isDark = useDark(props, proxy.$q);
      const sizeStyle = useSize(props, optionSizes);

      const rootRef = vue.ref(null);
      const { refocusTargetEl, refocusTarget } = useRefocusTarget(props, rootRef);

      const isTrue = vue.computed(() => props.modelValue === props.val);

      const classes = vue.computed(() =>
        'q-radio cursor-pointer no-outline row inline no-wrap items-center'
        + (props.disable === true ? ' disabled' : '')
        + (isDark.value === true ? ' q-radio--dark' : '')
        + (props.dense === true ? ' q-radio--dense' : '')
        + (props.leftLabel === true ? ' reverse' : '')
      );

      const innerClass = vue.computed(() => {
        const color = props.color !== void 0 && (
          props.keepColor === true
          || isTrue.value === true
        )
          ? ` text-${ props.color }`
          : '';

        return 'q-radio__inner relative-position '
          + `q-radio__inner--${ isTrue.value === true ? 'truthy' : 'falsy' }${ color }`
      });

      const tabindex = vue.computed(() => (
        props.disable === true ? -1 : props.tabindex || 0
      ));

      const formAttrs = vue.computed(() => {
        const prop = { type: 'radio' };

        props.name !== void 0 && Object.assign(prop, {
          name: props.name,
          value: props.val
        });

        return prop
      });

      const formDomProps = vue.computed(() => (
        props.name !== void 0 && isTrue.value === true
          ? { checked: true }
          : {}
      ));

      const injectFormInput = useFormInject(formAttrs, formDomProps);

      function onClick (e) {
        if (e !== void 0) {
          stopAndPrevent(e);
          refocusTarget(e);
        }

        if (props.disable !== true && isTrue.value !== true) {
          emit('update:modelValue', props.val, e);
        }
      }

      function onKeydown (e) {
        if (e.keyCode === 13 || e.keyCode === 32) {
          stopAndPrevent(e);
        }
      }

      function onKeyup (e) {
        if (e.keyCode === 13 || e.keyCode === 32) {
          onClick(e);
        }
      }

      // expose public methods
      Object.assign(proxy, { set: onClick });

      return () => {
        const content = [ svg$m ];

        props.disable !== true && injectFormInput(
          content,
          'unshift',
          ' q-radio__native q-ma-none q-pa-none'
        );

        const child = [
          vue.h('div', {
            class: innerClass.value,
            style: sizeStyle.value
          }, content)
        ];

        if (refocusTargetEl.value !== null) {
          child.push(refocusTargetEl.value);
        }

        const label = props.label !== void 0
          ? hMergeSlot(slots.default, [ props.label ])
          : hSlot(slots.default);

        label !== void 0 && child.push(
          vue.h('div', {
            class: 'q-radio__label q-anchor--skip'
          }, label)
        );

        return vue.h('div', {
          ref: rootRef,
          class: classes.value,
          tabindex: tabindex.value,
          role: 'radio',
          'aria-label': props.label,
          'aria-checked': isTrue.value === true ? 'true' : 'false',
          'aria-disabled': props.disable === true ? 'true' : void 0,
          onClick,
          onKeydown,
          onKeyup
        }, child)
      }
    }
  });

  var QToggle = vue.defineComponent({
    name: 'QToggle',

    props: {
      ...useCheckboxProps,

      icon: String,
      checkedIcon: String,
      uncheckedIcon: String,
      indeterminateIcon: String,

      iconColor: String
    },

    emits: useCheckboxEmits,

    setup (props) {
      function getInner (isTrue, isIndeterminate) {
        const computedIcon = vue.computed(() =>
          (isTrue.value === true
            ? props.checkedIcon
            : (isIndeterminate.value === true ? props.indeterminateIcon : props.uncheckedIcon)
          ) || props.icon
        );

        const computedIconColor = vue.computed(() => {
          if (isTrue.value === true) {
            return props.iconColor
          }
        });

        return () => [
          vue.h('div', { class: 'q-toggle__track' }),

          vue.h('div', {
            class: 'q-toggle__thumb absolute flex flex-center no-wrap'
          }, computedIcon.value !== void 0
            ? [
                vue.h(QIcon, {
                  name: computedIcon.value,
                  color: computedIconColor.value
                })
              ]
            : void 0
          )
        ]
      }

      return useCheckbox('toggle', getInner)
    }
  });

  const components$1 = {
    radio: QRadio,
    checkbox: QCheckbox,
    toggle: QToggle
  };

  const typeValues = Object.keys(components$1);

  var QOptionGroup = vue.defineComponent({
    name: 'QOptionGroup',

    props: {
      ...useDarkProps,

      modelValue: {
        required: true
      },
      options: {
        type: Array,
        validator: opts => opts.every(opt => 'value' in opt && 'label' in opt)
      },

      name: String,

      type: {
        default: 'radio',
        validator: v => typeValues.includes(v)
      },

      color: String,
      keepColor: Boolean,
      dense: Boolean,

      size: String,

      leftLabel: Boolean,
      inline: Boolean,
      disable: Boolean
    },

    emits: [ 'update:modelValue' ],

    setup (props, { emit }) {
      const { proxy: { $q } } = vue.getCurrentInstance();

      const arrayModel = Array.isArray(props.modelValue);

      if (props.type === 'radio') {
        if (arrayModel === true) {
          console.error('q-option-group: model should not be array');
        }
      }
      else if (arrayModel === false) {
        console.error('q-option-group: model should be array in your case');
      }

      const isDark = useDark(props, $q);

      const component = vue.computed(() => components$1[ props.type ]);

      const classes = vue.computed(() =>
        'q-option-group q-gutter-x-sm'
        + (props.inline === true ? ' q-option-group--inline' : '')
      );

      const attrs = vue.computed(() => {
        const attrs = {};

        if (props.type === 'radio') {
          attrs.role = 'radiogroup';

          if (props.disable === true) {
            attrs[ 'aria-disabled' ] = 'true';
          }
        }

        return attrs
      });

      function onUpdateModelValue (value) {
        emit('update:modelValue', value);
      }

      return () => vue.h('div', {
        class: classes.value,
        ...attrs.value
      }, props.options.map(opt => vue.h('div', [
        vue.h(component.value, {
          modelValue: props.modelValue,
          val: opt.value,
          name: opt.name === void 0 ? props.name : opt.name,
          disable: props.disable || opt.disable,
          label: opt.label,
          leftLabel: opt.leftLabel === void 0 ? props.leftLabel : opt.leftLabel,
          color: opt.color === void 0 ? props.color : opt.color,
          checkedIcon: opt.checkedIcon,
          uncheckedIcon: opt.uncheckedIcon,
          dark: opt.dark || isDark.value,
          size: opt.size === void 0 ? props.size : opt.size,
          dense: props.dense,
          keepColor: opt.keepColor === void 0 ? props.keepColor : opt.keepColor,
          'onUpdate:modelValue': onUpdateModelValue
        })
      ])))
    }
  });

  var QPage = vue.defineComponent({
    name: 'QPage',

    props: {
      padding: Boolean,
      styleFn: Function
    },

    setup (props, { slots }) {
      const { proxy: { $q } } = vue.getCurrentInstance();

      const $layout = vue.inject(layoutKey);
      vue.inject(pageContainerKey, () => {
        console.error('QPage needs to be child of QPageContainer');
      });

      const style = vue.computed(() => {
        const offset
          = ($layout.header.space === true ? $layout.header.size : 0)
          + ($layout.footer.space === true ? $layout.footer.size : 0);

        if (typeof props.styleFn === 'function') {
          const height = $layout.isContainer.value === true
            ? $layout.containerHeight.value
            : $q.screen.height;

          return props.styleFn(offset, height)
        }

        return {
          minHeight: $layout.isContainer.value === true
            ? ($layout.containerHeight.value - offset) + 'px'
            : (
                $q.screen.height === 0
                  ? (offset !== 0 ? `calc(100vh - ${ offset }px)` : '100vh')
                  : ($q.screen.height - offset) + 'px'
              )
        }
      });

      const classes = vue.computed(() =>
        `q-page ${ props.padding === true ? ' q-layout-padding' : '' }`
      );

      return () => vue.h('main', {
        class: classes.value,
        style: style.value
      }, hSlot(slots.default))
    }
  });

  var QPageContainer = vue.defineComponent({
    name: 'QPageContainer',

    setup (_, { slots }) {
      const { proxy: { $q } } = vue.getCurrentInstance();

      const $layout = vue.inject(layoutKey, () => {
        console.error('QPageContainer needs to be child of QLayout');
      });

      vue.provide(pageContainerKey, true);

      const style = vue.computed(() => {
        const css = {};

        if ($layout.header.space === true) {
          css.paddingTop = `${ $layout.header.size }px`;
        }
        if ($layout.right.space === true) {
          css[ `padding${ $q.lang.rtl === true ? 'Left' : 'Right' }` ] = `${ $layout.right.size }px`;
        }
        if ($layout.footer.space === true) {
          css.paddingBottom = `${ $layout.footer.size }px`;
        }
        if ($layout.left.space === true) {
          css[ `padding${ $q.lang.rtl === true ? 'Right' : 'Left' }` ] = `${ $layout.left.size }px`;
        }

        return css
      });

      return () => vue.h('div', {
        class: 'q-page-container',
        style: style.value
      }, hSlot(slots.default))
    }
  });

  const usePageStickyProps = {
    position: {
      type: String,
      default: 'bottom-right',
      validator: v => [
        'top-right', 'top-left',
        'bottom-right', 'bottom-left',
        'top', 'right', 'bottom', 'left'
      ].includes(v)
    },
    offset: {
      type: Array,
      validator: v => v.length === 2
    },
    expand: Boolean
  };

  function usePageSticky () {
    const { props, proxy } = vue.getCurrentInstance();
    const { $q } = proxy;

    const $layout = vue.inject(layoutKey, () => {
      console.error('QPageSticky needs to be child of QLayout');
    });

    const attach = vue.computed(() => {
      const pos = props.position;

      return {
        top: pos.indexOf('top') > -1,
        right: pos.indexOf('right') > -1,
        bottom: pos.indexOf('bottom') > -1,
        left: pos.indexOf('left') > -1,
        vertical: pos === 'top' || pos === 'bottom',
        horizontal: pos === 'left' || pos === 'right'
      }
    });

    const top = vue.computed(() => $layout.header.offset);
    const right = vue.computed(() => $layout.right.offset);
    const bottom = vue.computed(() => $layout.footer.offset);
    const left = vue.computed(() => $layout.left.offset);

    const style = vue.computed(() => {
      let posX = 0, posY = 0;

      const side = attach.value;
      const dir = $q.lang.rtl === true ? -1 : 1;

      if (side.top === true && top.value !== 0) {
        posY = `${ top.value }px`;
      }
      else if (side.bottom === true && bottom.value !== 0) {
        posY = `${ -bottom.value }px`;
      }

      if (side.left === true && left.value !== 0) {
        posX = `${ dir * left.value }px`;
      }
      else if (side.right === true && right.value !== 0) {
        posX = `${ -dir * right.value }px`;
      }

      const css = { transform: `translate(${ posX }, ${ posY })` };

      if (props.offset) {
        css.margin = `${ props.offset[ 1 ] }px ${ props.offset[ 0 ] }px`;
      }

      if (side.vertical === true) {
        if (left.value !== 0) {
          css[ $q.lang.rtl === true ? 'right' : 'left' ] = `${ left.value }px`;
        }
        if (right.value !== 0) {
          css[ $q.lang.rtl === true ? 'left' : 'right' ] = `${ right.value }px`;
        }
      }
      else if (side.horizontal === true) {
        if (top.value !== 0) {
          css.top = `${ top.value }px`;
        }
        if (bottom.value !== 0) {
          css.bottom = `${ bottom.value }px`;
        }
      }

      return css
    });

    const classes = vue.computed(() =>
      `q-page-sticky row flex-center fixed-${ props.position }`
      + ` q-page-sticky--${ props.expand === true ? 'expand' : 'shrink' }`
    );

    function getStickyContent (slots) {
      const content = hSlot(slots.default);

      return vue.h('div', {
        class: classes.value,
        style: style.value
      },
      props.expand === true
        ? content
        : [ vue.h('div', content) ]
      )
    }

    return {
      $layout,
      getStickyContent
    }
  }

  var QPageScroller = vue.defineComponent({
    name: 'QPageScroller',

    props: {
      ...usePageStickyProps,

      scrollOffset: {
        type: Number,
        default: 1000
      },

      reverse: Boolean,

      duration: {
        type: Number,
        default: 300
      },

      offset: {
        default: () => [ 18, 18 ]
      }
    },

    emits: [ 'click' ],

    setup (props, { slots, emit }) {
      const { proxy: { $q } } = vue.getCurrentInstance();
      const { $layout, getStickyContent } = usePageSticky();
      const rootRef = vue.ref(null);

      let heightWatcher;

      const scrollHeight = vue.computed(() => $layout.height.value - (
        $layout.isContainer.value === true
          ? $layout.containerHeight.value
          : $q.screen.height
      ));

      function isVisible () {
        return props.reverse === true
          ? scrollHeight.value - $layout.scroll.value.position > props.scrollOffset
          : $layout.scroll.value.position > props.scrollOffset
      }

      const showing = vue.ref(isVisible());

      function updateVisibility () {
        const newVal = isVisible();
        if (showing.value !== newVal) {
          showing.value = newVal;
        }
      }

      function updateReverse () {
        if (props.reverse === true) {
          if (heightWatcher === void 0) {
            heightWatcher = vue.watch(scrollHeight, updateVisibility);
          }
        }
        else {
          cleanup();
        }
      }

      vue.watch($layout.scroll, updateVisibility);
      vue.watch(() => props.reverse, updateReverse);

      function cleanup () {
        if (heightWatcher !== void 0) {
          heightWatcher();
          heightWatcher = void 0;
        }
      }

      function onClick (e) {
        const target = getScrollTarget(
          $layout.isContainer.value === true
            ? rootRef.value
            : $layout.rootRef.value
        );

        setVerticalScrollPosition(
          target,
          props.reverse === true ? $layout.height.value : 0,
          props.duration
        );

        emit('click', e);
      }

      function getContent () {
        return showing.value === true
          ? vue.h('div', {
              ref: rootRef,
              class: 'q-page-scroller',
              onClick
            }, getStickyContent(slots))
          : null
      }

      updateReverse();

      vue.onBeforeUnmount(cleanup);

      return () => vue.h(
        vue.Transition,
        { name: 'q-transition--fade' },
        getContent
      )
    }
  });

  var QPageSticky = vue.defineComponent({
    name: 'QPageSticky',

    props: usePageStickyProps,

    setup (_, { slots }) {
      const { getStickyContent } = usePageSticky();
      return () => getStickyContent(slots)
    }
  });

  var QPagination = vue.defineComponent({
    name: 'QPagination',

    props: {
      ...useDarkProps,

      modelValue: {
        type: Number,
        required: true
      },
      min: {
        type: Number,
        default: 1
      },
      max: {
        type: Number,
        required: true
      },

      color: {
        type: String,
        default: 'primary'
      },
      textColor: String,

      activeColor: String,
      activeTextColor: String,

      inputStyle: [ Array, String, Object ],
      inputClass: [ Array, String, Object ],

      size: String,

      disable: Boolean,

      input: Boolean,

      iconPrev: String,
      iconNext: String,
      iconFirst: String,
      iconLast: String,

      toFn: Function,

      boundaryLinks: {
        type: Boolean,
        default: null
      },
      boundaryNumbers: {
        type: Boolean,
        default: null
      },
      directionLinks: {
        type: Boolean,
        default: null
      },
      ellipses: {
        type: Boolean,
        default: null
      },
      maxPages: {
        type: Number,
        default: 0,
        validator: v => v >= 0
      },

      ripple: {
        type: [ Boolean, Object ],
        default: null
      },

      round: Boolean,
      rounded: Boolean,

      flat: Boolean,
      outline: Boolean,
      unelevated: Boolean,
      push: Boolean,
      glossy: Boolean,

      dense: Boolean,
      padding: {
        type: String,
        default: '3px 2px'
      }
    },

    emits: [ 'update:modelValue' ],

    setup (props, { emit }) {
      const { proxy } = vue.getCurrentInstance();
      const { $q } = proxy;

      const isDark = useDark(props, $q);

      const newPage = vue.ref(null);
      const model = vue.computed({
        get: () => props.modelValue,
        set: val => {
          val = parseInt(val, 10);
          if (props.disable || isNaN(val)) {
            return
          }
          const value = between(val, props.min, props.max);
          if (props.modelValue !== value) {
            emit('update:modelValue', value);
          }
        }
      });

      vue.watch(() => props.min + props.max, () => {
        model.value = props.modelValue;
      });

      function getBool (val, otherwise) {
        return [ true, false ].includes(val)
          ? val
          : otherwise
      }

      const classes = vue.computed(() =>
        'q-pagination row no-wrap items-center'
        + (props.disable === true ? ' disabled' : '')
      );
      const inputPlaceholder = vue.computed(() => model.value + ' / ' + props.max);
      const __boundaryLinks = vue.computed(() => getBool(props.boundaryLinks, props.input));
      const __boundaryNumbers = vue.computed(() => getBool(props.boundaryNumbers, !props.input));
      const __directionLinks = vue.computed(() => getBool(props.directionLinks, props.input));
      const __ellipses = vue.computed(() => getBool(props.ellipses, !props.input));
      const icons = vue.computed(() => {
        const ico = [
          props.iconFirst || $q.iconSet.pagination.first,
          props.iconPrev || $q.iconSet.pagination.prev,
          props.iconNext || $q.iconSet.pagination.next,
          props.iconLast || $q.iconSet.pagination.last
        ];
        return $q.lang.rtl === true ? ico.reverse() : ico
      });

      const attrs = vue.computed(() => (
        props.disable === true
          ? { 'aria-disabled': 'true' }
          : {}
      ));

      const btnProps = vue.computed(() => ({
        round: props.round,
        rounded: props.rounded,

        outline: props.outline,
        unelevated: props.unelevated,
        push: props.push,
        glossy: props.glossy,

        dense: props.dense,
        padding: props.padding,

        color: props.color,
        flat: true,
        size: props.size,
        ripple: props.ripple !== null
          ? props.ripple
          : true
      }));

      const activeBtnProps = vue.computed(() => ({
        flat: props.flat,
        color: props.activeColor || props.color,
        textColor: props.activeTextColor || props.textColor
      }));

      function set (value) {
        model.value = value;
      }

      function setByOffset (offset) {
        model.value = model.value + offset;
      }

      function updateModel () {
        model.value = newPage.value;
        newPage.value = null;
      }

      function getBtn (data, page) {
        const props = { ...btnProps.value, ...data };

        if (page !== void 0) {
          if (props.toFn !== void 0) {
            props.to = props.toFn(page);
          }
          else {
            props.onClick = () => set(page);
          }
        }

        return vue.h(QBtn, props)
      }

      // expose public methods
      Object.assign(proxy, { set, setByOffset });

      return () => {
        const
          contentStart = [],
          contentEnd = [],
          contentMiddle = [];

        if (__boundaryLinks.value) {
          contentStart.push(getBtn({
            key: 'bls',
            disable: props.disable || props.modelValue <= props.min,
            icon: icons.value[ 0 ]
          }, props.min));
          contentEnd.unshift(getBtn({
            key: 'ble',
            disable: props.disable || props.modelValue >= props.max,
            icon: icons.value[ 3 ]
          }, props.max));
        }

        if (__directionLinks.value) {
          contentStart.push(getBtn({
            key: 'bdp',
            disable: props.disable || props.modelValue <= props.min,
            icon: icons.value[ 1 ]
          }, props.modelValue - 1));
          contentEnd.unshift(getBtn({
            key: 'bdn',
            disable: props.disable || props.modelValue >= props.max,
            icon: icons.value[ 2 ]
          }, props.modelValue + 1));
        }

        if (props.input === true) {
          contentMiddle.push(vue.h(QInput, {
            class: 'inline',
            style: {
              width: `${ inputPlaceholder.value.length / 1.5 }em`
            },
            type: 'number',
            dense: true,
            value: newPage.value,
            disable: props.disable,
            dark: isDark.value,
            borderless: true,
            inputClass: props.inputClass,
            inputStyle: props.inputStyle,
            placeholder: inputPlaceholder.value,
            min: props.min,
            max: props.max,
            'onUpdate:modelValue' (value) { newPage.value = value; },
            onKeyup (e) { isKeyCode(e, 13) === true && updateModel(); },
            onBlur: updateModel
          }));
        }
        else { // is type select
          let
            maxPages = Math.max(
              props.maxPages,
              1 + (__ellipses.value ? 2 : 0) + (__boundaryNumbers.value ? 2 : 0)
            ),
            pgFrom = props.min,
            pgTo = props.max,
            ellipsesStart = false,
            ellipsesEnd = false,
            boundaryStart = false,
            boundaryEnd = false;

          if (props.maxPages && maxPages < (props.max - props.min + 1)) {
            maxPages = 1 + Math.floor(maxPages / 2) * 2;
            pgFrom = Math.max(props.min, Math.min(props.max - maxPages + 1, props.modelValue - Math.floor(maxPages / 2)));
            pgTo = Math.min(props.max, pgFrom + maxPages - 1);
            if (__boundaryNumbers.value) {
              boundaryStart = true;
              pgFrom += 1;
            }
            if (__ellipses.value && pgFrom > (props.min + (__boundaryNumbers.value ? 1 : 0))) {
              ellipsesStart = true;
              pgFrom += 1;
            }
            if (__boundaryNumbers.value) {
              boundaryEnd = true;
              pgTo -= 1;
            }
            if (__ellipses.value && pgTo < (props.max - (__boundaryNumbers.value ? 1 : 0))) {
              ellipsesEnd = true;
              pgTo -= 1;
            }
          }
          const style = {
            minWidth: `${ Math.max(2, String(props.max).length) }em`
          };
          if (boundaryStart) {
            const active = props.min === props.modelValue;
            contentStart.push(getBtn({
              key: 'bns',
              style,
              disable: props.disable,
              flat: !active,
              textColor: active ? props.textColor : void 0,
              label: props.min
            }, props.min));
          }
          if (boundaryEnd) {
            const active = props.max === props.modelValue;
            contentEnd.unshift(getBtn({
              key: 'bne',
              style,
              disable: props.disable,
              flat: !active,
              textColor: active ? props.textColor : void 0,
              label: props.max
            }, props.max));
          }
          if (ellipsesStart) {
            contentStart.push(getBtn({
              key: 'bes',
              style,
              disable: props.disable,
              label: '',
              ripple: false
            }, pgFrom - 1));
          }
          if (ellipsesEnd) {
            contentEnd.unshift(getBtn({
              key: 'bee',
              style,
              disable: props.disable,
              label: '',
              ripple: false
            }, pgTo + 1));
          }
          for (let i = pgFrom; i <= pgTo; i++) {
            const btn = {
              key: `bpg${ i }`,
              style,
              disable: props.disable,
              label: i
            };
            if (i === props.modelValue) {
              Object.assign(btn, activeBtnProps.value);
            }
            contentMiddle.push(getBtn(btn, i));
          }
        }

        return vue.h('div', {
          class: classes.value,
          ...attrs.value
        }, [
          contentStart,

          vue.h('div', {
            class: 'row justify-center'
          }, [
            contentMiddle
          ]),

          contentEnd
        ])
      }
    }
  });

  function frameDebounce (fn) {
    let wait = false, frame, callArgs;

    function debounced (/* ...args */) {
      callArgs = arguments;
      if (wait === true) { return }

      wait = true;
      frame = requestAnimationFrame(() => {
        fn.apply(this, callArgs);
        callArgs = void 0;
        wait = false;
      });
    }

    debounced.cancel = () => {
      window.cancelAnimationFrame(frame);
      wait = false;
    };

    return debounced
  }

  const { passive: passive$1 } = listenOpts;

  var QParallax = vue.defineComponent({
    name: 'QParallax',

    props: {
      src: String,
      height: {
        type: Number,
        default: 500
      },
      speed: {
        type: Number,
        default: 1,
        validator: v => v >= 0 && v <= 1
      },

      scrollTarget: {
        default: void 0
      },

      onScroll: Function
    },

    setup (props, { slots, emit }) {
      const percentScrolled = vue.ref(0);
      const rootRef = vue.ref(null);
      const mediaParentRef = vue.ref(null);
      const mediaRef = vue.ref(null);

      let isWorking, mediaEl, mediaHeight, resizeHandler, observer, localScrollTarget;

      vue.watch(() => props.height, () => {
        isWorking === true && updatePos();
      });

      vue.watch(() => props.scrollTarget, () => {
        if (isWorking === true) {
          stop();
          start();
        }
      });

      let update = percentage => {
        percentScrolled.value = percentage;
        props.onScroll !== void 0 && emit('scroll', percentage);
      };

      function updatePos () {
        let containerTop, containerHeight, containerBottom;

        if (localScrollTarget === window) {
          containerTop = 0;
          containerHeight = window.innerHeight;
          containerBottom = containerHeight;
        }
        else {
          containerTop = offset(localScrollTarget).top;
          containerHeight = height(localScrollTarget);
          containerBottom = containerTop + containerHeight;
        }

        const top = offset(rootRef.value).top;
        const bottom = top + props.height;

        if (observer !== void 0 || (bottom > containerTop && top < containerBottom)) {
          const percent = (containerBottom - top) / (props.height + containerHeight);
          setPos((mediaHeight - props.height) * percent * props.speed);
          update(percent);
        }
      }

      let setPos = offset => {
        // apply it immediately without any delay
        mediaEl.style.transform = `translate3d(-50%,${ Math.round(offset) }px,0)`;
      };

      function onResize () {
        mediaHeight = mediaEl.naturalHeight || mediaEl.videoHeight || height(mediaEl);
        isWorking === true && updatePos();
      }

      function start () {
        isWorking = true;
        localScrollTarget = getScrollTarget(rootRef.value, props.scrollTarget);
        localScrollTarget.addEventListener('scroll', updatePos, passive$1);
        window.addEventListener('resize', resizeHandler, passive$1);
        updatePos();
      }

      function stop () {
        if (isWorking === true) {
          isWorking = false;
          localScrollTarget.removeEventListener('scroll', updatePos, passive$1);
          window.removeEventListener('resize', resizeHandler, passive$1);
          localScrollTarget = void 0;
        }
      }

      vue.onMounted(() => {
        setPos = frameDebounce(setPos);
        update = frameDebounce(update);
        resizeHandler = frameDebounce(onResize);

        mediaEl = slots.media !== void 0
          ? mediaParentRef.value.children[ 0 ]
          : mediaRef.value;

        mediaEl.onload = mediaEl.onloadstart = mediaEl.loadedmetadata = onResize;
        onResize();
        mediaEl.style.display = 'initial';

        if (window.IntersectionObserver !== void 0) {
          observer = new IntersectionObserver(entries => {
            const fn = entries[ 0 ].isIntersecting === true ? start : stop;
            fn();
          });

          observer.observe(rootRef.value);
        }
        else {
          start();
        }
      });

      vue.onBeforeUnmount(() => {
        stop();
        observer !== void 0 && observer.disconnect();
        mediaEl.onload = mediaEl.onloadstart = mediaEl.loadedmetadata = null;
      });

      return () => {
        return vue.h('div', {
          ref: rootRef,
          class: 'q-parallax',
          style: { height: `${ props.height }px` }
        }, [
          vue.h('div', {
            ref: mediaParentRef,
            class: 'q-parallax__media absolute-full'
          }, slots.media !== void 0 ? slots.media() : [
            vue.h('img', {
              ref: mediaRef,
              src: props.src
            })
          ]),

          vue.h(
            'div',
            { class: 'q-parallax__content absolute-full column flex-center' },
            slots.content !== void 0
              ? slots.content({ percentScrolled: percentScrolled.value })
              : hSlot(slots.default)
          )
        ])
      }
    }
  });

  function clone (data) {
    const s = JSON.stringify(data);
    if (s) {
      return JSON.parse(s)
    }
  }

  var QPopupEdit = vue.defineComponent({
    name: 'QPopupEdit',

    props: {
      modelValue: {
        required: true
      },
      title: String,
      buttons: Boolean,
      labelSet: String,
      labelCancel: String,

      color: {
        type: String,
        default: 'primary'
      },
      validate: {
        type: Function,
        default: () => true
      },

      autoSave: Boolean,

      /* menu props overrides */
      cover: {
        type: Boolean,
        default: true
      },
      /* end of menu props */

      disable: Boolean
    },

    emits: [
      'update:modelValue', 'save', 'cancel',
      'before-show', 'show', 'before-hide', 'hide'
    ],

    setup (props, { slots, emit }) {
      const { proxy } = vue.getCurrentInstance();
      const { $q } = proxy;

      const menuRef = vue.ref(null);

      const initialValue = vue.ref('');
      const currentModel = vue.ref('');

      let validated = false;

      const scope = vue.computed(() => {
        const acc = {
          initialValue: initialValue.value,
          validate: props.validate,
          set,
          cancel,
          updatePosition
        };

        Object.defineProperty(acc, 'value', {
          get: () => currentModel.value,
          set: val => { currentModel.value = val; }
        });

        return acc
      });

      function set () {
        if (props.validate(currentModel.value) === false) {
          return
        }

        if (hasModelChanged() === true) {
          emit('save', currentModel.value, initialValue.value);
          emit('update:modelValue', currentModel.value);
        }

        closeMenu();
      }

      function cancel () {
        if (hasModelChanged() === true) {
          emit('cancel', currentModel.value, initialValue.value);
        }

        closeMenu();
      }

      function updatePosition () {
        vue.nextTick(() => {
          menuRef.value.updatePosition();
        });
      }

      function hasModelChanged () {
        return isDeepEqual(currentModel.value, initialValue.value) === false
      }

      function closeMenu () {
        validated = true;
        menuRef.value.hide();
      }

      function onBeforeShow () {
        validated = false;
        initialValue.value = clone(props.modelValue);
        currentModel.value = clone(props.modelValue);
        emit('before-show');
      }

      function onShow () {
        emit('show');
      }

      function onBeforeHide () {
        if (validated === false && hasModelChanged() === true) {
          if (props.autoSave === true && props.validate(currentModel.value) === true) {
            emit('save', currentModel.value, initialValue.value);
            emit('update:modelValue', currentModel.value);
          }
          else {
            emit('cancel', currentModel.value, initialValue.value);
          }
        }

        emit('before-hide');
      }

      function onHide () {
        emit('hide');
      }

      // expose public methods
      Object.assign(proxy, {
        set,
        cancel,
        show (e) { menuRef.value !== null && menuRef.value.show(e); },
        hide (e) { menuRef.value !== null && menuRef.value.hide(e); },
        updatePosition
      });

      function getContent () {
        const child = slots.default !== void 0
          ? slots.default(scope.value).slice()
          : [];

        props.title && child.unshift(
          vue.h('div', { class: 'q-dialog__title q-mt-sm q-mb-sm' }, props.title)
        );

        props.buttons === true && child.push(
          vue.h('div', { class: 'q-popup-edit__buttons row justify-center no-wrap' }, [
            vue.h(QBtn, {
              flat: true,
              color: props.color,
              label: props.labelCancel || $q.lang.label.cancel,
              onClick: cancel
            }),
            vue.h(QBtn, {
              flat: true,
              color: props.color,
              label: props.labelSet || $q.lang.label.set,
              onClick: set
            })
          ])
        );

        return child
      }

      return () => {
        if (props.disable === true) { return }

        return vue.h(QMenu, {
          ref: menuRef,
          class: 'q-popup-edit',
          cover: props.cover,
          onBeforeShow,
          onShow,
          onBeforeHide,
          onHide,
          onEscapeKey: cancel
        }, getContent)
      }
    }
  });

  var QPopupProxy = vue.defineComponent({
    name: 'QPopupProxy',

    props: {
      ...useAnchorProps,

      breakpoint: {
        type: [ String, Number ],
        default: 450
      }
    },

    emits: [ 'show', 'hide' ],

    setup (props, { slots, emit, attrs }) {
      const { proxy } = vue.getCurrentInstance();
      const { $q } = proxy;

      const showing = vue.ref(false);
      const popupRef = vue.ref(null);
      const breakpoint = vue.computed(() => parseInt(props.breakpoint, 10));

      const { canShow } = useAnchor({ showing });

      function getType () {
        return $q.screen.width < breakpoint.value || $q.screen.height < breakpoint.value
          ? 'dialog'
          : 'menu'
      }

      const type = vue.ref(getType());

      vue.watch(() => getType(), val => {
        if (showing.value !== true) {
          type.value = val;
        }
      });

      // expose public methods
      Object.assign(proxy, {
        show (evt) { canShow(evt) === true && popupRef.value.show(evt); },
        hide (evt) { popupRef.value.hide(evt); },
        toggle (evt) { popupRef.value.toggle(evt); }
      });

      function onShow (evt) {
        showing.value = true;
        emit('show', evt);
      }

      function onHide (evt) {
        showing.value = false;
        type.value = getType();
        emit('hide', evt);
      }

      return () => {
        const def = hSlot(slots.default);

        const popupProps = (
          type.value === 'menu'
          && def !== void 0
          && def[ 0 ] !== void 0
          && def[ 0 ].type !== void 0
          && [ 'QDate', 'QTime', 'QCarousel', 'QColor' ].includes(
            def[ 0 ].type.name
          )
        ) ? { cover: true, maxHeight: '99vh' } : {};

        const data = {
          ref: popupRef,
          ...popupProps,
          ...attrs,
          onShow,
          onHide
        };

        let component;

        if (type.value === 'dialog') {
          component = QDialog;
        }
        else {
          component = QMenu;
          Object.assign(data, {
            target: props.target,
            contextMenu: props.contextMenu,
            noParentEvent: true,
            separateClosePopup: true
          });
        }

        return vue.h(component, data, () => def)
      }
    }
  });

  const defaultSizes = {
    xs: 2,
    sm: 4,
    md: 6,
    lg: 10,
    xl: 14
  };

  function width (val, reverse, $q) {
    return {
      transform: reverse === true
        ? `translateX(${ $q.lang.rtl === true ? '-' : '' }100%) scale3d(${ -val },1,1)`
        : `scale3d(${ val },1,1)`
    }
  }

  var QLinearProgress = vue.defineComponent({
    name: 'QLinearProgress',

    props: {
      ...useDarkProps,
      ...useSizeProps,

      value: {
        type: Number,
        default: 0
      },
      buffer: Number,

      color: String,
      trackColor: String,

      reverse: Boolean,
      stripe: Boolean,
      indeterminate: Boolean,
      query: Boolean,
      rounded: Boolean,

      instantFeedback: Boolean
    },

    setup (props, { slots }) {
      const { proxy } = vue.getCurrentInstance();
      const isDark = useDark(props, proxy.$q);
      const sizeStyle = useSize(props, defaultSizes);

      const motion = vue.computed(() => props.indeterminate === true || props.query === true);

      const classes = vue.computed(() =>
        'q-linear-progress'
        + (props.color !== void 0 ? ` text-${ props.color }` : '')
        + (props.reverse === true || props.query === true ? ' q-linear-progress--reverse' : '')
        + (props.rounded === true ? ' rounded-borders' : '')
      );

      const trackStyle = vue.computed(() => width(props.buffer !== void 0 ? props.buffer : 1, props.reverse, proxy.$q));
      const trackClass = vue.computed(() =>
        'q-linear-progress__track absolute-full'
        + ` q-linear-progress__track--with${ props.instantFeedback === true ? 'out' : '' }-transition`
        + ` q-linear-progress__track--${ isDark.value === true ? 'dark' : 'light' }`
        + (props.trackColor !== void 0 ? ` bg-${ props.trackColor }` : '')
      );

      const modelStyle = vue.computed(() => width(motion.value === true ? 1 : props.value, props.reverse, proxy.$q));
      const modelClass = vue.computed(() =>
        'q-linear-progress__model absolute-full'
        + ` q-linear-progress__model--with${ props.instantFeedback === true ? 'out' : '' }-transition`
        + ` q-linear-progress__model--${ motion.value === true ? 'in' : '' }determinate`
      );

      const stripeStyle = vue.computed(() => ({ width: `${ props.value * 100 }%` }));
      const stripeClass = vue.computed(() =>
        `q-linear-progress__stripe absolute-${ props.reverse === true ? 'right' : 'left' }`
      );

      return () => {
        const child = [
          vue.h('div', {
            class: trackClass.value,
            style: trackStyle.value
          }),

          vue.h('div', {
            class: modelClass.value,
            style: modelStyle.value
          })
        ];

        props.stripe === true && motion.value === false && child.push(
          vue.h('div', {
            class: stripeClass.value,
            style: stripeStyle.value
          })
        );

        return vue.h('div', {
          class: classes.value,
          style: sizeStyle.value,
          role: 'progressbar',
          'aria-valuemin': 0,
          'aria-valuemax': 1,
          'aria-valuenow': props.indeterminate === true
            ? void 0
            : props.value
        }, hMergeSlot(slots.default, child))
      }
    }
  });

  const
    PULLER_HEIGHT = 40,
    OFFSET_TOP = 20;

  var QPullToRefresh = vue.defineComponent({
    name: 'QPullToRefresh',

    props: {
      color: String,
      bgColor: String,
      icon: String,
      noMouse: Boolean,
      disable: Boolean,

      scrollTarget: {
        default: void 0
      }
    },

    emits: [ 'refresh' ],

    setup (props, { slots, emit }) {
      const { proxy } = vue.getCurrentInstance();
      const { $q } = proxy;

      const state = vue.ref('pull');
      const pullRatio = vue.ref(0);
      const pulling = vue.ref(false);
      const pullPosition = vue.ref(-PULLER_HEIGHT);
      const animating = vue.ref(false);
      const positionCSS = vue.ref({});

      const style = vue.computed(() => ({
        opacity: pullRatio.value,
        transform: `translateY(${ pullPosition.value }px) rotate(${ pullRatio.value * 360 }deg)`
      }));

      const classes = vue.computed(() =>
        'q-pull-to-refresh__puller row flex-center'
        + (animating.value === true ? ' q-pull-to-refresh__puller--animating' : '')
        + (props.bgColor !== void 0 ? ` bg-${ props.bgColor }` : '')
      );

      function pull (event) {
        if (event.isFinal === true) {
          if (pulling.value === true) {
            pulling.value = false;

            if (state.value === 'pulled') {
              state.value = 'refreshing';
              animateTo({ pos: OFFSET_TOP });
              trigger();
            }
            else if (state.value === 'pull') {
              animateTo({ pos: -PULLER_HEIGHT, ratio: 0 });
            }
          }

          return
        }

        if (animating.value === true || state.value === 'refreshing') {
          return false
        }

        if (event.isFirst === true) {
          if (getVerticalScrollPosition(localScrollTarget) !== 0 || event.direction !== "down") {
            if (pulling.value === true) {
              pulling.value = false;
              state.value = 'pull';
              animateTo({ pos: -PULLER_HEIGHT, ratio: 0 });
            }

            return false
          }

          pulling.value = true;

          const { top, left } = $el.getBoundingClientRect();
          positionCSS.value = {
            top: top + 'px',
            left: left + 'px',
            width: window.getComputedStyle($el).getPropertyValue('width')
          };
        }

        prevent(event.evt);

        const distance = Math.min(140, Math.max(0, event.distance.y));
        pullPosition.value = distance - PULLER_HEIGHT;
        pullRatio.value = between(distance / (OFFSET_TOP + PULLER_HEIGHT), 0, 1);

        const newState = pullPosition.value > OFFSET_TOP ? 'pulled' : 'pull';

        if (state.value !== newState) {
          state.value = newState;
        }
      }

      const directives = vue.computed(() => {
        // if props.disable === false
        const modifiers = {
          down: true,
          mightPrevent: true
        };

        if (props.noMouse !== true) {
          modifiers.mouse = true;
        }

        return [ [
          TouchPan,
          pull,
          void 0,
          modifiers
        ] ]
      });

      const contentClass = vue.computed(() =>
        `q-pull-to-refresh__content${ pulling.value === true ? ' no-pointer-events' : '' }`
      );

      function trigger () {
        emit('refresh', () => {
          animateTo({ pos: -PULLER_HEIGHT, ratio: 0 }, () => {
            state.value = 'pull';
          });
        });
      }

      function animateTo ({ pos, ratio }, done) {
        animating.value = true;
        pullPosition.value = pos;

        if (ratio !== void 0) {
          pullRatio.value = ratio;
        }

        clearTimeout(timer);
        timer = setTimeout(() => {
          animating.value = false;
          done && done();
        }, 300);
      }

      // expose public methods
      Object.assign(proxy, { trigger, updateScrollTarget });

      let $el, localScrollTarget, timer;

      function updateScrollTarget () {
        localScrollTarget = getScrollTarget($el, props.scrollTarget);
      }

      vue.watch(() => props.scrollTarget, updateScrollTarget);

      vue.onMounted(() => {
        $el = proxy.$el;
        updateScrollTarget();
      });

      vue.onBeforeUnmount(() => {
        clearTimeout(timer);
      });

      return () => {
        const child = [
          vue.h('div', { class: contentClass.value }, hSlot(slots.default)),

          vue.h('div', {
            class: 'q-pull-to-refresh__puller-container fixed row flex-center no-pointer-events z-top',
            style: positionCSS.value
          }, [
            vue.h('div', {
              class: classes.value,
              style: style.value
            }, [
              state.value !== 'refreshing'
                ? vue.h(QIcon, {
                    name: props.icon || $q.iconSet.pullToRefresh.icon,
                    color: props.color,
                    size: '32px'
                  })
                : vue.h(QSpinner, {
                  size: '24px',
                  color: props.color
                })
            ])
          ])
        ];

        return hDir(
          'div',
          { class: 'q-pull-to-refresh' },
          child,
          'main',
          props.disable === false,
          () => directives.value
        )
      }
    }
  });

  const dragType = {
    MIN: 0,
    RANGE: 1,
    MAX: 2
  };

  var QRange = vue.defineComponent({
    name: 'QRange',

    props: {
      ...useFormProps,
      ...useSliderProps,

      modelValue: {
        type: Object,
        default: () => ({
          min: null,
          max: null
        }),
        validator (val) {
          return 'min' in val && 'max' in val
        }
      },

      name: String,

      dragRange: Boolean,
      dragOnlyRange: Boolean,

      leftLabelColor: String,
      leftLabelTextColor: String,
      rightLabelColor: String,
      rightLabelTextColor: String,

      leftLabelValue: [ String, Number ],
      rightLabelValue: [ String, Number ]
    },

    emits: useSliderEmits,

    setup (props, { emit }) {
      const { proxy: { $q } } = vue.getCurrentInstance();

      const formAttrs = vue.computed(() => {
        return {
          type: 'hidden',
          name: props.name,
          value: `${ props.modelValue.min }|${ props.modelValue.max }`
        }
      });

      const injectFormInput = useFormInject(formAttrs);

      const rootRef = vue.ref(null);
      const model = vue.ref({
        min: props.modelValue.min === null ? props.min : props.modelValue.min,
        max: props.modelValue.max === null ? props.max : props.modelValue.max
      });

      const nextFocus = vue.ref(null);

      const curMinRatio = vue.ref(0);
      const curMaxRatio = vue.ref(0);

      const { state, methods } = useSlider({
        updateValue, updatePosition, getDragging
      });

      const modelMinRatio = vue.computed(() => (
        state.minMaxDiff.value === 0 ? 0 : (model.value.min - props.min) / state.minMaxDiff.value
      ));

      const ratioMin = vue.computed(() => (
        state.active.value === true ? curMinRatio.value : modelMinRatio.value
      ));

      const modelMaxRatio = vue.computed(() => (
        state.minMaxDiff.value === 0 ? 0 : (model.value.max - props.min) / state.minMaxDiff.value
      ));

      const ratioMax = vue.computed(() => (
        state.active.value === true ? curMaxRatio.value : modelMaxRatio.value
      ));

      const trackStyle = vue.computed(() => ({
        [ state.positionProp.value ]: `${ 100 * ratioMin.value }%`,
        [ state.sizeProp.value ]: `${ 100 * (ratioMax.value - ratioMin.value) }%`
      }));

      const events = vue.computed(() => {
        if (state.editable.value !== true) {
          return {}
        }

        if ($q.platform.is.mobile === true) {
          return { onClick: methods.onMobileClick }
        }

        const evt = { onMousedown: methods.onActivate };

        props.dragOnlyRange === true && Object.assign(evt, {
          onFocus: () => { onFocus('both'); },
          onBlur: methods.onBlur,
          onKeydown,
          onKeyup: methods.onKeyup
        });

        return evt
      });

      const minProps = {
        domRef: vue.ref(null),

        events: vue.computed(() => (
          state.editable.value === true && $q.platform.is.mobile !== true && props.dragOnlyRange !== true
            ? {
                onFocus: () => { onFocus('min'); },
                onBlur: methods.onBlur,
                onKeydown,
                onKeyup: methods.onKeyup
              }
            : {}
        )),

        thumbStyle: vue.computed(() => ({
          [ state.positionProp.value ]: `${ 100 * ratioMin.value }%`,
          'z-index': nextFocus.value === 'min' ? 2 : void 0
        })),

        thumbClass: vue.computed(() => (
          state.preventFocus.value === false && state.focus.value === 'min'
            ? ' q-slider--focus'
            : ''
        )),

        pinClass: vue.computed(() => {
          const color = props.leftLabelColor || props.labelColor;
          return color ? ` text-${ color }` : ''
        }),

        pinTextClass: vue.computed(() => {
          const color = props.leftLabelTextColor || props.labelTextColor;
          return color ? ` text-${ color }` : ''
        }),

        pinStyle: vue.computed(() => {
          const percent = (props.reverse === true ? -ratioMin.value : ratioMin.value - 1);
          return methods.getPinStyle(percent, ratioMin.value)
        }),

        label: vue.computed(() => (
          props.leftLabelValue !== void 0
            ? props.leftLabelValue
            : model.value.min
        ))
      };

      const maxProps = {
        domRef: vue.ref(null),

        events: vue.computed(() => (
          state.editable.value === true && $q.platform.is.mobile !== true && props.dragOnlyRange !== true
            ? {
                onFocus: () => { onFocus('max'); },
                onBlur: methods.onBlur,
                onKeydown,
                onKeyup: methods.onKeyup
              }
            : {}
        )),

        thumbStyle: vue.computed(() => ({
          [ state.positionProp.value ]: `${ 100 * ratioMax.value }%`
        })),

        thumbClass: vue.computed(() => (
          state.preventFocus.value === false && state.focus.value === 'max'
            ? ' q-slider--focus'
            : ''
        )),

        pinClass: vue.computed(() => {
          const color = props.rightLabelColor || props.labelColor;
          return color ? ` text-${ color }` : ''
        }),

        pinTextClass: vue.computed(() => {
          const color = props.rightLabelTextColor || props.labelTextColor;
          return color ? ` text-${ color }` : ''
        }),

        pinStyle: vue.computed(() => {
          const percent = (props.reverse === true ? -ratioMax.value : ratioMax.value - 1);
          return methods.getPinStyle(percent, ratioMax.value)
        }),

        label: vue.computed(() => (
          props.rightLabelValue !== void 0
            ? props.rightLabelValue
            : model.value.max
        ))
      };

      vue.watch(() => props.modelValue.min, val => {
        model.value.min = val === null
          ? props.min
          : val;
      });

      vue.watch(() => props.modelValue.max, val => {
        model.value.max = val === null
          ? props.max
          : val;
      });

      vue.watch(() => props.min, value => {
        if (model.value.min < value) {
          model.value.min = value;
        }
        if (model.value.max < value) {
          model.value.max = value;
        }
      });

      vue.watch(() => props.max, value => {
        if (model.value.min > value) {
          model.value.min = value;
        }
        if (model.value.max > value) {
          model.value.max = value;
        }
      });

      function updateValue (change) {
        if (model.value.min !== props.modelValue.min || model.value.max !== props.modelValue.max) {
          emit('update:modelValue', { ...model.value });
        }
        change === true && emit('change', { ...model.value });
      }

      function getDragging (event) {
        const
          { left, top, width, height } = rootRef.value.getBoundingClientRect(),
          sensitivity = props.dragOnlyRange === true
            ? 0
            : (props.vertical === true
                ? minProps.domRef.value.offsetHeight / (2 * height)
                : minProps.domRef.value.offsetWidth / (2 * width)
              );

        const dragging = {
          left,
          top,
          width,
          height,
          valueMin: model.value.min,
          valueMax: model.value.max,
          ratioMin: modelMinRatio.value,
          ratioMax: modelMaxRatio.value
        };

        const ratio = getRatio(event, dragging, state.isReversed.value, props.vertical);
        let type;

        if (props.dragOnlyRange !== true && ratio < dragging.ratioMin + sensitivity) {
          type = dragType.MIN;
        }
        else if (props.dragOnlyRange === true || ratio < dragging.ratioMax - sensitivity) {
          if (props.dragRange === true || props.dragOnlyRange === true) {
            type = dragType.RANGE;
            Object.assign(dragging, {
              offsetRatio: ratio,
              offsetModel: getModel(ratio, props.min, props.max, props.step, state.decimals.value),
              rangeValue: dragging.valueMax - dragging.valueMin,
              rangeRatio: dragging.ratioMax - dragging.ratioMin
            });
          }
          else {
            type = dragging.ratioMax - ratio < ratio - dragging.ratioMin
              ? dragType.MAX
              : dragType.MIN;
          }
        }
        else {
          type = dragType.MAX;
        }

        dragging.type = type;
        nextFocus.value = null;

        return dragging
      }

      function updatePosition (event, dragging = state.dragging.value) {
        const
          ratio = getRatio(event, dragging, state.isReversed.value, props.vertical),
          localModel = getModel(ratio, props.min, props.max, props.step, state.decimals.value);
        let pos;

        switch (dragging.type) {
          case dragType.MIN:
            if (ratio <= dragging.ratioMax) {
              pos = {
                minR: ratio,
                maxR: dragging.ratioMax,
                min: localModel,
                max: dragging.valueMax
              };
              nextFocus.value = 'min';
            }
            else {
              pos = {
                minR: dragging.ratioMax,
                maxR: ratio,
                min: dragging.valueMax,
                max: localModel
              };
              nextFocus.value = 'max';
            }
            break

          case dragType.MAX:
            if (ratio >= dragging.ratioMin) {
              pos = {
                minR: dragging.ratioMin,
                maxR: ratio,
                min: dragging.valueMin,
                max: localModel
              };
              nextFocus.value = 'max';
            }
            else {
              pos = {
                minR: ratio,
                maxR: dragging.ratioMin,
                min: localModel,
                max: dragging.valueMin
              };
              nextFocus.value = 'min';
            }
            break

          case dragType.RANGE:
            const
              ratioDelta = ratio - dragging.offsetRatio,
              minR = between(dragging.ratioMin + ratioDelta, 0, 1 - dragging.rangeRatio),
              modelDelta = localModel - dragging.offsetModel,
              min = between(dragging.valueMin + modelDelta, props.min, props.max - dragging.rangeValue);

            pos = {
              minR,
              maxR: minR + dragging.rangeRatio,
              min: parseFloat(min.toFixed(state.decimals.value)),
              max: parseFloat((min + dragging.rangeValue).toFixed(state.decimals.value))
            };
            break
        }

        model.value = {
          min: pos.min,
          max: pos.max
        };

        // If either of the values to be emitted are null, set them to the defaults the user has entered.
        if (model.value.min === null || model.value.max === null) {
          model.value.min = pos.min || props.min;
          model.value.max = pos.max || props.max;
        }

        if (props.snap !== true || props.step === 0) {
          curMinRatio.value = pos.minR;
          curMaxRatio.value = pos.maxR;
        }
        else {
          curMinRatio.value = state.minMaxDiff.value === 0 ? 0 : (model.value.min - props.min) / state.minMaxDiff.value;
          curMaxRatio.value = state.minMaxDiff.value === 0 ? 0 : (model.value.max - props.min) / state.minMaxDiff.value;
        }
      }

      function onFocus (which) {
        state.focus.value = which;
      }

      function onKeydown (evt) {
        if (!keyCodes$2.includes(evt.keyCode)) {
          return
        }

        stopAndPrevent(evt);

        const
          stepVal = ([ 34, 33 ].includes(evt.keyCode) ? 10 : 1) * props.step,
          offset = [ 34, 37, 40 ].includes(evt.keyCode) ? -stepVal : stepVal;

        if (props.dragOnlyRange) {
          const interval = props.dragOnlyRange
            ? model.value.max - model.value.min
            : 0;

          const min = between(
            parseFloat((model.value.min + offset).toFixed(state.decimals.value)),
            props.min,
            props.max - interval
          );

          model.value = {
            min,
            max: parseFloat((min + interval).toFixed(state.decimals.value))
          };
        }
        else if (state.focus.value === false) {
          return
        }
        else {
          const which = state.focus.value;

          model.value = {
            ...model.value,
            [ which ]: between(
              parseFloat((model.value[ which ] + offset).toFixed(state.decimals.value)),
              which === 'min' ? props.min : model.value.min,
              which === 'max' ? props.max : model.value.max
            )
          };
        }

        updateValue();
      }

      function getThumb (sideProps) {
        const child = [
          methods.getThumbSvg(),
          vue.h('div', { class: 'q-slider__focus-ring' })
        ];

        if (props.label === true || props.labelAlways === true) {
          child.push(
            vue.h('div', {
              class: `q-slider__pin q-slider__pin${ state.axis.value } absolute` + sideProps.pinClass.value,
              style: sideProps.pinStyle.value.pin
            }, [
              vue.h('div', {
                class: `q-slider__pin-text-container q-slider__pin-text-container${ state.axis.value }`,
                style: sideProps.pinStyle.value.pinTextContainer
              }, [
                vue.h('span', {
                  class: 'q-slider__pin-text' + sideProps.pinTextClass.value
                }, sideProps.label.value)
              ])
            ]),

            vue.h('div', {
              class: `q-slider__arrow q-slider__arrow${ state.axis.value }` + sideProps.pinClass.value
            })
          );
        }

        return vue.h('div', {
          ref: sideProps.domRef,
          class: `q-slider__thumb-container q-slider__thumb-container${ state.axis.value } absolute non-selectable` + sideProps.thumbClass.value,
          style: sideProps.thumbStyle.value,
          ...sideProps.events.value,
          tabindex: props.dragOnlyRange !== true ? state.tabindex.value : null
        }, child)
      }

      return () => {
        const track = [
          vue.h('div', {
            class: `q-slider__track q-slider__track${ state.axis.value } absolute`,
            style: trackStyle.value
          })
        ];

        props.markers === true && track.push(
          vue.h('div', {
            class: `q-slider__track-markers q-slider__track-markers${ state.axis.value } absolute-full fit`,
            style: state.markerStyle.value
          })
        );

        const child = [
          vue.h('div', {
            class: `q-slider__track-container q-slider__track-container${ state.axis.value } absolute`
          }, track),

          getThumb(minProps),
          getThumb(maxProps)
        ];

        if (props.name !== void 0 && props.disable !== true) {
          injectFormInput(child, 'push');
        }

        const data = {
          ref: rootRef,
          class: 'q-range ' + state.classes.value + (
            props.modelValue.min === null || props.modelValue.max === null
              ? ' q-slider--no-value'
              : ''
          ),
          ...state.attributes.value,
          'aria-valuenow': props.modelValue.min + '|' + props.modelValue.max,
          tabindex: props.dragOnlyRange === true && $q.platform.is.mobile !== true
            ? state.tabindex.value
            : null,
          ...events.value
        };

        return hDir('div', data, child, 'slide', state.editable.value, () => state.panDirective.value)
      }
    }
  });

  var QRating = vue.defineComponent({
    name: 'QRating',

    props: {
      ...useSizeProps,
      ...useFormProps,

      modelValue: {
        type: Number,
        required: true
      },

      max: {
        type: [ String, Number ],
        default: 5
      },

      icon: [ String, Array ],
      iconHalf: [ String, Array ],
      iconSelected: [ String, Array ],

      color: [ String, Array ],
      colorHalf: [ String, Array ],
      colorSelected: [ String, Array ],

      noReset: Boolean,
      noDimming: Boolean,

      readonly: Boolean,
      disable: Boolean
    },

    emits: [ 'update:modelValue' ],

    setup (props, { slots, emit }) {
      const { proxy: { $q } } = vue.getCurrentInstance();

      const sizeStyle = useSize(props);
      const formAttrs = useFormAttrs(props);
      const injectFormInput = useFormInject(formAttrs);

      const mouseModel = vue.ref(0);

      let iconRefs = {};

      const editable = vue.computed(() =>
        props.readonly !== true && props.disable !== true
      );

      const classes = vue.computed(() =>
        'q-rating row inline items-center'
        + ` q-rating--${ editable.value === true ? '' : 'non-' }editable`
        + (props.noDimming === true ? ' q-rating--no-dimming' : '')
        + (props.disable === true ? ' disabled' : '')
        + (
          props.color !== void 0 && Array.isArray(props.color) === false
            ? ` text-${ props.color }`
            : ''
        )
      );

      const iconData = vue.computed(() => {
        const
          iconLen = Array.isArray(props.icon) === true ? props.icon.length : 0,
          selIconLen = Array.isArray(props.iconSelected) === true ? props.iconSelected.length : 0,
          halfIconLen = Array.isArray(props.iconHalf) === true ? props.iconHalf.length : 0,
          colorLen = Array.isArray(props.color) === true ? props.color.length : 0,
          selColorLen = Array.isArray(props.colorSelected) === true ? props.colorSelected.length : 0,
          halfColorLen = Array.isArray(props.colorHalf) === true ? props.colorHalf.length : 0;

        return {
          iconLen,
          icon: iconLen > 0 ? props.icon[ iconLen - 1 ] : props.icon,
          selIconLen,
          selIcon: selIconLen > 0 ? props.iconSelected[ selIconLen - 1 ] : props.iconSelected,
          halfIconLen,
          halfIcon: halfIconLen > 0 ? props.iconHalf[ selIconLen - 1 ] : props.iconHalf,
          colorLen,
          color: colorLen > 0 ? props.color[ colorLen - 1 ] : props.color,
          selColorLen,
          selColor: selColorLen > 0 ? props.colorSelected[ selColorLen - 1 ] : props.colorSelected,
          halfColorLen,
          halfColor: halfColorLen > 0 ? props.colorHalf[ halfColorLen - 1 ] : props.colorHalf
        }
      });

      const attributes = vue.computed(() => {
        if (props.disable === true) {
          return { 'aria-disabled': 'true' }
        }
        if (props.readonly === true) {
          return { 'aria-readonly': 'true' }
        }
      });

      function set (value) {
        if (editable.value === true) {
          const
            model = between(parseInt(value, 10), 1, parseInt(props.max, 10)),
            newVal = props.noReset !== true && props.modelValue === model ? 0 : model;

          newVal !== props.modelValue && emit('update:modelValue', newVal);
          mouseModel.value = 0;
        }
      }

      function setHoverValue (value) {
        if (editable.value === true) {
          mouseModel.value = value;
        }
      }

      function onKeyup (e, i) {
        switch (e.keyCode) {
          case 13:
          case 32:
            set(i);
            return stopAndPrevent(e)
          case 37: // LEFT ARROW
          case 40: // DOWN ARROW
            if (iconRefs[ `rt${ i - 1 }` ]) {
              iconRefs[ `rt${ i - 1 }` ].$el.focus();
            }
            return stopAndPrevent(e)
          case 39: // RIGHT ARROW
          case 38: // UP ARROW
            if (iconRefs[ `rt${ i + 1 }` ]) {
              iconRefs[ `rt${ i + 1 }` ].$el.focus();
            }
            return stopAndPrevent(e)
        }
      }

      function resetMouseModel () {
        mouseModel.value = 0;
      }

      vue.onBeforeUpdate(() => {
        iconRefs = {};
      });

      return () => {
        const
          child = [],
          tabindex = editable.value === true ? 0 : null,
          icons = iconData.value,
          ceil = Math.ceil(props.modelValue);

        const halfIndex = props.iconHalf === void 0 || ceil === props.modelValue
          ? -1
          : ceil;

        for (let i = 1; i <= props.max; i++) {
          const
            active = (mouseModel.value === 0 && props.modelValue >= i) || (mouseModel.value > 0 && mouseModel.value >= i),
            half = halfIndex === i && mouseModel.value < i,
            exSelected = mouseModel.value > 0 && (half === true ? ceil : props.modelValue) >= i && mouseModel.value < i,
            name = half === true
              ? (i <= icons.halfIconLen ? props.iconHalf[ i - 1 ] : icons.halfIcon)
              : (
                  icons.selIcon !== void 0 && (active === true || exSelected === true)
                    ? (i <= icons.selIconLen ? props.iconSelected[ i - 1 ] : icons.selIcon)
                    : (i <= icons.iconLen ? props.icon[ i - 1 ] : icons.icon)
                ),
            color = half === true
              ? (i <= icons.halfColorLen ? props.colorHalf[ i - 1 ] : icons.halfColor)
              : (
                  icons.selColor !== void 0 && active === true
                    ? (i <= icons.selColorLen ? props.colorSelected[ i - 1 ] : icons.selColor)
                    : (i <= icons.colorLen ? props.color[ i - 1 ] : icons.color)
                ),
            classes = 'q-rating__icon'
              + (active === true || half === true ? ' q-rating__icon--active' : '')
              + (exSelected === true ? ' q-rating__icon--exselected' : '')
              + (mouseModel.value === i ? ' q-rating__icon--hovered' : '')
              + (color !== void 0 ? ` text-${ color }` : '');

          child.push(
            vue.h(QIcon, {
              key: i,
              ref: vm => { iconRefs[ `rt${ i }` ] = vm; },
              class: classes,
              name: name || $q.iconSet.rating.icon,
              tabindex,
              onClick () { set(i); },
              onMouseover () { setHoverValue(i); },
              onMouseout: resetMouseModel,
              onFocus () { setHoverValue(i); },
              onBlur: resetMouseModel,
              onKeyup (e) { onKeyup(e, i); }
            }, slots[ `tip-${ i }` ])
          );
        }

        if (props.name !== void 0 && props.disable !== true) {
          injectFormInput(child, 'push');
        }

        return vue.h('div', {
          class: classes.value,
          style: sizeStyle.value,
          ...attributes.value
        }, child)
      }
    }
  });

  var QResponsive = vue.defineComponent({
    name: 'QResponsive',

    props: useRatioProps,

    setup (props, { slots }) {
      const ratioStyle = useRatio(props);

      return () => vue.h('div', {
        class: 'q-responsive'
      }, [
        vue.h('div', {
          class: 'q-responsive__filler overflow-hidden'
        }, [
          vue.h('div', { style: ratioStyle.value })
        ]),

        vue.h('div', {
          class: 'q-responsive__content absolute-full fit'
        }, hSlot(slots.default))
      ])
    }
  });

  const axisList = [ 'vertical', 'horizontal' ];
  const dirProps = {
    vertical: { offset: 'offsetY', scroll: 'scrollTop', dir: 'down', dist: 'y' },
    horizontal: { offset: 'offsetX', scroll: 'scrollLeft', dir: 'right', dist: 'x' }
  };

  var QScrollArea = vue.defineComponent({
    name: 'QScrollArea',

    props: {
      ...useDarkProps,

      thumbStyle: Object,
      verticalThumbStyle: Object,
      horizontalThumbStyle: Object,

      barStyle: [ Array, String, Object ],
      verticalBarStyle: [ Array, String, Object ],
      horizontalBarStyle: [ Array, String, Object ],

      contentStyle: [ Array, String, Object ],
      contentActiveStyle: [ Array, String, Object ],

      delay: {
        type: [ String, Number ],
        default: 1000
      },

      visible: {
        type: Boolean,
        default: null
      },

      tabindex: [ String, Number ],

      onScroll: Function
    },

    setup (props, { slots, emit }) {
      // state management
      const tempShowing = vue.ref(false);
      const panning = vue.ref(false);
      const hover = vue.ref(false);

      // other...
      const container = {
        vertical: vue.ref(0),
        horizontal: vue.ref(0)
      };

      const scroll = {
        vertical: {
          ref: vue.ref(null),
          position: vue.ref(0),
          size: vue.ref(0)
        },

        horizontal: {
          ref: vue.ref(null),
          position: vue.ref(0),
          size: vue.ref(0)
        }
      };

      const vm = vue.getCurrentInstance();

      const isDark = useDark(props, vm.proxy.$q);

      let timer, panRefPos;

      const targetRef = vue.ref(null);

      const classes = vue.computed(() =>
        'q-scrollarea'
        + (isDark.value === true ? ' q-scrollarea--dark' : '')
      );

      scroll.vertical.percentage = vue.computed(() => {
        const diff = scroll.vertical.size.value - container.vertical.value;
        if (diff <= 0) { return 0 }
        const p = between(scroll.vertical.position.value / diff, 0, 1);
        return Math.round(p * 10000) / 10000
      });
      scroll.vertical.thumbHidden = vue.computed(() =>
        (
          (props.visible === null ? hover.value : props.visible) !== true
          && tempShowing.value === false
          && panning.value === false
        ) || scroll.vertical.size.value <= container.vertical.value + 1
      );
      scroll.vertical.thumbSize = vue.computed(() =>
        Math.round(
          between(
            container.vertical.value * container.vertical.value / scroll.vertical.size.value,
            50,
            container.vertical.value
          )
        )
      );
      scroll.vertical.style = vue.computed(() => {
        const thumbSize = scroll.vertical.thumbSize.value;
        const pos = scroll.vertical.percentage.value * (container.vertical.value - thumbSize);
        return {
          ...props.thumbStyle,
          ...props.verticalThumbStyle,
          top: `${ pos }px`,
          height: `${ thumbSize }px`
        }
      });
      scroll.vertical.thumbClass = vue.computed(() =>
        'q-scrollarea__thumb q-scrollarea__thumb--v absolute-right'
        + (scroll.vertical.thumbHidden.value === true ? ' q-scrollarea__thumb--invisible' : '')
      );
      scroll.vertical.barClass = vue.computed(() =>
        'q-scrollarea__bar q-scrollarea__bar--v absolute-right'
        + (scroll.vertical.thumbHidden.value === true ? ' q-scrollarea__bar--invisible' : '')
      );

      scroll.horizontal.percentage = vue.computed(() => {
        const diff = scroll.horizontal.size.value - container.horizontal.value;
        if (diff <= 0) { return 0 }
        const p = between(scroll.horizontal.position.value / diff, 0, 1);
        return Math.round(p * 10000) / 10000
      });
      scroll.horizontal.thumbHidden = vue.computed(() =>
        (
          (props.visible === null ? hover.value : props.visible) !== true
          && tempShowing.value === false
          && panning.value === false
        ) || scroll.horizontal.size.value <= container.horizontal.value + 1
      );
      scroll.horizontal.thumbSize = vue.computed(() =>
        Math.round(
          between(
            container.horizontal.value * container.horizontal.value / scroll.horizontal.size.value,
            50,
            container.horizontal.value
          )
        )
      );
      scroll.horizontal.style = vue.computed(() => {
        const thumbSize = scroll.horizontal.thumbSize.value;
        const pos = scroll.horizontal.percentage.value * (container.horizontal.value - thumbSize);
        return {
          ...props.thumbStyle,
          ...props.horizontalThumbStyle,
          left: `${ pos }px`,
          width: `${ thumbSize }px`
        }
      });
      scroll.horizontal.thumbClass = vue.computed(() =>
        'q-scrollarea__thumb q-scrollarea__thumb--h absolute-bottom'
        + (scroll.horizontal.thumbHidden.value === true ? ' q-scrollarea__thumb--invisible' : '')
      );
      scroll.horizontal.barClass = vue.computed(() =>
        'q-scrollarea__bar q-scrollarea__bar--h absolute-bottom'
        + (scroll.horizontal.thumbHidden.value === true ? ' q-scrollarea__bar--invisible' : '')
      );

      const mainStyle = vue.computed(() => (
        scroll.vertical.thumbHidden.value === true || scroll.horizontal.thumbHidden.value === true
          ? props.contentStyle
          : props.contentActiveStyle
      ));

      const thumbVertDir = [ [
        TouchPan,
        e => { onPanThumb(e, 'vertical'); },
        void 0,
        {
          vertical: true,
          prevent: true,
          mouse: true,
          mouseAllDir: true
        }
      ] ];

      const thumbHorizDir = [ [
        TouchPan,
        e => { onPanThumb(e, 'horizontal'); },
        void 0,
        {
          horizontal: true,
          prevent: true,
          mouse: true,
          mouseAllDir: true
        }
      ] ];

      function getScroll () {
        const info = {};

        axisList.forEach(axis => {
          const data = scroll[ axis ];

          info[ axis + 'Position' ] = data.position.value;
          info[ axis + 'Percentage' ] = data.percentage.value;
          info[ axis + 'Size' ] = data.size.value;
          info[ axis + 'ContainerSize' ] = container[ axis ].value;
        });

        return info
      }

      // we have lots of listeners, so
      // ensure we're not emitting same info
      // multiple times
      const emitScroll = debounce(() => {
        const info = getScroll();
        info.ref = vm.proxy;
        emit('scroll', info);
      }, 0);

      function localSetScrollPosition (axis, offset, duration) {
        if (axisList.includes(axis) === false) {
          console.error('[QScrollArea]: wrong first param of setScrollPosition (vertical/horizontal)');
          return
        }

        const fn = axis === 'vertical'
          ? setVerticalScrollPosition
          : setHorizontalScrollPosition;

        fn(targetRef.value, offset, duration);
      }

      function updateContainer ({ height, width }) {
        let change = false;

        if (container.vertical.value !== height) {
          container.vertical.value = height;
          change = true;
        }

        if (container.horizontal.value !== width) {
          container.horizontal.value = width;
          change = true;
        }

        change === true && startTimer();
      }

      function updateScroll ({ position }) {
        let change = false;

        if (scroll.vertical.position.value !== position.top) {
          scroll.vertical.position.value = position.top;
          change = true;
        }

        if (scroll.horizontal.position.value !== position.left) {
          scroll.horizontal.position.value = position.left;
          change = true;
        }

        change === true && startTimer();
      }

      function updateScrollSize ({ height, width }) {
        if (scroll.horizontal.size.value !== width) {
          scroll.horizontal.size.value = width;
          startTimer();
        }

        if (scroll.vertical.size.value !== height) {
          scroll.vertical.size.value = height;
          startTimer();
        }
      }

      function onPanThumb (e, axis) {
        const data = scroll[ axis ];

        if (e.isFirst === true) {
          if (data.thumbHidden.value === true) {
            return
          }

          panRefPos = data.position.value;
          panning.value = true;
        }
        else if (panning.value !== true) {
          return
        }

        if (e.isFinal === true) {
          panning.value = false;
        }

        const dProp = dirProps[ axis ];
        const containerSize = container[ axis ].value;

        const multiplier = (data.size.value - containerSize) / (containerSize - data.thumbSize.value);
        const distance = e.distance[ dProp.dist ];
        const pos = panRefPos + (e.direction === dProp.dir ? 1 : -1) * distance * multiplier;

        setScroll(pos, axis);
      }

      function onMousedown (evt, axis) {
        const data = scroll[ axis ];

        if (data.thumbHidden.value !== true) {
          const pos = evt[ dirProps[ axis ].offset ] - data.thumbSize.value / 2;
          setScroll(pos / container[ axis ].value * data.size.value, axis);

          // activate thumb pan
          if (data.ref.value !== null) {
            data.ref.value.dispatchEvent(new MouseEvent(evt.type, evt));
          }
        }
      }

      function onVerticalMousedown (evt) {
        onMousedown(evt, 'vertical');
      }

      function onHorizontalMousedown (evt) {
        onMousedown(evt, 'horizontal');
      }

      function startTimer () {
        if (tempShowing.value === true) {
          clearTimeout(timer);
        }
        else {
          tempShowing.value = true;
        }

        timer = setTimeout(() => { tempShowing.value = false; }, props.delay);
        props.onScroll !== void 0 && emitScroll();
      }

      function setScroll (offset, axis) {
        targetRef.value[ dirProps[ axis ].scroll ] = offset;
      }

      function onMouseenter () {
        hover.value = true;
      }

      function onMouseleave () {
        hover.value = false;
      }

      // expose public methods
      Object.assign(vm.proxy, {
        getScrollTarget: () => targetRef.value,
        getScroll,
        getScrollPosition: () => ({
          top: scroll.vertical.position.value,
          left: scroll.horizontal.position.value
        }),
        getScrollPercentage: () => ({
          top: scroll.vertical.percentage.value,
          left: scroll.horizontal.percentage.value
        }),
        setScrollPosition: localSetScrollPosition,
        setScrollPercentage (axis, percentage, duration) {
          localSetScrollPosition(
            axis,
            percentage * (scroll[ axis ].size.value - container[ axis ].value),
            duration
          );
        }
      });

      return () => {
        return vue.h('div', {
          class: classes.value,
          onMouseenter,
          onMouseleave
        }, [
          vue.h('div', {
            ref: targetRef,
            class: 'q-scrollarea__container scroll relative-position fit hide-scrollbar',
            tabindex: props.tabindex !== void 0 ? props.tabindex : void 0
          }, [
            vue.h('div', {
              class: 'q-scrollarea__content absolute',
              style: mainStyle.value
            }, hMergeSlot(slots.default, [
              vue.h(QResizeObserver, {
                onResize: updateScrollSize
              })
            ])),

            vue.h(QScrollObserver, {
              axis: 'both',
              onScroll: updateScroll
            })
          ]),

          vue.h(QResizeObserver, { onResize: updateContainer }),

          vue.h('div', {
            class: scroll.vertical.barClass.value,
            style: [ props.barStyle, props.verticalBarStyle ],
            'aria-hidden': 'true',
            onMousedown: onVerticalMousedown
          }),

          vue.h('div', {
            class: scroll.horizontal.barClass.value,
            style: [ props.barStyle, props.horizontalBarStyle ],
            'aria-hidden': 'true',
            onMousedown: onHorizontalMousedown
          }),

          vue.withDirectives(
            vue.h('div', {
              ref: scroll.vertical.ref,
              class: scroll.vertical.thumbClass.value,
              style: scroll.vertical.style.value,
              'aria-hidden': 'true'
            }),
            thumbVertDir
          ),

          vue.withDirectives(
            vue.h('div', {
              ref: scroll.horizontal.ref,
              class: scroll.horizontal.thumbClass.value,
              style: scroll.horizontal.style.value,
              'aria-hidden': 'true'
            }),
            thumbHorizDir
          )
        ])
      }
    }
  });

  const aggBucketSize = 1000;

  const scrollToEdges = [
    'start',
    'center',
    'end',
    'start-force',
    'center-force',
    'end-force'
  ];

  const slice = Array.prototype.slice;

  let buggyRTL = void 0;

  // mobile Chrome takes the crown for this
  {
    const scroller = document.createElement('div');
    const spacer = document.createElement('div');

    scroller.setAttribute('dir', 'rtl');
    scroller.style.width = '1px';
    scroller.style.height = '1px';
    scroller.style.overflow = 'auto';

    spacer.style.width = '1000px';
    spacer.style.height = '1px';

    document.body.appendChild(scroller);
    scroller.appendChild(spacer);
    scroller.scrollLeft = -1000;

    buggyRTL = scroller.scrollLeft >= 0;

    scroller.remove();
  }

  let id$1 = 1;

  const setOverflowAnchor = window.getComputedStyle(document.body).overflowAnchor === void 0
    ? noop
    : function (id, index) {
      const ssId = id + '_ss';

      let styleSheet = document.getElementById(ssId);

      if (styleSheet === null) {
        styleSheet = document.createElement('style');
        styleSheet.type = 'text/css';
        styleSheet.id = ssId;
        document.head.appendChild(styleSheet);
      }

      if (styleSheet.qChildIndex !== index) {
        styleSheet.qChildIndex = index;
        styleSheet.innerHTML = `#${ id } > *:nth-child(${ index }) { overflow-anchor: auto }`;
      }
    };

  function sumFn (acc, h) {
    return acc + h
  }

  function getScrollDetails (
    parent,
    child,
    beforeRef,
    afterRef,
    horizontal,
    rtl,
    stickyStart,
    stickyEnd
  ) {
    const
      parentCalc = parent === window ? document.scrollingElement || document.documentElement : parent,
      propElSize = horizontal === true ? 'offsetWidth' : 'offsetHeight',
      details = {
        scrollStart: 0,
        scrollViewSize: -stickyStart - stickyEnd,
        scrollMaxSize: 0,
        offsetStart: -stickyStart,
        offsetEnd: -stickyEnd
      };

    if (horizontal === true) {
      if (parent === window) {
        details.scrollStart = window.pageXOffset || window.scrollX || document.body.scrollLeft || 0;
        details.scrollViewSize += window.innerWidth;
      }
      else {
        details.scrollStart = parentCalc.scrollLeft;
        details.scrollViewSize += parentCalc.clientWidth;
      }
      details.scrollMaxSize = parentCalc.scrollWidth;

      if (rtl === true) {
        details.scrollStart = (buggyRTL === true ? details.scrollMaxSize - details.scrollViewSize : 0) - details.scrollStart;
      }
    }
    else {
      if (parent === window) {
        details.scrollStart = window.pageYOffset || window.scrollY || document.body.scrollTop || 0;
        details.scrollViewSize += window.innerHeight;
      }
      else {
        details.scrollStart = parentCalc.scrollTop;
        details.scrollViewSize += parentCalc.clientHeight;
      }
      details.scrollMaxSize = parentCalc.scrollHeight;
    }

    if (beforeRef !== null) {
      for (let el = beforeRef.previousElementSibling; el !== null; el = el.previousElementSibling) {
        if (el.classList.contains('q-virtual-scroll--skip') === false) {
          details.offsetStart += el[ propElSize ];
        }
      }
    }

    if (afterRef !== null) {
      for (let el = afterRef.nextElementSibling; el !== null; el = el.nextElementSibling) {
        if (el.classList.contains('q-virtual-scroll--skip') === false) {
          details.offsetEnd += el[ propElSize ];
        }
      }
    }

    if (child !== parent) {
      const
        parentRect = parentCalc.getBoundingClientRect(),
        childRect = child.getBoundingClientRect();

      if (horizontal === true) {
        details.offsetStart += childRect.left - parentRect.left;
        details.offsetEnd -= childRect.width;
      }
      else {
        details.offsetStart += childRect.top - parentRect.top;
        details.offsetEnd -= childRect.height;
      }

      if (parent !== window) {
        details.offsetStart += details.scrollStart;
      }
      details.offsetEnd += details.scrollMaxSize - details.offsetStart;
    }

    return details
  }

  function setScroll (parent, scroll, horizontal, rtl) {
    if (parent === window) {
      if (horizontal === true) {
        if (rtl === true) {
          scroll = (buggyRTL === true ? document.body.scrollWidth - window.innerWidth : 0) - scroll;
        }
        window.scrollTo(scroll, window.pageYOffset || window.scrollY || document.body.scrollTop || 0);
      }
      else {
        window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, scroll);
      }
    }
    else if (horizontal === true) {
      if (rtl === true) {
        scroll = (buggyRTL === true ? parent.scrollWidth - parent.offsetWidth : 0) - scroll;
      }
      parent.scrollLeft = scroll;
    }
    else {
      parent.scrollTop = scroll;
    }
  }

  function sumSize (sizeAgg, size, from, to) {
    if (from >= to) { return 0 }

    const
      lastTo = size.length,
      fromAgg = Math.floor(from / aggBucketSize),
      toAgg = Math.floor((to - 1) / aggBucketSize) + 1;

    let total = sizeAgg.slice(fromAgg, toAgg).reduce(sumFn, 0);

    if (from % aggBucketSize !== 0) {
      total -= size.slice(fromAgg * aggBucketSize, from).reduce(sumFn, 0);
    }
    if (to % aggBucketSize !== 0 && to !== lastTo) {
      total -= size.slice(to, toAgg * aggBucketSize).reduce(sumFn, 0);
    }

    return total
  }

  const commonVirtScrollProps = {
    virtualScrollSliceSize: {
      type: [ Number, String ],
      default: null
    },

    virtualScrollSliceRatioBefore: {
      type: [ Number, String ],
      default: 1
    },

    virtualScrollSliceRatioAfter: {
      type: [ Number, String ],
      default: 1
    },

    virtualScrollItemSize: {
      type: [ Number, String ],
      default: 24
    },

    virtualScrollStickySizeStart: {
      type: [ Number, String ],
      default: 0
    },

    virtualScrollStickySizeEnd: {
      type: [ Number, String ],
      default: 0
    },

    tableColspan: [ Number, String ]
  };

  const commonVirtPropsList = Object.keys(commonVirtScrollProps);

  const useVirtualScrollProps = {
    virtualScrollHorizontal: Boolean,
    onVirtualScroll: Function,
    ...commonVirtScrollProps
  };

  function useVirtualScroll ({
    virtualScrollLength, getVirtualScrollTarget, getVirtualScrollEl,
    virtualScrollItemSizeComputed // optional
  }) {
    const vm = vue.getCurrentInstance();

    const { props, emit, proxy } = vm;
    const { $q } = proxy;

    let prevScrollStart, prevToIndex, localScrollViewSize, virtualScrollSizesAgg = [], virtualScrollSizes;

    const vsId = 'qvs_' + id$1++;

    const virtualScrollPaddingBefore = vue.ref(0);
    const virtualScrollPaddingAfter = vue.ref(0);
    const virtualScrollSliceSizeComputed = vue.ref({});

    const beforeRef = vue.ref(null);
    const afterRef = vue.ref(null);
    const contentRef = vue.ref(null);

    const virtualScrollSliceRange = vue.ref({ from: 0, to: 0 });

    const colspanAttr = vue.computed(() => (props.tableColspan !== void 0 ? props.tableColspan : 100));

    if (virtualScrollItemSizeComputed === void 0) {
      virtualScrollItemSizeComputed = vue.computed(() => props.virtualScrollItemSize);
    }

    const needsReset = vue.computed(() => virtualScrollItemSizeComputed.value + ';' + props.virtualScrollHorizontal);

    const needsSliceRecalc = vue.computed(() =>
      needsReset.value + ';' + props.virtualScrollSliceRatioBefore + ';' + props.virtualScrollSliceRatioAfter
    );

    vue.watch(needsSliceRecalc, () => { setVirtualScrollSize(); });
    vue.watch(needsReset, reset);

    function reset () {
      localResetVirtualScroll(prevToIndex, true);
    }

    function refresh (toIndex) {
      localResetVirtualScroll(toIndex === void 0 ? prevToIndex : toIndex);
    }

    function scrollTo (toIndex, edge) {
      const scrollEl = getVirtualScrollTarget();

      if (scrollEl === void 0 || scrollEl === null || scrollEl.nodeType === 8) {
        return
      }

      const scrollDetails = getScrollDetails(
        scrollEl,
        getVirtualScrollEl(),
        beforeRef.value,
        afterRef.value,
        props.virtualScrollHorizontal,
        $q.lang.rtl,
        props.virtualScrollStickySizeStart,
        props.virtualScrollStickySizeEnd
      );

      localScrollViewSize !== scrollDetails.scrollViewSize && setVirtualScrollSize(scrollDetails.scrollViewSize);

      setVirtualScrollSliceRange(
        scrollEl,
        scrollDetails,
        Math.min(virtualScrollLength.value - 1, Math.max(0, parseInt(toIndex, 10) || 0)),
        0,
        scrollToEdges.indexOf(edge) > -1 ? edge : (prevToIndex > -1 && toIndex > prevToIndex ? 'end' : 'start')
      );
    }

    function localOnVirtualScrollEvt () {
      const scrollEl = getVirtualScrollTarget();

      if (scrollEl === void 0 || scrollEl === null || scrollEl.nodeType === 8) {
        return
      }

      const
        scrollDetails = getScrollDetails(
          scrollEl,
          getVirtualScrollEl(),
          beforeRef.value,
          afterRef.value,
          props.virtualScrollHorizontal,
          $q.lang.rtl,
          props.virtualScrollStickySizeStart,
          props.virtualScrollStickySizeEnd
        ),
        listLastIndex = virtualScrollLength.value - 1,
        listEndOffset = scrollDetails.scrollMaxSize - scrollDetails.offsetStart - scrollDetails.offsetEnd - virtualScrollPaddingAfter.value;

      if (prevScrollStart === scrollDetails.scrollStart) {
        return
      }

      if (scrollDetails.scrollMaxSize <= 0) {
        setVirtualScrollSliceRange(scrollEl, scrollDetails, 0, 0);
        return
      }

      localScrollViewSize !== scrollDetails.scrollViewSize && setVirtualScrollSize(scrollDetails.scrollViewSize);

      updateVirtualScrollSizes(virtualScrollSliceRange.value.from);

      const scrollMaxStart = Math.floor(scrollDetails.scrollMaxSize
        - Math.max(scrollDetails.scrollViewSize, scrollDetails.offsetEnd)
        - Math.min(virtualScrollSizes[ listLastIndex ], scrollDetails.scrollViewSize / 2));

      if (scrollMaxStart > 0 && Math.ceil(scrollDetails.scrollStart) >= scrollMaxStart) {
        setVirtualScrollSliceRange(
          scrollEl,
          scrollDetails,
          listLastIndex,
          scrollDetails.scrollMaxSize - scrollDetails.offsetEnd - virtualScrollSizesAgg.reduce(sumFn, 0)
        );

        return
      }

      let
        toIndex = 0,
        listOffset = scrollDetails.scrollStart - scrollDetails.offsetStart,
        offset = listOffset;

      if (listOffset <= listEndOffset && listOffset + scrollDetails.scrollViewSize >= virtualScrollPaddingBefore.value) {
        listOffset -= virtualScrollPaddingBefore.value;
        toIndex = virtualScrollSliceRange.value.from;
        offset = listOffset;
      }
      else {
        for (let j = 0; listOffset >= virtualScrollSizesAgg[ j ] && toIndex < listLastIndex; j++) {
          listOffset -= virtualScrollSizesAgg[ j ];
          toIndex += aggBucketSize;
        }
      }

      while (listOffset > 0 && toIndex < listLastIndex) {
        listOffset -= virtualScrollSizes[ toIndex ];
        if (listOffset > -scrollDetails.scrollViewSize) {
          toIndex++;
          offset = listOffset;
        }
        else {
          offset = virtualScrollSizes[ toIndex ] + listOffset;
        }
      }

      setVirtualScrollSliceRange(
        scrollEl,
        scrollDetails,
        toIndex,
        offset
      );
    }

    function setVirtualScrollSliceRange (scrollEl, scrollDetails, toIndex, offset, align) {
      const alignForce = typeof align === 'string' && align.indexOf('-force') > -1;
      const alignEnd = alignForce === true ? align.replace('-force', '') : align;
      const alignRange = alignEnd !== void 0 ? alignEnd : 'start';

      let
        from = Math.max(0, toIndex - virtualScrollSliceSizeComputed.value[ alignRange ]),
        to = from + virtualScrollSliceSizeComputed.value.total;

      if (to > virtualScrollLength.value) {
        to = virtualScrollLength.value;
        from = Math.max(0, to - virtualScrollSliceSizeComputed.value.total);
      }

      prevScrollStart = scrollDetails.scrollStart;

      const rangeChanged = from !== virtualScrollSliceRange.value.from || to !== virtualScrollSliceRange.value.to;

      if (rangeChanged === false && alignEnd === void 0) {
        emitScroll(toIndex);
        return
      }

      const { activeElement } = document;
      if (
        rangeChanged === true
        && contentRef.value !== null
        && contentRef.value !== activeElement
        && contentRef.value.contains(activeElement) === true
      ) {
        const onBlurFn = () => {
          contentRef.value.focus();
        };

        activeElement.addEventListener('blur', onBlurFn, true);

        requestAnimationFrame(() => {
          activeElement.removeEventListener('blur', onBlurFn, true);
        });
      }

      setOverflowAnchor(vsId, toIndex - from + 1);

      const sizeBefore = alignEnd !== void 0 ? virtualScrollSizes.slice(from, toIndex).reduce(sumFn, 0) : 0;

      if (rangeChanged === true) {
        // vue key matching algorithm works only if
        // the array of VNodes changes on only one of the ends
        // so we first change one end and then the other

        const tempTo = to >= virtualScrollSliceRange.value.from && from <= virtualScrollSliceRange.value.to
          ? virtualScrollSliceRange.value.to
          : to;

        virtualScrollSliceRange.value = { from, to: tempTo };
        virtualScrollPaddingBefore.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, 0, from);
        virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, to, virtualScrollLength.value);

        requestAnimationFrame(() => {
          if (virtualScrollSliceRange.value.to !== to && prevScrollStart === scrollDetails.scrollStart) {
            virtualScrollSliceRange.value = { from: virtualScrollSliceRange.value.from, to };
            virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, to, virtualScrollLength.value);
          }
        });
      }

      requestAnimationFrame(() => {
        // if the scroll was changed give up
        // (another call to setVirtualScrollSliceRange before animation frame)
        if (prevScrollStart !== scrollDetails.scrollStart) {
          return
        }

        if (rangeChanged === true) {
          updateVirtualScrollSizes(from);
        }

        const
          sizeAfter = virtualScrollSizes.slice(from, toIndex).reduce(sumFn, 0),
          posStart = sizeAfter + scrollDetails.offsetStart + virtualScrollPaddingBefore.value,
          posEnd = posStart + virtualScrollSizes[ toIndex ];

        let scrollPosition = posStart + offset;

        if (alignEnd !== void 0) {
          const sizeDiff = sizeAfter - sizeBefore;
          const scrollStart = scrollDetails.scrollStart + sizeDiff;

          scrollPosition = alignForce !== true && scrollStart < posStart && posEnd < scrollStart + scrollDetails.scrollViewSize
            ? scrollStart
            : (
                alignEnd === 'end'
                  ? posEnd - scrollDetails.scrollViewSize
                  : posStart - (alignEnd === 'start' ? 0 : Math.round((scrollDetails.scrollViewSize - virtualScrollSizes[ toIndex ]) / 2))
              );
        }

        prevScrollStart = scrollPosition;

        setScroll(
          scrollEl,
          scrollPosition,
          props.virtualScrollHorizontal,
          $q.lang.rtl
        );

        emitScroll(toIndex);
      });
    }

    function updateVirtualScrollSizes (from) {
      const contentEl = contentRef.value;

      if (contentEl) {
        const
          children = slice.call(contentEl.children)
            .filter(el => el.classList.contains('q-virtual-scroll--skip') === false),
          childrenLength = children.length,
          sizeFn = props.virtualScrollHorizontal === true
            ? el => el.getBoundingClientRect().width
            : el => el.offsetHeight;

        let
          index = from,
          size, diff;

        for (let i = 0; i < childrenLength;) {
          size = sizeFn(children[ i ]);
          i++;

          while (i < childrenLength && children[ i ].classList.contains('q-virtual-scroll--with-prev') === true) {
            size += sizeFn(children[ i ]);
            i++;
          }

          diff = size - virtualScrollSizes[ index ];

          if (diff !== 0) {
            virtualScrollSizes[ index ] += diff;
            virtualScrollSizesAgg[ Math.floor(index / aggBucketSize) ] += diff;
          }

          index++;
        }
      }
    }

    function localResetVirtualScroll (toIndex, fullReset) {
      const defaultSize = 1 * virtualScrollItemSizeComputed.value;

      if (fullReset === true || Array.isArray(virtualScrollSizes) === false) {
        virtualScrollSizes = [];
      }

      const oldVirtualScrollSizesLength = virtualScrollSizes.length;

      virtualScrollSizes.length = virtualScrollLength.value;

      for (let i = virtualScrollLength.value - 1; i >= oldVirtualScrollSizesLength; i--) {
        virtualScrollSizes[ i ] = defaultSize;
      }

      const jMax = Math.floor((virtualScrollLength.value - 1) / aggBucketSize);
      virtualScrollSizesAgg = [];
      for (let j = 0; j <= jMax; j++) {
        let size = 0;
        const iMax = Math.min((j + 1) * aggBucketSize, virtualScrollLength.value);
        for (let i = j * aggBucketSize; i < iMax; i++) {
          size += virtualScrollSizes[ i ];
        }
        virtualScrollSizesAgg.push(size);
      }

      prevToIndex = -1;
      prevScrollStart = void 0;

      if (toIndex >= 0) {
        updateVirtualScrollSizes(virtualScrollSliceRange.value.from);
        vue.nextTick(() => { scrollTo(toIndex); });
      }
      else {
        virtualScrollPaddingBefore.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, 0, virtualScrollSliceRange.value.from);
        virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, virtualScrollSliceRange.value.to, virtualScrollLength.value);
        onVirtualScrollEvt();
      }
    }

    function setVirtualScrollSize (scrollViewSize) {
      if (scrollViewSize === void 0 && typeof window !== 'undefined') {
        const scrollEl = getVirtualScrollTarget();

        if (scrollEl !== void 0 && scrollEl !== null && scrollEl.nodeType !== 8) {
          scrollViewSize = getScrollDetails(
            scrollEl,
            getVirtualScrollEl(),
            beforeRef.value,
            afterRef.value,
            props.virtualScrollHorizontal,
            $q.lang.rtl,
            props.virtualScrollStickySizeStart,
            props.virtualScrollStickySizeEnd
          ).scrollViewSize;
        }
      }

      localScrollViewSize = scrollViewSize;

      const multiplier = 1 + props.virtualScrollSliceRatioBefore + props.virtualScrollSliceRatioAfter;
      const view = scrollViewSize === void 0 || scrollViewSize <= 0
        ? 1
        : Math.ceil(scrollViewSize / virtualScrollItemSizeComputed.value);

      const baseSize = Math.max(
        10,
        view,
        Math.ceil(props.virtualScrollSliceSize / multiplier)
      );

      virtualScrollSliceSizeComputed.value = {
        total: Math.ceil(baseSize * multiplier),
        start: Math.ceil(baseSize * props.virtualScrollSliceRatioBefore),
        center: Math.ceil(baseSize * (0.5 + props.virtualScrollSliceRatioBefore)),
        end: Math.ceil(baseSize * (1 + props.virtualScrollSliceRatioBefore)),
        view
      };
    }

    function padVirtualScroll (tag, content) {
      const paddingSize = props.virtualScrollHorizontal === true ? 'width' : 'height';
      const style = {
        [ '--q-virtual-scroll-item-' + paddingSize ]: virtualScrollItemSizeComputed.value + 'px'
      };

      return [
        tag === 'tbody'
          ? vue.h(tag, {
              class: 'q-virtual-scroll__padding',
              key: 'before',
              ref: beforeRef
            }, [
              vue.h('tr', [
                vue.h('td', {
                  style: { [ paddingSize ]: `${ virtualScrollPaddingBefore.value }px`, ...style },
                  colspan: colspanAttr.value
                })
              ])
            ])
          : vue.h(tag, {
            class: 'q-virtual-scroll__padding',
            key: 'before',
            ref: beforeRef,
            style: { [ paddingSize ]: `${ virtualScrollPaddingBefore.value }px`, ...style }
          }),

        vue.h(tag, {
          class: 'q-virtual-scroll__content',
          key: 'content',
          ref: contentRef,
          id: vsId,
          tabindex: -1
        }, content.flat()),

        tag === 'tbody'
          ? vue.h(tag, {
              class: 'q-virtual-scroll__padding',
              key: 'after',
              ref: afterRef
            }, [
              vue.h('tr', [
                vue.h('td', {
                  style: { [ paddingSize ]: `${ virtualScrollPaddingAfter.value }px`, ...style },
                  colspan: colspanAttr.value
                })
              ])
            ])
          : vue.h(tag, {
            class: 'q-virtual-scroll__padding',
            key: 'after',
            ref: afterRef,
            style: { [ paddingSize ]: `${ virtualScrollPaddingAfter.value }px`, ...style }
          })
      ]
    }

    function emitScroll (index) {
      if (prevToIndex !== index) {
        props.onVirtualScroll !== void 0 && emit('virtual-scroll', {
          index,
          from: virtualScrollSliceRange.value.from,
          to: virtualScrollSliceRange.value.to - 1,
          direction: index < prevToIndex ? 'decrease' : 'increase',
          ref: proxy
        });

        prevToIndex = index;
      }
    }

    setVirtualScrollSize();
    const onVirtualScrollEvt = debounce(localOnVirtualScrollEvt, $q.platform.is.ios === true ? 120 : 35);

    vue.onBeforeMount(() => {
      setVirtualScrollSize();
    });

    setOverflowAnchor !== noop && vue.onBeforeUnmount(() => {
      const styleSheet = document.getElementById(vsId + '_ss');
      styleSheet !== null && styleSheet.remove();
    });

    // expose public methods
    Object.assign(proxy, { scrollTo, reset, refresh });

    return {
      virtualScrollSliceRange,
      virtualScrollSliceSizeComputed,

      setVirtualScrollSize,
      onVirtualScrollEvt,
      localResetVirtualScroll,
      padVirtualScroll,

      scrollTo,
      reset,
      refresh
    }
  }

  const validateNewValueMode = v => [ 'add', 'add-unique', 'toggle' ].includes(v);
  const reEscapeList = '.*+?^${}()|[]\\';
  const fieldPropsList = Object.keys(useFieldProps);

  var QSelect = vue.defineComponent({
    name: 'QSelect',

    inheritAttrs: false,

    props: {
      ...useVirtualScrollProps,
      ...useFormProps,
      ...useFieldProps,

      modelValue: {
        required: true
      },

      multiple: Boolean,

      displayValue: [ String, Number ],
      displayValueHtml: Boolean,
      dropdownIcon: String,

      options: {
        type: Array,
        default: () => []
      },

      optionValue: [ Function, String ],
      optionLabel: [ Function, String ],
      optionDisable: [ Function, String ],

      hideSelected: Boolean,
      hideDropdownIcon: Boolean,
      fillInput: Boolean,

      maxValues: [ Number, String ],

      optionsDense: Boolean,
      optionsDark: {
        type: Boolean,
        default: null
      },
      optionsSelectedClass: String,
      optionsHtml: Boolean,

      optionsCover: Boolean,

      menuShrink: Boolean,
      menuAnchor: String,
      menuSelf: String,
      menuOffset: Array,

      popupContentClass: String,
      popupContentStyle: [ String, Array, Object ],

      useInput: Boolean,
      useChips: Boolean,

      newValueMode: {
        type: String,
        validator: validateNewValueMode
      },

      mapOptions: Boolean,
      emitValue: Boolean,

      inputDebounce: {
        type: [ Number, String ],
        default: 500
      },

      inputClass: [ Array, String, Object ],
      inputStyle: [ Array, String, Object ],

      tabindex: {
        type: [ String, Number ],
        default: 0
      },

      autocomplete: String,

      transitionShow: String,
      transitionHide: String,
      transitionDuration: [ String, Number ],

      behavior: {
        type: String,
        validator: v => [ 'default', 'menu', 'dialog' ].includes(v),
        default: 'default'
      },

      virtualScrollItemSize: {
        type: [ Number, String ],
        default: void 0
      },

      onNewValue: Function,
      onFilter: Function
    },

    emits: [
      ...useFieldEmits,
      'add', 'remove', 'input-value',
      'keyup', 'keypress', 'keydown',
      'filter-abort'
    ],

    setup (props, { slots, emit }) {
      const { proxy } = vue.getCurrentInstance();
      const { $q } = proxy;

      const menu = vue.ref(false);
      const dialog = vue.ref(false);
      const optionIndex = vue.ref(-1);
      const inputValue = vue.ref('');
      const dialogFieldFocused = vue.ref(false);
      const innerLoadingIndicator = vue.ref(false);

      let inputTimer, innerValueCache, optionScopeCache,
        hasDialog, userInputValue, filterId, defaultInputValue,
        transitionShowComputed, searchBuffer, searchBufferExp;

      const inputRef = vue.ref(null);
      const targetRef = vue.ref(null);
      const menuRef = vue.ref(null);
      const dialogRef = vue.ref(null);
      const menuContentRef = vue.ref(null);

      const nameProp = useFormInputNameAttr(props);

      const onComposition = useKeyComposition(onInput);

      const virtualScrollLength = vue.computed(() => (
        Array.isArray(props.options)
          ? props.options.length
          : 0
      ));

      const virtualScrollItemSizeComputed = vue.computed(() => (
        props.virtualScrollItemSize === void 0
          ? (props.dense === true ? 24 : 48)
          : props.virtualScrollItemSize
      ));

      const {
        virtualScrollSliceRange,
        virtualScrollSliceSizeComputed,
        localResetVirtualScroll,
        padVirtualScroll,
        onVirtualScrollEvt,
        scrollTo,
        setVirtualScrollSize
      } = useVirtualScroll({
        virtualScrollLength, getVirtualScrollTarget, getVirtualScrollEl,
        virtualScrollItemSizeComputed
      });

      const state = useFieldState();

      const innerValue = vue.computed(() => {
        const
          mapNull = props.mapOptions === true && props.multiple !== true,
          val = props.modelValue !== void 0 && (props.modelValue !== null || mapNull === true)
            ? (props.multiple === true && Array.isArray(props.modelValue) ? props.modelValue : [ props.modelValue ])
            : [];

        if (props.mapOptions === true && Array.isArray(props.options) === true) {
          const cache = props.mapOptions === true && innerValueCache !== void 0
            ? innerValueCache
            : [];
          const values = val.map(v => getOption(v, cache));

          return props.modelValue === null && mapNull === true
            ? values.filter(v => v !== null)
            : values
        }

        return val
      });

      const innerFieldProps = vue.computed(() => {
        const acc = {};
        fieldPropsList.forEach(key => props[ key ]);
        return acc
      });

      const isOptionsDark = vue.computed(() => (
        props.optionsDark === null
          ? state.isDark.value
          : props.optionsDark
      ));

      const hasValue = vue.computed(() => fieldValueIsFilled(innerValue.value));

      const computedInputClass = vue.computed(() => {
        let cls = 'q-field__input q-placeholder col';

        if (props.hideSelected === true || innerValue.value.length === 0) {
          return [ cls, props.inputClass ]
        }

        cls += ' q-field__input--padding';

        return props.inputClass === void 0
          ? cls
          : [ cls, props.inputClass ]
      });

      const menuContentClass = vue.computed(() =>
        (props.virtualScrollHorizontal === true ? 'q-virtual-scroll--horizontal' : '')
        + (props.popupContentClass ? ' ' + props.popupContentClass : '')
      );

      const noOptions = vue.computed(() => virtualScrollLength.value === 0);

      const selectedString = vue.computed(() =>
        innerValue.value
          .map(opt => getOptionLabel.value(opt))
          .join(', ')
      );

      const needsHtmlFn = vue.computed(() => (
        props.optionsHtml === true
          ? () => true
          : opt => opt !== void 0 && opt !== null && opt.html === true
      ));

      const valueAsHtml = vue.computed(() => (
        props.displayValueHtml === true || (
          props.displayValue === void 0 && (
            props.optionsHtml === true
            || innerValue.value.some(needsHtmlFn.value)
          )
        )
      ));

      const tabindex = vue.computed(() => (state.focused.value === true ? props.tabindex : -1));

      const selectedScope = vue.computed(() => {
        return innerValue.value.map((opt, i) => ({
          index: i,
          opt,
          html: needsHtmlFn.value(opt),
          selected: true,
          removeAtIndex: removeAtIndexAndFocus,
          toggleOption,
          tabindex: tabindex.value
        }))
      });

      const optionScope = vue.computed(() => {
        if (virtualScrollLength.value === 0) {
          return []
        }

        const { from, to } = virtualScrollSliceRange.value;
        const { options, optionEls } = optionScopeCache;

        return props.options.slice(from, to).map((opt, i) => {
          const disable = isOptionDisabled.value(opt) === true;
          const index = from + i;

          const itemProps = {
            clickable: true,
            active: false,
            activeClass: computedOptionsSelectedClass.value,
            manualFocus: true,
            focused: false,
            disable,
            tabindex: -1,
            dense: props.optionsDense,
            dark: isOptionsDark.value,
            onClick: () => { toggleOption(opt); }
          };

          if (disable !== true) {
            isOptionSelected(opt) === true && (itemProps.active = true);
            optionIndex.value === index && (itemProps.focused = true);

            if ($q.platform.is.desktop === true) {
              itemProps.onMousemove = () => { setOptionIndex(index); };
            }
          }

          const option = {
            index,
            opt,
            html: needsHtmlFn.value(opt),
            label: getOptionLabel.value(opt),
            selected: itemProps.active,
            focused: itemProps.focused,
            toggleOption,
            setOptionIndex,
            itemProps
          };

          const optionWithoutEvents = {
            ...option,
            itemProps: {
              ...itemProps,
              onClick: void 0,
              onMousemove: void 0
            }
          };

          if (options[ i ] === void 0 || isDeepEqual(optionWithoutEvents, options[ i ]) !== true) {
            options[ i ] = optionWithoutEvents;
            optionEls[ i ] = void 0;
          }

          return option
        })
      });

      const dropdownArrowIcon = vue.computed(() => (
        props.dropdownIcon !== void 0
          ? props.dropdownIcon
          : $q.iconSet.arrow.dropdown
      ));

      const squaredMenu = vue.computed(() =>
        props.optionsCover === false
        && props.outlined !== true
        && props.standout !== true
        && props.borderless !== true
        && props.rounded !== true
      );

      const computedOptionsSelectedClass = vue.computed(() => (
        props.optionsSelectedClass !== void 0
          ? props.optionsSelectedClass
          : (props.color !== void 0 ? `text-${ props.color }` : '')
      ));

      // returns method to get value of an option;
      // takes into account 'option-value' prop
      const getOptionValue = vue.computed(() => getPropValueFn(props.optionValue, 'value'));

      // returns method to get label of an option;
      // takes into account 'option-label' prop
      const getOptionLabel = vue.computed(() => getPropValueFn(props.optionLabel, 'label'));

      // returns method to tell if an option is disabled;
      // takes into account 'option-disable' prop
      const isOptionDisabled = vue.computed(() => getPropValueFn(props.optionDisable, 'disable'));

      const innerOptionsValue = vue.computed(() => innerValue.value.map(opt => getOptionValue.value(opt)));

      const inputControlEvents = vue.computed(() => {
        const evt = {
          onInput,
          // Safari < 10.2 & UIWebView doesn't fire compositionend when
          // switching focus before confirming composition choice
          // this also fixes the issue where some browsers e.g. iOS Chrome
          // fires "change" instead of "input" on autocomplete.
          onChange: onComposition,
          onKeydown: onTargetKeydown,
          onKeyup: onTargetAutocomplete,
          onKeypress: onTargetKeypress,
          onFocus: selectInputText,
          onClick (e) { hasDialog === true && stop(e); }
        };

        evt.onCompositionstart = evt.onCompositionupdate = evt.onCompositionend = onComposition;

        return evt
      });

      vue.watch(innerValue, val => {
        innerValueCache = val;

        if (
          props.useInput === true
          && props.fillInput === true
          && props.multiple !== true
          // Prevent re-entering in filter while filtering
          // Also prevent clearing inputValue while filtering
          && state.innerLoading.value !== true
          && ((dialog.value !== true && menu.value !== true) || hasValue.value !== true)
        ) {
          userInputValue !== true && resetInputValue();
          if (dialog.value === true || menu.value === true) {
            filter('');
          }
        }
      }, { immediate: true });

      vue.watch(() => props.fillInput, resetInputValue);

      vue.watch(menu, updateMenu);

      function getEmittingOptionValue (opt) {
        return props.emitValue === true
          ? getOptionValue.value(opt)
          : opt
      }

      function removeAtIndex (index) {
        if (index > -1 && index < innerValue.value.length) {
          if (props.multiple === true) {
            const model = props.modelValue.slice();
            emit('remove', { index, value: model.splice(index, 1)[ 0 ] });
            emit('update:modelValue', model);
          }
          else {
            emit('update:modelValue', null);
          }
        }
      }

      function removeAtIndexAndFocus (index) {
        removeAtIndex(index);
        state.focus();
      }

      function add (opt, unique) {
        const val = getEmittingOptionValue(opt);

        if (props.multiple !== true) {
          props.fillInput === true && updateInputValue(
            getOptionLabel.value(opt),
            true,
            true
          );

          emit('update:modelValue', val);
          return
        }

        if (innerValue.value.length === 0) {
          emit('add', { index: 0, value: val });
          emit('update:modelValue', props.multiple === true ? [ val ] : val);
          return
        }

        if (unique === true && isOptionSelected(opt) === true) {
          return
        }

        if (props.maxValues !== void 0 && props.modelValue.length >= props.maxValues) {
          return
        }

        const model = props.modelValue.slice();

        emit('add', { index: model.length, value: val });
        model.push(val);
        emit('update:modelValue', model);
      }

      function toggleOption (opt, keepOpen) {
        if (state.editable.value !== true || opt === void 0 || isOptionDisabled.value(opt) === true) {
          return
        }

        const optValue = getOptionValue.value(opt);

        if (props.multiple !== true) {
          if (keepOpen !== true) {
            updateInputValue(
              props.fillInput === true ? getOptionLabel.value(opt) : '',
              true,
              true
            );

            hidePopup();
          }

          targetRef.value !== null && targetRef.value.focus();

          if (isDeepEqual(getOptionValue.value(innerValue.value[ 0 ]), optValue) !== true) {
            emit('update:modelValue', props.emitValue === true ? optValue : opt);
          }
          return
        }

        (hasDialog !== true || dialogFieldFocused.value === true) && state.focus();

        selectInputText();

        if (innerValue.value.length === 0) {
          const val = props.emitValue === true ? optValue : opt;
          emit('add', { index: 0, value: val });
          emit('update:modelValue', props.multiple === true ? [ val ] : val);
          return
        }

        const
          model = props.modelValue.slice(),
          index = innerOptionsValue.value.findIndex(v => isDeepEqual(v, optValue));

        if (index > -1) {
          emit('remove', { index, value: model.splice(index, 1)[ 0 ] });
        }
        else {
          if (props.maxValues !== void 0 && model.length >= props.maxValues) {
            return
          }

          const val = props.emitValue === true ? optValue : opt;

          emit('add', { index: model.length, value: val });
          model.push(val);
        }

        emit('update:modelValue', model);
      }

      function setOptionIndex (index) {
        if ($q.platform.is.desktop !== true) { return }

        const val = index > -1 && index < virtualScrollLength.value
          ? index
          : -1;

        if (optionIndex.value !== val) {
          optionIndex.value = val;
        }
      }

      function moveOptionSelection (offset = 1, skipInputValue) {
        if (menu.value === true) {
          let index = optionIndex.value;
          do {
            index = normalizeToInterval(
              index + offset,
              -1,
              virtualScrollLength.value - 1
            );
          }
          while (index !== -1 && index !== optionIndex.value && isOptionDisabled.value(props.options[ index ]) === true)

          if (optionIndex.value !== index) {
            setOptionIndex(index);
            scrollTo(index);

            if (skipInputValue !== true && props.useInput === true && props.fillInput === true) {
              setInputValue(index >= 0
                ? getOptionLabel.value(props.options[ index ])
                : defaultInputValue
              );
            }
          }
        }
      }

      function getOption (value, valueCache) {
        const fn = opt => isDeepEqual(getOptionValue.value(opt), value);
        return props.options.find(fn) || valueCache.find(fn) || value
      }

      function getPropValueFn (propValue, defaultVal) {
        const val = propValue !== void 0
          ? propValue
          : defaultVal;

        return typeof val === 'function'
          ? val
          : opt => (Object(opt) === opt && val in opt ? opt[ val ] : opt)
      }

      function isOptionSelected (opt) {
        const val = getOptionValue.value(opt);
        return innerOptionsValue.value.find(v => isDeepEqual(v, val)) !== void 0
      }

      function selectInputText () {
        if (props.useInput === true && targetRef.value !== null) {
          targetRef.value.select();
        }
      }

      function onTargetKeyup (e) {
        // if ESC and we have an opened menu
        // then stop propagation (might be caught by a QDialog
        // and so it will also close the QDialog, which is wrong)
        if (isKeyCode(e, 27) === true && menu.value === true) {
          stop(e);
          // on ESC we need to close the dialog also
          hidePopup();
          resetInputValue();
        }

        emit('keyup', e);
      }

      function onTargetAutocomplete (e) {
        const { value } = e.target;

        if (e.keyCode !== void 0) {
          onTargetKeyup(e);
          return
        }

        e.target.value = '';
        clearTimeout(inputTimer);
        resetInputValue();

        if (typeof value === 'string' && value.length > 0) {
          const needle = value.toLocaleLowerCase();

          let fn = opt => getOptionValue.value(opt).toLocaleLowerCase() === needle;
          let option = props.options.find(fn);

          if (option !== void 0) {
            if (innerValue.value.indexOf(option) === -1) {
              toggleOption(option);
            }
            else {
              hidePopup();
            }
          }
          else {
            fn = opt => getOptionLabel.value(opt).toLocaleLowerCase() === needle;
            option = props.options.find(fn);

            if (option !== void 0) {
              if (innerValue.value.indexOf(option) === -1) {
                toggleOption(option);
              }
              else {
                hidePopup();
              }
            }
            else {
              filter(value, true);
            }
          }
        }
        else {
          state.clearValue(e);
        }
      }

      function onTargetKeypress (e) {
        emit('keypress', e);
      }

      function onTargetKeydown (e) {
        emit('keydown', e);

        if (shouldIgnoreKey(e) === true) {
          return
        }

        const newValueModeValid = inputValue.value.length > 0
          && (props.newValueMode !== void 0 || props.onNewValue !== void 0);

        const tabShouldSelect = e.shiftKey !== true
          && props.multiple !== true
          && (optionIndex.value > -1 || newValueModeValid === true);

        // escape
        if (e.keyCode === 27) {
          prevent(e); // prevent clearing the inputValue
          return
        }

        // tab
        if (e.keyCode === 9 && tabShouldSelect === false) {
          closeMenu();
          return
        }

        if (e.target === void 0 || e.target.id !== state.targetUid.value) { return }

        // down
        if (
          e.keyCode === 40
          && state.innerLoading.value !== true
          && menu.value === false
        ) {
          stopAndPrevent(e);
          showPopup();
          return
        }

        // backspace
        if (
          e.keyCode === 8
          && props.hideSelected !== true
          && inputValue.value.length === 0
        ) {
          if (props.multiple === true && Array.isArray(props.modelValue) === true) {
            removeAtIndex(props.modelValue.length - 1);
          }
          else if (props.multiple !== true && props.modelValue !== null) {
            emit('update:modelValue', null);
          }
          return
        }

        // home, end - 36, 35
        if (
          (e.keyCode === 35 || e.keyCode === 36)
          && (typeof inputValue.value !== 'string' || inputValue.value.length === 0)
        ) {
          stopAndPrevent(e);
          optionIndex.value = -1;
          moveOptionSelection(e.keyCode === 36 ? 1 : -1, props.multiple);
        }

        // pg up, pg down - 33, 34
        if (
          (e.keyCode === 33 || e.keyCode === 34)
          && virtualScrollSliceSizeComputed.value !== void 0
        ) {
          stopAndPrevent(e);
          optionIndex.value = Math.max(
            -1,
            Math.min(
              virtualScrollLength.value,
              optionIndex.value + (e.keyCode === 33 ? -1 : 1) * virtualScrollSliceSizeComputed.value.view
            )
          );
          moveOptionSelection(e.keyCode === 33 ? 1 : -1, props.multiple);
        }

        // up, down
        if (e.keyCode === 38 || e.keyCode === 40) {
          stopAndPrevent(e);
          moveOptionSelection(e.keyCode === 38 ? -1 : 1, props.multiple);
        }

        const optionsLength = virtualScrollLength.value;

        // clear search buffer if expired
        if (searchBuffer === void 0 || searchBufferExp < Date.now()) {
          searchBuffer = '';
        }

        // keyboard search when not having use-input
        if (
          optionsLength > 0
          && props.useInput !== true
          && e.key !== void 0
          && e.key.length === 1 // printable char
          && e.altKey === e.ctrlKey // not kbd shortcut
          && (e.keyCode !== 32 || searchBuffer.length > 0) // space in middle of search
        ) {
          menu.value !== true && showPopup(e);

          const
            char = e.key.toLocaleLowerCase(),
            keyRepeat = searchBuffer.length === 1 && searchBuffer[ 0 ] === char;

          searchBufferExp = Date.now() + 1500;
          if (keyRepeat === false) {
            stopAndPrevent(e);
            searchBuffer += char;
          }

          const searchRe = new RegExp('^' + searchBuffer.split('').map(l => (reEscapeList.indexOf(l) > -1 ? '\\' + l : l)).join('.*'), 'i');

          let index = optionIndex.value;

          if (keyRepeat === true || index < 0 || searchRe.test(getOptionLabel.value(props.options[ index ])) !== true) {
            do {
              index = normalizeToInterval(index + 1, -1, optionsLength - 1);
            }
            while (index !== optionIndex.value && (
              isOptionDisabled.value(props.options[ index ]) === true
              || searchRe.test(getOptionLabel.value(props.options[ index ])) !== true
            ))
          }

          if (optionIndex.value !== index) {
            vue.nextTick(() => {
              setOptionIndex(index);
              scrollTo(index);

              if (index >= 0 && props.useInput === true && props.fillInput === true) {
                setInputValue(getOptionLabel.value(props.options[ index ]));
              }
            });
          }

          return
        }

        // enter, space (when not using use-input and not in search), or tab (when not using multiple and option selected)
        // same target is checked above
        if (
          e.keyCode !== 13
          && (e.keyCode !== 32 || props.useInput === true || searchBuffer !== '')
          && (e.keyCode !== 9 || tabShouldSelect === false)
        ) { return }

        e.keyCode !== 9 && stopAndPrevent(e);

        if (optionIndex.value > -1 && optionIndex.value < optionsLength) {
          toggleOption(props.options[ optionIndex.value ]);
          return
        }

        if (newValueModeValid === true) {
          const done = (val, mode) => {
            if (mode) {
              if (validateNewValueMode(mode) !== true) {
                return
              }
            }
            else {
              mode = props.newValueMode;
            }

            if (val === void 0 || val === null) {
              return
            }

            updateInputValue('', props.multiple !== true, true);

            const fn = mode === 'toggle' ? toggleOption : add;
            fn(val, mode === 'add-unique');

            if (props.multiple !== true) {
              targetRef.value !== null && targetRef.value.focus();
              hidePopup();
            }
          };

          if (props.onNewValue !== void 0) {
            emit('new-value', inputValue.value, done);
          }
          else {
            done(inputValue.value);
          }

          if (props.multiple !== true) {
            return
          }
        }

        if (menu.value === true) {
          closeMenu();
        }
        else if (state.innerLoading.value !== true) {
          showPopup();
        }
      }

      function getVirtualScrollEl () {
        return hasDialog === true
          ? menuContentRef.value
          : (
              menuRef.value !== null && menuRef.value.__qPortalInnerRef.value !== null
                ? menuRef.value.__qPortalInnerRef.value
                : void 0
            )
      }

      function getVirtualScrollTarget () {
        return getVirtualScrollEl()
      }

      function getSelection () {
        if (props.hideSelected === true) {
          return []
        }

        if (slots[ 'selected-item' ] !== void 0) {
          return selectedScope.value.map(scope => slots[ 'selected-item' ](scope)).slice()
        }

        if (slots.selected !== void 0) {
          return slots.selected().slice()
        }

        if (props.useChips === true) {
          return selectedScope.value.map((scope, i) => vue.h(QChip, {
            key: 'option-' + i,
            removable: state.editable.value === true && isOptionDisabled.value(scope.opt) !== true,
            dense: true,
            textColor: props.color,
            tabindex: tabindex.value,
            onRemove () { scope.removeAtIndex(i); }
          }, () => vue.h('span', {
            class: 'ellipsis',
            [ scope.html === true ? 'innerHTML' : 'textContent' ]: getOptionLabel.value(scope.opt)
          })))
        }

        return [
          vue.h('span', {
            [ valueAsHtml.value === true ? 'innerHTML' : 'textContent' ]: props.displayValue !== void 0
              ? props.displayValue
              : selectedString.value
          })
        ]
      }

      function getAllOptions () {
        if (
          slots.option !== void 0
          && optionScopeCache.optionSlot !== slots.option
        ) {
          optionScopeCache.optionSlot = slots.option;
          optionScopeCache.optionEls = [];
        }

        const fn = slots.option !== void 0
          ? slots.option
          : scope => {
            return vue.h(QItem, {
              key: scope.index,
              ...scope.itemProps
            }, () => {
              return vue.h(
                QItemSection,
                () => vue.h(
                  QItemLabel,
                  () => vue.h('span', {
                    [ scope.html === true ? 'innerHTML' : 'textContent' ]: scope.label
                  })
                )
              )
            })
          };

        const { optionEls } = optionScopeCache;

        let options = padVirtualScroll('div', optionScope.value.map((scope, i) => {
          if (optionEls[ i ] === void 0) {
            optionEls[ i ] = fn(scope);
          }

          return optionEls[ i ]
        }));

        if (slots[ 'before-options' ] !== void 0) {
          options = slots[ 'before-options' ]().concat(options);
        }

        return hMergeSlot(slots[ 'after-options' ], options)
      }

      function getInput (fromDialog, isTarget) {
        const data = {
          ref: isTarget === true ? targetRef : void 0,
          key: 'i_t',
          class: computedInputClass.value,
          style: props.inputStyle,
          value: inputValue.value !== void 0 ? inputValue.value : '',
          // required for Android in order to show ENTER key when in form
          type: 'search',
          ...state.splitAttrs.attributes.value,
          id: state.targetUid.value,
          maxlength: props.maxlength,
          tabindex: props.tabindex,
          autocomplete: props.autocomplete,
          'data-autofocus': (fromDialog !== true && props.autofocus === true) || void 0,
          disabled: props.disable === true,
          readonly: props.readonly === true,
          ...inputControlEvents.value
        };

        if (fromDialog !== true && hasDialog === true) {
          if (Array.isArray(data.class) === true) {
            data.class[ 0 ] += ' no-pointer-events';
          }
          else {
            data.class += ' no-pointer-events';
          }
        }

        return vue.h('input', data)
      }

      function onInput (e) {
        clearTimeout(inputTimer);

        if (e && e.target && e.target.composing === true) {
          return
        }

        setInputValue(e.target.value || '');
        // mark it here as user input so that if updateInputValue is called
        // before filter is called the indicator is reset
        userInputValue = true;
        defaultInputValue = inputValue.value;

        if (
          state.focused.value !== true
          && (hasDialog !== true || dialogFieldFocused.value === true)
        ) {
          state.focus();
        }

        if (props.onFilter !== void 0) {
          inputTimer = setTimeout(() => {
            filter(inputValue.value);
          }, props.inputDebounce);
        }
      }

      function setInputValue (val) {
        if (inputValue.value !== val) {
          inputValue.value = val;
          emit('input-value', val);
        }
      }

      function updateInputValue (val, noFiltering, internal) {
        userInputValue = internal !== true;

        if (props.useInput === true) {
          setInputValue(val);

          if (noFiltering === true || internal !== true) {
            defaultInputValue = val;
          }

          noFiltering !== true && filter(val);
        }
      }

      function filter (val, keepClosed) {
        if (props.onFilter === void 0 || (keepClosed !== true && state.focused.value !== true)) {
          return
        }

        if (state.innerLoading.value === true) {
          emit('filter-abort');
        }
        else {
          state.innerLoading.value = true;
          innerLoadingIndicator.value = true;
        }

        if (
          val !== ''
          && props.multiple !== true
          && innerValue.value.length > 0
          && userInputValue !== true
          && val === getOptionLabel.value(innerValue.value[ 0 ])
        ) {
          val = '';
        }

        const localFilterId = setTimeout(() => {
          menu.value === true && (menu.value = false);
        }, 10);

        clearTimeout(filterId);
        filterId = localFilterId;

        emit(
          'filter',
          val,
          (fn, afterFn) => {
            if ((keepClosed === true || state.focused.value === true) && filterId === localFilterId) {
              clearTimeout(filterId);

              typeof fn === 'function' && fn();

              // hide indicator to allow arrow to animate
              innerLoadingIndicator.value = false;

              vue.nextTick(() => {
                state.innerLoading.value = false;

                if (state.editable.value === true) {
                  if (keepClosed === true) {
                    menu.value === true && hidePopup();
                  }
                  else if (menu.value === true) {
                    updateMenu(true);
                  }
                  else {
                    menu.value = true;
                  }
                }

                typeof afterFn === 'function' && vue.nextTick(() => { afterFn(proxy); });
              });
            }
          },
          () => {
            if (state.focused.value === true && filterId === localFilterId) {
              clearTimeout(filterId);
              state.innerLoading.value = false;
              innerLoadingIndicator.value = false;
            }
            menu.value === true && (menu.value = false);
          }
        );
      }

      function getMenu () {
        const child = noOptions.value === true
          ? (
              slots[ 'no-option' ] !== void 0
                ? () => slots[ 'no-option' ]({ inputValue: inputValue.value })
                : void 0
            )
          : getAllOptions;

        return vue.h(QMenu, {
          ref: menuRef,
          class: menuContentClass.value,
          style: props.popupContentStyle,
          modelValue: menu.value,
          fit: props.menuShrink !== true,
          cover: props.optionsCover === true && noOptions.value !== true && props.useInput !== true,
          anchor: props.menuAnchor,
          self: props.menuSelf,
          offset: props.menuOffset,
          dark: isOptionsDark.value,
          noParentEvent: true,
          noRefocus: true,
          noFocus: true,
          square: squaredMenu.value,
          transitionShow: props.transitionShow,
          transitionHide: props.transitionHide,
          transitionDuration: props.transitionDuration,
          separateClosePopup: true,
          onScrollPassive: onVirtualScrollEvt,
          onBeforeShow: onControlPopupShow,
          onBeforeHide: onMenuBeforeHide,
          onShow: onMenuShow
        }, child)
      }

      function onMenuBeforeHide (e) {
        onControlPopupHide(e);
        closeMenu();
      }

      function onMenuShow () {
        setVirtualScrollSize();
      }

      function onDialogFieldFocus (e) {
        stop(e);
        targetRef.value !== null && targetRef.value.focus();
        dialogFieldFocused.value = true;
        window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, 0);
      }

      function onDialogFieldBlur (e) {
        stop(e);
        vue.nextTick(() => {
          dialogFieldFocused.value = false;
        });
      }

      function getDialog () {
        const content = [
          vue.h(QField, {
            class: `col-auto ${ state.fieldClass }`,
            ...innerFieldProps.value,
            for: state.targetUid.value,
            dark: isOptionsDark.value,
            square: true,
            loading: innerLoadingIndicator.value,
            itemAligned: false,
            filled: true,
            stackLabel: inputValue.value.length > 0,
            ...state.splitAttrs.listeners.value,
            onFocus: onDialogFieldFocus,
            onBlur: onDialogFieldBlur
          }, {
            ...slots,
            rawControl: () => state.getControl(true),
            before: void 0,
            after: void 0
          })
        ];

        menu.value === true && content.push(
          vue.h('div', {
            ref: menuContentRef,
            class: menuContentClass.value + ' scroll',
            style: props.popupContentStyle,
            onClick: prevent,
            onScrollPassive: onVirtualScrollEvt
          }, (
            noOptions.value === true
              ? (
                  slots[ 'no-option' ] !== void 0
                    ? slots[ 'no-option' ]({ inputValue: inputValue.value })
                    : null
                )
              : getAllOptions()
          ))
        );

        return vue.h(QDialog, {
          ref: dialogRef,
          modelValue: dialog.value,
          position: props.useInput === true ? 'top' : void 0,
          transitionShow: transitionShowComputed,
          transitionHide: props.transitionHide,
          transitionDuration: props.transitionDuration,
          onBeforeShow: onControlPopupShow,
          onBeforeHide: onDialogBeforeHide,
          onHide: onDialogHide,
          onShow: onDialogShow
        }, () => vue.h('div', {
          class: 'q-select__dialog'
            + (isOptionsDark.value === true ? ' q-select__dialog--dark q-dark' : '')
            + (dialogFieldFocused.value === true ? ' q-select__dialog--focused' : '')
        }, content))
      }

      function onDialogBeforeHide (e) {
        onControlPopupHide(e);

        if (dialogRef.value !== null) {
          dialogRef.value.__updateRefocusTarget(
            state.rootRef.value.querySelector('.q-field__native > [tabindex]:last-child')
          );
        }

        state.focused.value = false;
      }

      function onDialogHide (e) {
        hidePopup();
        state.focused.value === false && emit('blur', e);
        resetInputValue();
      }

      function onDialogShow () {
        const el = document.activeElement;
        if (
          (el === null || el.id !== state.targetUid.value)
          && targetRef.value !== null
          && targetRef.value !== el
        ) {
          targetRef.value.focus();
        }

        setVirtualScrollSize();
      }

      function closeMenu () {
        if (optionScopeCache !== void 0) {
          optionScopeCache.optionEls = [];
        }

        if (dialog.value === true) {
          return
        }

        optionIndex.value = -1;

        if (menu.value === true) {
          menu.value = false;
        }

        if (state.focused.value === false) {
          clearTimeout(filterId);
          filterId = void 0;

          if (state.innerLoading.value === true) {
            emit('filter-abort');
            state.innerLoading.value = false;
            innerLoadingIndicator.value = false;
          }
        }
      }

      function showPopup (e) {
        if (state.editable.value !== true) {
          return
        }

        if (hasDialog === true) {
          state.onControlFocusin(e);
          dialog.value = true;
          vue.nextTick(() => {
            state.focus();
          });
        }
        else {
          state.focus();
        }

        if (props.onFilter !== void 0) {
          filter(inputValue.value);
        }
        else if (noOptions.value !== true || slots[ 'no-option' ] !== void 0) {
          menu.value = true;
        }
      }

      function hidePopup () {
        dialog.value = false;
        closeMenu();
      }

      function resetInputValue () {
        props.useInput === true && updateInputValue(
          props.multiple !== true && props.fillInput === true && innerValue.value.length > 0
            ? getOptionLabel.value(innerValue.value[ 0 ]) || ''
            : '',
          true,
          true
        );
      }

      function updateMenu (show) {
        let optionIndex = -1;

        if (show === true) {
          if (innerValue.value.length > 0) {
            const val = getOptionValue.value(innerValue.value[ 0 ]);
            optionIndex = props.options.findIndex(v => isDeepEqual(getOptionValue.value(v), val));
          }

          localResetVirtualScroll(optionIndex);
        }

        setOptionIndex(optionIndex);
      }

      function updateMenuPosition () {
        if (dialog.value === false && menuRef.value !== null) {
          menuRef.value.updatePosition();
        }
      }

      function onControlPopupShow (e) {
        e !== void 0 && stop(e);
        emit('popup-show', e);
        state.hasPopupOpen.value = true;
        state.onControlFocusin(e);
      }

      function onControlPopupHide (e) {
        e !== void 0 && stop(e);
        emit('popup-hide', e);
        state.hasPopupOpen.value = false;
        state.onControlFocusout(e);
      }

      function updatePreState () {
        hasDialog = $q.platform.is.mobile !== true && props.behavior !== 'dialog'
          ? false
          : props.behavior !== 'menu' && (
            props.useInput === true
              ? slots[ 'no-option' ] !== void 0 || props.onFilter !== void 0 || noOptions.value === false
              : true
          );

        transitionShowComputed = $q.platform.is.ios === true && hasDialog === true && props.useInput === true
          ? 'fade'
          : props.transitionShow;
      }

      vue.onBeforeUpdate(updatePreState);
      vue.onUpdated(updateMenuPosition);

      updatePreState();

      vue.onBeforeMount(() => {
        optionScopeCache = {
          optionSlot: slots.option,
          options: [],
          optionEls: []
        };
      });

      vue.onBeforeUnmount(() => {
        optionScopeCache = void 0;
        clearTimeout(inputTimer);
      });

      // expose public methods
      Object.assign(proxy, {
        showPopup, hidePopup,
        removeAtIndex, add, toggleOption,
        setOptionIndex, moveOptionSelection,
        filter, updateMenuPosition, updateInputValue,
        isOptionSelected,
        getEmittingOptionValue,
        isOptionDisabled: () => isOptionDisabled.value.apply(null, arguments),
        getOptionValue: () => getOptionValue.value.apply(null, arguments),
        getOptionLabel: () => getOptionLabel.value.apply(null, arguments)
      });

      Object.assign(state, {
        innerValue,

        fieldClass: vue.computed(() =>
          `q-select q-field--auto-height q-select--with${ props.useInput !== true ? 'out' : '' }-input`
          + ` q-select--with${ props.useChips !== true ? 'out' : '' }-chips`
          + ` q-select--${ props.multiple === true ? 'multiple' : 'single' }`
        ),

        inputRef,
        targetRef,
        hasValue,
        showPopup,

        floatingLabel: vue.computed(() =>
          (props.hideSelected === true
            ? inputValue.value.length > 0
            : hasValue.value === true
          )
          || fieldValueIsFilled(props.displayValue)
        ),

        getControlChild: () => {
          if (
            state.editable.value !== false && (
              dialog.value === true // dialog always has menu displayed, so need to render it
              || noOptions.value !== true
              || slots[ 'no-option' ] !== void 0
            )
          ) {
            return hasDialog === true ? getDialog() : getMenu()
          }
        },

        controlEvents: {
          onFocusin (e) { state.onControlFocusin(e); },
          onFocusout (e) {
            state.onControlFocusout(e, () => {
              resetInputValue();
              closeMenu();
            });
          },
          onClick (e) {
            if (hasDialog !== true) {
              // label from QField will propagate click on the input (except IE)
              prevent(e);

              if (menu.value === true) {
                closeMenu();
                targetRef.value !== null && targetRef.value.focus();
                return
              }
            }

            showPopup(e);
          }
        },

        getControl: fromDialog => {
          const child = getSelection();
          const isTarget = fromDialog === true || dialog.value !== true || hasDialog !== true;

          if (props.useInput === true) {
            child.push(getInput(fromDialog, isTarget));
          }
          // there can be only one (when dialog is opened the control in dialog should be target)
          else if (state.editable.value === true && isTarget === true) {
            child.push(
              vue.h('div', {
                ref: targetRef,
                key: 'd_t',
                class: 'no-outline',
                id: state.targetUid.value,
                tabindex: props.tabindex,
                onKeydown: onTargetKeydown,
                onKeyup: onTargetKeyup,
                onKeypress: onTargetKeypress
              })
            );

            if (typeof props.autocomplete === 'string' && props.autocomplete.length > 0) {
              child.push(
                vue.h('input', {
                  class: 'q-select__autocomplete-input no-outline',
                  autocomplete: props.autocomplete,
                  onKeyup: onTargetAutocomplete
                })
              );
            }
          }

          if (nameProp.value !== void 0 && props.disable !== true && innerOptionsValue.value.length > 0) {
            const opts = innerOptionsValue.value.map(value => vue.h('option', { value, selected: true }));

            child.push(
              vue.h('select', {
                class: 'hidden',
                name: nameProp.value,
                multiple: props.multiple
              }, opts)
            );
          }

          return vue.h('div', {
            class: 'q-field__native row items-center',
            ...state.splitAttrs.attributes.value
          }, child)
        },

        getInnerAppend: () => (
          props.loading !== true && innerLoadingIndicator.value !== true && props.hideDropdownIcon !== true
            ? [
                vue.h(QIcon, {
                  class: 'q-select__dropdown-icon' + (menu.value === true ? ' rotate-180' : ''),
                  name: dropdownArrowIcon.value
                })
              ]
            : null
        )
      });

      return useField(state)
    }
  });

  const skeletonTypes = [
    'text', 'rect', 'circle',
    'QBtn', 'QBadge', 'QChip', 'QToolbar',
    'QCheckbox', 'QRadio', 'QToggle',
    'QSlider', 'QRange', 'QInput',
    'QAvatar'
  ];

  const skeletonAnimations = [
    'wave', 'pulse', 'pulse-x', 'pulse-y', 'fade', 'blink', 'none'
  ];

  var QSkeleton = vue.defineComponent({
    name: 'QSkeleton',

    props: {
      ...useDarkProps,

      tag: {
        type: String,
        default: 'div'
      },

      type: {
        type: String,
        validator: v => skeletonTypes.includes(v),
        default: 'rect'
      },

      animation: {
        type: String,
        validator: v => skeletonAnimations.includes(v),
        default: 'wave'
      },

      square: Boolean,
      bordered: Boolean,

      size: String,
      width: String,
      height: String
    },

    setup (props, { slots }) {
      const vm = vue.getCurrentInstance();
      const isDark = useDark(props, vm.proxy.$q);

      const style = vue.computed(() => (
        props.size !== void 0
          ? { width: props.size, height: props.size }
          : { width: props.width, height: props.height }
      ));

      const classes = vue.computed(() =>
        `q-skeleton q-skeleton--${ isDark.value === true ? 'dark' : 'light' } q-skeleton--type-${ props.type }`
        + (props.animation !== 'none' ? ` q-skeleton--anim q-skeleton--anim-${ props.animation }` : '')
        + (props.square === true ? ' q-skeleton--square' : '')
        + (props.bordered === true ? ' q-skeleton--bordered' : '')
      );

      return () => vue.h(props.tag, {
        class: classes.value,
        style: style.value
      }, hSlot(slots.default))
    }
  });

  const slotsDef = [
    [ 'left', 'center', 'start', 'width' ],
    [ 'right', 'center', 'end', 'width' ],
    [ 'top', 'start', 'center', 'height' ],
    [ 'bottom', 'end', 'center', 'height' ]
  ];

  var QSlideItem = vue.defineComponent({
    name: 'QSlideItem',

    props: {
      ...useDarkProps,

      leftColor: String,
      rightColor: String,
      topColor: String,
      bottomColor: String,

      onSlide: Function
    },

    emits: [ 'action', 'top', 'right', 'bottom', 'left' ],

    setup (props, { slots, emit }) {
      const { proxy } = vue.getCurrentInstance();
      const { $q } = proxy;

      const isDark = useDark(props, $q);
      const { getCacheWithFn } = useCache();

      const contentRef = vue.ref(null);

      let timer, pan = {}, dirRefs = {}, dirContentRefs = {};

      const langDir = vue.computed(() => (
        $q.lang.rtl === true
          ? { left: 'right', right: 'left' }
          : { left: 'left', right: 'right' }
      ));

      const classes = vue.computed(() =>
        'q-slide-item q-item-type overflow-hidden'
        + (isDark.value === true ? ' q-slide-item--dark q-dark' : '')
      );

      function reset () {
        contentRef.value.style.transform = 'translate(0,0)';
      }

      function emitSlide (side, ratio, isReset) {
        props.onSlide !== void 0 && emit('slide', { side, ratio, isReset });
      }

      function onPan (evt) {
        const node = contentRef.value;

        if (evt.isFirst) {
          pan = {
            dir: null,
            size: { left: 0, right: 0, top: 0, bottom: 0 },
            scale: 0
          };

          node.classList.add('no-transition');

          slotsDef.forEach(slotName => {
            if (slots[ slotName[ 0 ] ] !== void 0) {
              const node = dirContentRefs[ slotName[ 0 ] ];
              node.style.transform = 'scale(1)';
              pan.size[ slotName[ 0 ] ] = node.getBoundingClientRect()[ slotName[ 3 ] ];
            }
          });

          pan.axis = (evt.direction === 'up' || evt.direction === 'down')
            ? 'Y'
            : 'X';
        }
        else if (evt.isFinal) {
          node.classList.remove('no-transition');

          if (pan.scale === 1) {
            node.style.transform = `translate${ pan.axis }(${ pan.dir * 100 }%)`;

            timer = setTimeout(() => {
              emit(pan.showing, { reset });
              emit('action', { side: pan.showing, reset });
            }, 230);
          }
          else {
            node.style.transform = 'translate(0,0)';
            emitSlide(pan.showing, 0, true);
          }

          return
        }
        else {
          evt.direction = pan.axis === 'X'
            ? evt.offset.x < 0 ? 'left' : 'right'
            : evt.offset.y < 0 ? 'up' : 'down';
        }

        if (
          (slots.left === void 0 && evt.direction === langDir.value.right)
          || (slots.right === void 0 && evt.direction === langDir.value.left)
          || (slots.top === void 0 && evt.direction === 'down')
          || (slots.bottom === void 0 && evt.direction === 'up')
        ) {
          node.style.transform = 'translate(0,0)';
          return
        }

        let showing, dir, dist;

        if (pan.axis === 'X') {
          dir = evt.direction === 'left' ? -1 : 1;
          showing = dir === 1 ? langDir.value.left : langDir.value.right;
          dist = evt.distance.x;
        }
        else {
          dir = evt.direction === 'up' ? -2 : 2;
          showing = dir === 2 ? 'top' : 'bottom';
          dist = evt.distance.y;
        }

        if (pan.dir !== null && Math.abs(dir) !== Math.abs(pan.dir)) {
          return
        }

        if (pan.dir !== dir) {
          [ 'left', 'right', 'top', 'bottom' ].forEach(d => {
            if (dirRefs[ d ]) {
              dirRefs[ d ].style.visibility = showing === d
                ? 'visible'
                : 'hidden';
            }
          });
          pan.showing = showing;
          pan.dir = dir;
        }

        pan.scale = Math.max(0, Math.min(1, (dist - 40) / pan.size[ showing ]));

        node.style.transform = `translate${ pan.axis }(${ dist * dir / Math.abs(dir) }px)`;
        dirContentRefs[ showing ].style.transform = `scale(${ pan.scale })`;

        emitSlide(showing, pan.scale, false);
      }

      vue.onBeforeUpdate(() => {
        dirRefs = {};
        dirContentRefs = {};
      });

      vue.onBeforeUnmount(() => {
        clearTimeout(timer);
      });

      // expose public methods
      Object.assign(proxy, { reset });

      return () => {
        const
          content = [],
          slotsList = {
            left: slots[ langDir.value.right ] !== void 0,
            right: slots[ langDir.value.left ] !== void 0,
            up: slots.bottom !== void 0,
            down: slots.top !== void 0
          },
          dirs = Object.keys(slotsList).filter(key => slotsList[ key ] === true);

        slotsDef.forEach(slotName => {
          const dir = slotName[ 0 ];

          if (slots[ dir ] !== void 0) {
            content.push(
              vue.h('div', {
                ref: el => { dirRefs[ dir ] = el; },
                class: `q-slide-item__${ dir } absolute-full row no-wrap items-${ slotName[ 1 ] } justify-${ slotName[ 2 ] }`
                  + (props[ dir + 'Color' ] !== void 0 ? ` bg-${ props[ dir + 'Color' ] }` : '')
              }, [
                vue.h('div', { ref: el => { dirContentRefs[ dir ] = el; } }, slots[ dir ]())
              ])
            );
          }
        });

        const node = vue.h('div', {
          key: 'content',
          ref: contentRef,
          class: 'q-slide-item__content'
        }, hSlot(slots.default));

        content.push(
          vue.withDirectives(node, getCacheWithFn('dir#' + dirs.join(''), () => {
            const modifiers = {
              prevent: true,
              stop: true,
              mouse: true
            };

            dirs.forEach(dir => {
              modifiers[ dir ] = true;
            });

            return [ [
              TouchPan,
              onPan,
              void 0,
              modifiers
            ] ]
          }))
        );

        return vue.h('div', { class: classes.value }, content)
      }
    }
  });

  const space = vue.h('div', { class: 'q-space' });

  var QSpace = vue.defineComponent({
    name: 'QSpace',

    setup () {
      return () => space
    }
  });

  const svg$l = [
    vue.h('g', {
      transform: 'matrix(1 0 0 -1 0 80)'
    }, [
      vue.h('rect', {
        width: '10',
        height: '20',
        rx: '3'
      }, [
        vue.h('animate', {
          attributeName: 'height',
          begin: '0s',
          dur: '4.3s',
          values: '20;45;57;80;64;32;66;45;64;23;66;13;64;56;34;34;2;23;76;79;20',
          calcMode: 'linear',
          repeatCount: 'indefinite'
        })
      ]),
      vue.h('rect', {
        x: '15',
        width: '10',
        height: '80',
        rx: '3'
      }, [
        vue.h('animate', {
          attributeName: 'height',
          begin: '0s',
          dur: '2s',
          values: '80;55;33;5;75;23;73;33;12;14;60;80',
          calcMode: 'linear',
          repeatCount: 'indefinite'
        })
      ]),
      vue.h('rect', {
        x: '30',
        width: '10',
        height: '50',
        rx: '3'
      }, [
        vue.h('animate', {
          attributeName: 'height',
          begin: '0s',
          dur: '1.4s',
          values: '50;34;78;23;56;23;34;76;80;54;21;50',
          calcMode: 'linear',
          repeatCount: 'indefinite'
        })
      ]),
      vue.h('rect', {
        x: '45',
        width: '10',
        height: '30',
        rx: '3'
      }, [
        vue.h('animate', {
          attributeName: 'height',
          begin: '0s',
          dur: '2s',
          values: '30;45;13;80;56;72;45;76;34;23;67;30',
          calcMode: 'linear',
          repeatCount: 'indefinite'
        })
      ])
    ])
  ];

  var QSpinnerAudio = vue.defineComponent({
    name: 'QSpinnerAudio',

    props: useSpinnerProps,

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value,
        fill: 'currentColor',
        width: cSize.value,
        height: cSize.value,
        viewBox: '0 0 55 80',
        xmlns: 'http://www.w3.org/2000/svg'
      }, svg$l)
    }
  });

  const svg$k = [
    vue.h('g', {
      transform: 'translate(1 1)',
      'stroke-width': '2',
      fill: 'none',
      'fill-rule': 'evenodd'
    }, [
      vue.h('circle', {
        cx: '5',
        cy: '50',
        r: '5'
      }, [
        vue.h('animate', {
          attributeName: 'cy',
          begin: '0s',
          dur: '2.2s',
          values: '50;5;50;50',
          calcMode: 'linear',
          repeatCount: 'indefinite'
        }),
        vue.h('animate', {
          attributeName: 'cx',
          begin: '0s',
          dur: '2.2s',
          values: '5;27;49;5',
          calcMode: 'linear',
          repeatCount: 'indefinite'
        })
      ]),
      vue.h('circle', {
        cx: '27',
        cy: '5',
        r: '5'
      }, [
        vue.h('animate', {
          attributeName: 'cy',
          begin: '0s',
          dur: '2.2s',
          from: '5',
          to: '5',
          values: '5;50;50;5',
          calcMode: 'linear',
          repeatCount: 'indefinite'
        }),
        vue.h('animate', {
          attributeName: 'cx',
          begin: '0s',
          dur: '2.2s',
          from: '27',
          to: '27',
          values: '27;49;5;27',
          calcMode: 'linear',
          repeatCount: 'indefinite'
        })
      ]),
      vue.h('circle', {
        cx: '49',
        cy: '50',
        r: '5'
      }, [
        vue.h('animate', {
          attributeName: 'cy',
          begin: '0s',
          dur: '2.2s',
          values: '50;50;5;50',
          calcMode: 'linear',
          repeatCount: 'indefinite'
        }),
        vue.h('animate', {
          attributeName: 'cx',
          from: '49',
          to: '49',
          begin: '0s',
          dur: '2.2s',
          values: '49;5;27;49',
          calcMode: 'linear',
          repeatCount: 'indefinite'
        })
      ])
    ])
  ];

  var QSpinnerBall = vue.defineComponent({
    name: 'QSpinnerBall',

    props: useSpinnerProps,

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value,
        stroke: 'currentColor',
        width: cSize.value,
        height: cSize.value,
        viewBox: '0 0 57 57',
        xmlns: 'http://www.w3.org/2000/svg'
      }, svg$k)
    }
  });

  const svg$j = [
    vue.h('rect', {
      y: '10',
      width: '15',
      height: '120',
      rx: '6'
    }, [
      vue.h('animate', {
        attributeName: 'height',
        begin: '0.5s',
        dur: '1s',
        values: '120;110;100;90;80;70;60;50;40;140;120',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      }),
      vue.h('animate', {
        attributeName: 'y',
        begin: '0.5s',
        dur: '1s',
        values: '10;15;20;25;30;35;40;45;50;0;10',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      })
    ]),
    vue.h('rect', {
      x: '30',
      y: '10',
      width: '15',
      height: '120',
      rx: '6'
    }, [
      vue.h('animate', {
        attributeName: 'height',
        begin: '0.25s',
        dur: '1s',
        values: '120;110;100;90;80;70;60;50;40;140;120',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      }),
      vue.h('animate', {
        attributeName: 'y',
        begin: '0.25s',
        dur: '1s',
        values: '10;15;20;25;30;35;40;45;50;0;10',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      })
    ]),
    vue.h('rect', {
      x: '60',
      width: '15',
      height: '140',
      rx: '6'
    }, [
      vue.h('animate', {
        attributeName: 'height',
        begin: '0s',
        dur: '1s',
        values: '120;110;100;90;80;70;60;50;40;140;120',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      }),
      vue.h('animate', {
        attributeName: 'y',
        begin: '0s',
        dur: '1s',
        values: '10;15;20;25;30;35;40;45;50;0;10',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      })
    ]),
    vue.h('rect', {
      x: '90',
      y: '10',
      width: '15',
      height: '120',
      rx: '6'
    }, [
      vue.h('animate', {
        attributeName: 'height',
        begin: '0.25s',
        dur: '1s',
        values: '120;110;100;90;80;70;60;50;40;140;120',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      }),
      vue.h('animate', {
        attributeName: 'y',
        begin: '0.25s',
        dur: '1s',
        values: '10;15;20;25;30;35;40;45;50;0;10',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      })
    ]),
    vue.h('rect', {
      x: '120',
      y: '10',
      width: '15',
      height: '120',
      rx: '6'
    }, [
      vue.h('animate', {
        attributeName: 'height',
        begin: '0.5s',
        dur: '1s',
        values: '120;110;100;90;80;70;60;50;40;140;120',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      }),
      vue.h('animate', {
        attributeName: 'y',
        begin: '0.5s',
        dur: '1s',
        values: '10;15;20;25;30;35;40;45;50;0;10',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      })
    ])
  ];

  var QSpinnerBars = vue.defineComponent({
    name: 'QSpinnerBars',

    props: useSpinnerProps,

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value,
        fill: 'currentColor',
        width: cSize.value,
        height: cSize.value,
        viewBox: '0 0 135 140',
        xmlns: 'http://www.w3.org/2000/svg'
      }, svg$j)
    }
  });

  const svg$i = [
    vue.h('rect', {
      x: '25',
      y: '25',
      width: '50',
      height: '50',
      fill: 'none',
      'stroke-width': '4',
      stroke: 'currentColor'
    }, [
      vue.h('animateTransform', {
        id: 'spinnerBox',
        attributeName: 'transform',
        type: 'rotate',
        from: '0 50 50',
        to: '180 50 50',
        dur: '0.5s',
        begin: 'rectBox.end'
      })
    ]),
    vue.h('rect', {
      x: '27',
      y: '27',
      width: '46',
      height: '50',
      fill: 'currentColor'
    }, [
      vue.h('animate', {
        id: 'rectBox',
        attributeName: 'height',
        begin: '0s;spinnerBox.end',
        dur: '1.3s',
        from: '50',
        to: '0',
        fill: 'freeze'
      })
    ])
  ];

  var QSpinnerBox = vue.defineComponent({
    name: 'QSpinnerBox',

    props: useSpinnerProps,

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value,
        width: cSize.value,
        height: cSize.value,
        viewBox: '0 0 100 100',
        preserveAspectRatio: 'xMidYMid',
        xmlns: 'http://www.w3.org/2000/svg'
      }, svg$i)
    }
  });

  const svg$h = [
    vue.h('circle', {
      cx: '50',
      cy: '50',
      r: '48',
      fill: 'none',
      'stroke-width': '4',
      'stroke-miterlimit': '10',
      stroke: 'currentColor'
    }),
    vue.h('line', {
      'stroke-linecap': 'round',
      'stroke-width': '4',
      'stroke-miterlimit': '10',
      stroke: 'currentColor',
      x1: '50',
      y1: '50',
      x2: '85',
      y2: '50.5'
    }, [
      vue.h('animateTransform', {
        attributeName: 'transform',
        type: 'rotate',
        from: '0 50 50',
        to: '360 50 50',
        dur: '2s',
        repeatCount: 'indefinite'
      })
    ]),
    vue.h('line', {
      'stroke-linecap': 'round',
      'stroke-width': '4',
      'stroke-miterlimit': '10',
      stroke: 'currentColor',
      x1: '50',
      y1: '50',
      x2: '49.5',
      y2: '74'
    }, [
      vue.h('animateTransform', {
        attributeName: 'transform',
        type: 'rotate',
        from: '0 50 50',
        to: '360 50 50',
        dur: '15s',
        repeatCount: 'indefinite'
      })
    ])
  ];

  var QSpinnerClock = vue.defineComponent({
    name: 'QSpinnerClock',

    props: useSpinnerProps,

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value,
        width: cSize.value,
        height: cSize.value,
        viewBox: '0 0 100 100',
        preserveAspectRatio: 'xMidYMid',
        xmlns: 'http://www.w3.org/2000/svg'
      }, svg$h)
    }
  });

  const svg$g = [
    vue.h('rect', {
      x: '0',
      y: '0',
      width: ' 100',
      height: '100',
      fill: 'none'
    }),
    vue.h('path', {
      d: 'M78,19H22c-6.6,0-12,5.4-12,12v31c0,6.6,5.4,12,12,12h37.2c0.4,3,1.8,5.6,3.7,7.6c2.4,2.5,5.1,4.1,9.1,4 c-1.4-2.1-2-7.2-2-10.3c0-0.4,0-0.8,0-1.3h8c6.6,0,12-5.4,12-12V31C90,24.4,84.6,19,78,19z',
      fill: 'currentColor'
    }),
    vue.h('circle', {
      cx: '30',
      cy: '47',
      r: '5',
      fill: '#fff'
    }, [
      vue.h('animate', {
        attributeName: 'opacity',
        from: '0',
        to: '1',
        values: '0;1;1',
        keyTimes: '0;0.2;1',
        dur: '1s',
        repeatCount: 'indefinite'
      })
    ]),
    vue.h('circle', {
      cx: '50',
      cy: '47',
      r: '5',
      fill: '#fff'
    }, [
      vue.h('animate', {
        attributeName: 'opacity',
        from: '0',
        to: '1',
        values: '0;0;1;1',
        keyTimes: '0;0.2;0.4;1',
        dur: '1s',
        repeatCount: 'indefinite'
      })
    ]),
    vue.h('circle', {
      cx: '70',
      cy: '47',
      r: '5',
      fill: '#fff'
    }, [
      vue.h('animate', {
        attributeName: 'opacity',
        from: '0',
        to: '1',
        values: '0;0;1;1',
        keyTimes: '0;0.4;0.6;1',
        dur: '1s',
        repeatCount: 'indefinite'
      })
    ])
  ];

  var QSpinnerComment = vue.defineComponent({
    name: 'QSpinnerComment',

    props: useSpinnerProps,

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value,
        width: cSize.value,
        height: cSize.value,
        xmlns: 'http://www.w3.org/2000/svg',
        viewBox: '0 0 100 100',
        preserveAspectRatio: 'xMidYMid'
      }, svg$g)
    }
  });

  const svg$f = [
    vue.h('rect', {
      x: '0',
      y: '0',
      width: ' 100',
      height: '100',
      fill: 'none'
    }),
    vue.h('g', {
      transform: 'translate(25 25)'
    }, [
      vue.h('rect', {
        x: '-20',
        y: '-20',
        width: ' 40',
        height: '40',
        fill: 'currentColor',
        opacity: '0.9'
      }, [
        vue.h('animateTransform', {
          attributeName: 'transform',
          type: 'scale',
          from: '1.5',
          to: '1',
          repeatCount: 'indefinite',
          begin: '0s',
          dur: '1s',
          calcMode: 'spline',
          keySplines: '0.2 0.8 0.2 0.8',
          keyTimes: '0;1'
        })
      ])
    ]),
    vue.h('g', {
      transform: 'translate(75 25)'
    }, [
      vue.h('rect', {
        x: '-20',
        y: '-20',
        width: ' 40',
        height: '40',
        fill: 'currentColor',
        opacity: '0.8'
      }, [
        vue.h('animateTransform', {
          attributeName: 'transform',
          type: 'scale',
          from: '1.5',
          to: '1',
          repeatCount: 'indefinite',
          begin: '0.1s',
          dur: '1s',
          calcMode: 'spline',
          keySplines: '0.2 0.8 0.2 0.8',
          keyTimes: '0;1'
        })
      ])
    ]),
    vue.h('g', {
      transform: 'translate(25 75)'
    }, [
      vue.h('rect', {
        x: '-20',
        y: '-20',
        width: ' 40',
        height: '40',
        fill: 'currentColor',
        opacity: '0.7'
      }, [
        vue.h('animateTransform', {
          attributeName: 'transform',
          type: 'scale',
          from: '1.5',
          to: '1',
          repeatCount: 'indefinite',
          begin: '0.3s',
          dur: '1s',
          calcMode: 'spline',
          keySplines: '0.2 0.8 0.2 0.8',
          keyTimes: '0;1'
        })
      ])
    ]),
    vue.h('g', {
      transform: 'translate(75 75)'
    }, [
      vue.h('rect', {
        x: '-20',
        y: '-20',
        width: ' 40',
        height: '40',
        fill: 'currentColor',
        opacity: '0.6'
      }, [
        vue.h('animateTransform', {
          attributeName: 'transform',
          type: 'scale',
          from: '1.5',
          to: '1',
          repeatCount: 'indefinite',
          begin: '0.2s',
          dur: '1s',
          calcMode: 'spline',
          keySplines: '0.2 0.8 0.2 0.8',
          keyTimes: '0;1'
        })
      ])
    ])
  ];

  var QSpinnerCube = vue.defineComponent({
    name: 'QSpinnerCube',

    props: useSpinnerProps,

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value,
        width: cSize.value,
        height: cSize.value,
        xmlns: 'http://www.w3.org/2000/svg',
        viewBox: '0 0 100 100',
        preserveAspectRatio: 'xMidYMid'
      }, svg$f)
    }
  });

  const svg$e = [
    vue.h('circle', {
      cx: '15',
      cy: '15',
      r: '15'
    }, [
      vue.h('animate', {
        attributeName: 'r',
        from: '15',
        to: '15',
        begin: '0s',
        dur: '0.8s',
        values: '15;9;15',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      }),
      vue.h('animate', {
        attributeName: 'fill-opacity',
        from: '1',
        to: '1',
        begin: '0s',
        dur: '0.8s',
        values: '1;.5;1',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      })
    ]),
    vue.h('circle', {
      cx: '60',
      cy: '15',
      r: '9',
      'fill-opacity': '.3'
    }, [
      vue.h('animate', {
        attributeName: 'r',
        from: '9',
        to: '9',
        begin: '0s',
        dur: '0.8s',
        values: '9;15;9',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      }),
      vue.h('animate', {
        attributeName: 'fill-opacity',
        from: '.5',
        to: '.5',
        begin: '0s',
        dur: '0.8s',
        values: '.5;1;.5',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      })
    ]),
    vue.h('circle', {
      cx: '105',
      cy: '15',
      r: '15'
    }, [
      vue.h('animate', {
        attributeName: 'r',
        from: '15',
        to: '15',
        begin: '0s',
        dur: '0.8s',
        values: '15;9;15',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      }),
      vue.h('animate', {
        attributeName: 'fill-opacity',
        from: '1',
        to: '1',
        begin: '0s',
        dur: '0.8s',
        values: '1;.5;1',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      })
    ])
  ];

  var QSpinnerDots = vue.defineComponent({
    name: 'QSpinnerDots',

    props: useSpinnerProps,

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value,
        fill: 'currentColor',
        width: cSize.value,
        height: cSize.value,
        viewBox: '0 0 120 30',
        xmlns: 'http://www.w3.org/2000/svg'
      }, svg$e)
    }
  });

  const svg$d = [
    vue.h('g', {
      transform: 'translate(20 50)'
    }, [
      vue.h('rect', {
        x: '-10',
        y: '-30',
        width: ' 20',
        height: '60',
        fill: 'currentColor',
        opacity: '0.6'
      }, [
        vue.h('animateTransform', {
          attributeName: 'transform',
          type: 'scale',
          from: '2',
          to: '1',
          begin: '0s',
          repeatCount: 'indefinite',
          dur: '1s',
          calcMode: 'spline',
          keySplines: '0.1 0.9 0.4 1',
          keyTimes: '0;1',
          values: '2;1'
        })
      ])
    ]),
    vue.h('g', {
      transform: 'translate(50 50)'
    }, [
      vue.h('rect', {
        x: '-10',
        y: '-30',
        width: ' 20',
        height: '60',
        fill: 'currentColor',
        opacity: '0.8'
      }, [
        vue.h('animateTransform', {
          attributeName: 'transform',
          type: 'scale',
          from: '2',
          to: '1',
          begin: '0.1s',
          repeatCount: 'indefinite',
          dur: '1s',
          calcMode: 'spline',
          keySplines: '0.1 0.9 0.4 1',
          keyTimes: '0;1',
          values: '2;1'
        })
      ])
    ]),
    vue.h('g', {
      transform: 'translate(80 50)'
    }, [
      vue.h('rect', {
        x: '-10',
        y: '-30',
        width: ' 20',
        height: '60',
        fill: 'currentColor',
        opacity: '0.9'
      }, [
        vue.h('animateTransform', {
          attributeName: 'transform',
          type: 'scale',
          from: '2',
          to: '1',
          begin: '0.2s',
          repeatCount: 'indefinite',
          dur: '1s',
          calcMode: 'spline',
          keySplines: '0.1 0.9 0.4 1',
          keyTimes: '0;1',
          values: '2;1'
        })
      ])
    ])
  ];

  var QSpinnerFacebook = vue.defineComponent({
    name: 'QSpinnerFacebook',

    props: useSpinnerProps,

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value,
        width: cSize.value,
        height: cSize.value,
        viewBox: '0 0 100 100',
        xmlns: 'http://www.w3.org/2000/svg',
        preserveAspectRatio: 'xMidYMid'
      }, svg$d)
    }
  });

  const svg$c = [
    vue.h('g', {
      transform: 'translate(-20,-20)'
    }, [
      vue.h('path', {
        d: 'M79.9,52.6C80,51.8,80,50.9,80,50s0-1.8-0.1-2.6l-5.1-0.4c-0.3-2.4-0.9-4.6-1.8-6.7l4.2-2.9c-0.7-1.6-1.6-3.1-2.6-4.5 L70,35c-1.4-1.9-3.1-3.5-4.9-4.9l2.2-4.6c-1.4-1-2.9-1.9-4.5-2.6L59.8,27c-2.1-0.9-4.4-1.5-6.7-1.8l-0.4-5.1C51.8,20,50.9,20,50,20 s-1.8,0-2.6,0.1l-0.4,5.1c-2.4,0.3-4.6,0.9-6.7,1.8l-2.9-4.1c-1.6,0.7-3.1,1.6-4.5,2.6l2.1,4.6c-1.9,1.4-3.5,3.1-5,4.9l-4.5-2.1 c-1,1.4-1.9,2.9-2.6,4.5l4.1,2.9c-0.9,2.1-1.5,4.4-1.8,6.8l-5,0.4C20,48.2,20,49.1,20,50s0,1.8,0.1,2.6l5,0.4 c0.3,2.4,0.9,4.7,1.8,6.8l-4.1,2.9c0.7,1.6,1.6,3.1,2.6,4.5l4.5-2.1c1.4,1.9,3.1,3.5,5,4.9l-2.1,4.6c1.4,1,2.9,1.9,4.5,2.6l2.9-4.1 c2.1,0.9,4.4,1.5,6.7,1.8l0.4,5.1C48.2,80,49.1,80,50,80s1.8,0,2.6-0.1l0.4-5.1c2.3-0.3,4.6-0.9,6.7-1.8l2.9,4.2 c1.6-0.7,3.1-1.6,4.5-2.6L65,69.9c1.9-1.4,3.5-3,4.9-4.9l4.6,2.2c1-1.4,1.9-2.9,2.6-4.5L73,59.8c0.9-2.1,1.5-4.4,1.8-6.7L79.9,52.6 z M50,65c-8.3,0-15-6.7-15-15c0-8.3,6.7-15,15-15s15,6.7,15,15C65,58.3,58.3,65,50,65z',
        fill: 'currentColor'
      }, [
        vue.h('animateTransform', {
          attributeName: 'transform',
          type: 'rotate',
          from: '90 50 50',
          to: '0 50 50',
          dur: '1s',
          repeatCount: 'indefinite'
        })
      ])
    ]),
    vue.h('g', {
      transform: 'translate(20,20) rotate(15 50 50)'
    }, [
      vue.h('path', {
        d: 'M79.9,52.6C80,51.8,80,50.9,80,50s0-1.8-0.1-2.6l-5.1-0.4c-0.3-2.4-0.9-4.6-1.8-6.7l4.2-2.9c-0.7-1.6-1.6-3.1-2.6-4.5 L70,35c-1.4-1.9-3.1-3.5-4.9-4.9l2.2-4.6c-1.4-1-2.9-1.9-4.5-2.6L59.8,27c-2.1-0.9-4.4-1.5-6.7-1.8l-0.4-5.1C51.8,20,50.9,20,50,20 s-1.8,0-2.6,0.1l-0.4,5.1c-2.4,0.3-4.6,0.9-6.7,1.8l-2.9-4.1c-1.6,0.7-3.1,1.6-4.5,2.6l2.1,4.6c-1.9,1.4-3.5,3.1-5,4.9l-4.5-2.1 c-1,1.4-1.9,2.9-2.6,4.5l4.1,2.9c-0.9,2.1-1.5,4.4-1.8,6.8l-5,0.4C20,48.2,20,49.1,20,50s0,1.8,0.1,2.6l5,0.4 c0.3,2.4,0.9,4.7,1.8,6.8l-4.1,2.9c0.7,1.6,1.6,3.1,2.6,4.5l4.5-2.1c1.4,1.9,3.1,3.5,5,4.9l-2.1,4.6c1.4,1,2.9,1.9,4.5,2.6l2.9-4.1 c2.1,0.9,4.4,1.5,6.7,1.8l0.4,5.1C48.2,80,49.1,80,50,80s1.8,0,2.6-0.1l0.4-5.1c2.3-0.3,4.6-0.9,6.7-1.8l2.9,4.2 c1.6-0.7,3.1-1.6,4.5-2.6L65,69.9c1.9-1.4,3.5-3,4.9-4.9l4.6,2.2c1-1.4,1.9-2.9,2.6-4.5L73,59.8c0.9-2.1,1.5-4.4,1.8-6.7L79.9,52.6 z M50,65c-8.3,0-15-6.7-15-15c0-8.3,6.7-15,15-15s15,6.7,15,15C65,58.3,58.3,65,50,65z',
        fill: 'currentColor'
      }, [
        vue.h('animateTransform', {
          attributeName: 'transform',
          type: 'rotate',
          from: '0 50 50',
          to: '90 50 50',
          dur: '1s',
          repeatCount: 'indefinite'
        })
      ])
    ])
  ];

  var QSpinnerGears = vue.defineComponent({
    name: 'QSpinnerGears',

    props: useSpinnerProps,

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value,
        width: cSize.value,
        height: cSize.value,
        viewBox: '0 0 100 100',
        preserveAspectRatio: 'xMidYMid',
        xmlns: 'http://www.w3.org/2000/svg'
      }, svg$c)
    }
  });

  const svg$b = [
    vue.h('circle', {
      cx: '12.5',
      cy: '12.5',
      r: '12.5'
    }, [
      vue.h('animate', {
        attributeName: 'fill-opacity',
        begin: '0s',
        dur: '1s',
        values: '1;.2;1',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      })
    ]),
    vue.h('circle', {
      cx: '12.5',
      cy: '52.5',
      r: '12.5',
      'fill-opacity': '.5'
    }, [
      vue.h('animate', {
        attributeName: 'fill-opacity',
        begin: '100ms',
        dur: '1s',
        values: '1;.2;1',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      })
    ]),
    vue.h('circle', {
      cx: '52.5',
      cy: '12.5',
      r: '12.5'
    }, [
      vue.h('animate', {
        attributeName: 'fill-opacity',
        begin: '300ms',
        dur: '1s',
        values: '1;.2;1',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      })
    ]),
    vue.h('circle', {
      cx: '52.5',
      cy: '52.5',
      r: '12.5'
    }, [
      vue.h('animate', {
        attributeName: 'fill-opacity',
        begin: '600ms',
        dur: '1s',
        values: '1;.2;1',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      })
    ]),
    vue.h('circle', {
      cx: '92.5',
      cy: '12.5',
      r: '12.5'
    }, [
      vue.h('animate', {
        attributeName: 'fill-opacity',
        begin: '800ms',
        dur: '1s',
        values: '1;.2;1',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      })
    ]),
    vue.h('circle', {
      cx: '92.5',
      cy: '52.5',
      r: '12.5'
    }, [
      vue.h('animate', {
        attributeName: 'fill-opacity',
        begin: '400ms',
        dur: '1s',
        values: '1;.2;1',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      })
    ]),
    vue.h('circle', {
      cx: '12.5',
      cy: '92.5',
      r: '12.5'
    }, [
      vue.h('animate', {
        attributeName: 'fill-opacity',
        begin: '700ms',
        dur: '1s',
        values: '1;.2;1',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      })
    ]),
    vue.h('circle', {
      cx: '52.5',
      cy: '92.5',
      r: '12.5'
    }, [
      vue.h('animate', {
        attributeName: 'fill-opacity',
        begin: '500ms',
        dur: '1s',
        values: '1;.2;1',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      })
    ]),
    vue.h('circle', {
      cx: '92.5',
      cy: '92.5',
      r: '12.5'
    }, [
      vue.h('animate', {
        attributeName: 'fill-opacity',
        begin: '200ms',
        dur: '1s',
        values: '1;.2;1',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      })
    ])
  ];

  var QSpinnerGrid = vue.defineComponent({
    name: 'QSpinnerGrid',

    props: useSpinnerProps,

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value,
        fill: 'currentColor',
        width: cSize.value,
        height: cSize.value,
        viewBox: '0 0 105 105',
        xmlns: 'http://www.w3.org/2000/svg'
      }, svg$b)
    }
  });

  const svg$a = [
    vue.h('path', {
      d: 'M30.262 57.02L7.195 40.723c-5.84-3.976-7.56-12.06-3.842-18.063 3.715-6 11.467-7.65 17.306-3.68l4.52 3.76 2.6-5.274c3.716-6.002 11.47-7.65 17.304-3.68 5.84 3.97 7.56 12.054 3.842 18.062L34.49 56.118c-.897 1.512-2.793 1.915-4.228.9z',
      'fill-opacity': '.5'
    }, [
      vue.h('animate', {
        attributeName: 'fill-opacity',
        begin: '0s',
        dur: '1.4s',
        values: '0.5;1;0.5',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      })
    ]),
    vue.h('path', {
      d: 'M105.512 56.12l-14.44-24.272c-3.716-6.008-1.996-14.093 3.843-18.062 5.835-3.97 13.588-2.322 17.306 3.68l2.6 5.274 4.52-3.76c5.84-3.97 13.593-2.32 17.308 3.68 3.718 6.003 1.998 14.088-3.842 18.064L109.74 57.02c-1.434 1.014-3.33.61-4.228-.9z',
      'fill-opacity': '.5'
    }, [
      vue.h('animate', {
        attributeName: 'fill-opacity',
        begin: '0.7s',
        dur: '1.4s',
        values: '0.5;1;0.5',
        calcMode: 'linear',
        repeatCount: 'indefinite'
      })
    ]),
    vue.h('path', {
      d: 'M67.408 57.834l-23.01-24.98c-5.864-6.15-5.864-16.108 0-22.248 5.86-6.14 15.37-6.14 21.234 0L70 16.168l4.368-5.562c5.863-6.14 15.375-6.14 21.235 0 5.863 6.14 5.863 16.098 0 22.247l-23.007 24.98c-1.43 1.556-3.757 1.556-5.188 0z'
    })
  ];

  var QSpinnerHearts = vue.defineComponent({
    name: 'QSpinnerHearts',

    props: useSpinnerProps,

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value,
        fill: 'currentColor',
        width: cSize.value,
        height: cSize.value,
        viewBox: '0 0 140 64',
        xmlns: 'http://www.w3.org/2000/svg'
      }, svg$a)
    }
  });

  const svg$9 = [
    vue.h('g', [
      vue.h('path', {
        fill: 'none',
        stroke: 'currentColor',
        'stroke-width': '5',
        'stroke-miterlimit': '10',
        d: 'M58.4,51.7c-0.9-0.9-1.4-2-1.4-2.3s0.5-0.4,1.4-1.4 C70.8,43.8,79.8,30.5,80,15.5H70H30H20c0.2,15,9.2,28.1,21.6,32.3c0.9,0.9,1.4,1.2,1.4,1.5s-0.5,1.6-1.4,2.5 C29.2,56.1,20.2,69.5,20,85.5h10h40h10C79.8,69.5,70.8,55.9,58.4,51.7z'
      }),
      vue.h('clipPath', {
        id: 'uil-hourglass-clip1'
      }, [
        vue.h('rect', {
          x: '15',
          y: '20',
          width: ' 70',
          height: '25'
        }, [
          vue.h('animate', {
            attributeName: 'height',
            from: '25',
            to: '0',
            dur: '1s',
            repeatCount: 'indefinite',
            values: '25;0;0',
            keyTimes: '0;0.5;1'
          }),
          vue.h('animate', {
            attributeName: 'y',
            from: '20',
            to: '45',
            dur: '1s',
            repeatCount: 'indefinite',
            values: '20;45;45',
            keyTimes: '0;0.5;1'
          })
        ])
      ]),
      vue.h('clipPath', {
        id: 'uil-hourglass-clip2'
      }, [
        vue.h('rect', {
          x: '15',
          y: '55',
          width: ' 70',
          height: '25'
        }, [
          vue.h('animate', {
            attributeName: 'height',
            from: '0',
            to: '25',
            dur: '1s',
            repeatCount: 'indefinite',
            values: '0;25;25',
            keyTimes: '0;0.5;1'
          }),
          vue.h('animate', {
            attributeName: 'y',
            from: '80',
            to: '55',
            dur: '1s',
            repeatCount: 'indefinite',
            values: '80;55;55',
            keyTimes: '0;0.5;1'
          })
        ])
      ]),
      vue.h('path', {
        d: 'M29,23c3.1,11.4,11.3,19.5,21,19.5S67.9,34.4,71,23H29z',
        'clip-path': 'url(#uil-hourglass-clip1)',
        fill: 'currentColor'
      }),
      vue.h('path', {
        d: 'M71.6,78c-3-11.6-11.5-20-21.5-20s-18.5,8.4-21.5,20H71.6z',
        'clip-path': 'url(#uil-hourglass-clip2)',
        fill: 'currentColor'
      }),
      vue.h('animateTransform', {
        attributeName: 'transform',
        type: 'rotate',
        from: '0 50 50',
        to: '180 50 50',
        repeatCount: 'indefinite',
        dur: '1s',
        values: '0 50 50;0 50 50;180 50 50',
        keyTimes: '0;0.7;1'
      })
    ])
  ];

  var QSpinnerHourglass = vue.defineComponent({
    name: 'QSpinnerHourglass',

    props: useSpinnerProps,

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value,
        width: cSize.value,
        height: cSize.value,
        viewBox: '0 0 100 100',
        preserveAspectRatio: 'xMidYMid',
        xmlns: 'http://www.w3.org/2000/svg'
      }, svg$9)
    }
  });

  const svg$8 = [
    vue.h('path', {
      d: 'M24.3,30C11.4,30,5,43.3,5,50s6.4,20,19.3,20c19.3,0,32.1-40,51.4-40C88.6,30,95,43.3,95,50s-6.4,20-19.3,20C56.4,70,43.6,30,24.3,30z',
      fill: 'none',
      stroke: 'currentColor',
      'stroke-width': '8',
      'stroke-dasharray': '10.691205342610678 10.691205342610678',
      'stroke-dashoffset': '0'
    }, [
      vue.h('animate', {
        attributeName: 'stroke-dashoffset',
        from: '0',
        to: '21.382410685221355',
        begin: '0',
        dur: '2s',
        repeatCount: 'indefinite',
        fill: 'freeze'
      })
    ])
  ];

  var QSpinnerInfinity = vue.defineComponent({
    name: 'QSpinnerInfinity',

    props: useSpinnerProps,

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value,
        width: cSize.value,
        height: cSize.value,
        viewBox: '0 0 100 100',
        preserveAspectRatio: 'xMidYMid'
      }, svg$8)
    }
  });

  const svg$7 = [
    vue.h('g', {
      'stroke-width': '4',
      'stroke-linecap': 'round'
    }, [
      vue.h('line', {
        y1: '17',
        y2: '29',
        transform: 'translate(32,32) rotate(180)'
      }, [
        vue.h('animate', {
          attributeName: 'stroke-opacity',
          dur: '750ms',
          values: '1;.85;.7;.65;.55;.45;.35;.25;.15;.1;0;1',
          repeatCount: 'indefinite'
        })
      ]),
      vue.h('line', {
        y1: '17',
        y2: '29',
        transform: 'translate(32,32) rotate(210)'
      }, [
        vue.h('animate', {
          attributeName: 'stroke-opacity',
          dur: '750ms',
          values: '0;1;.85;.7;.65;.55;.45;.35;.25;.15;.1;0',
          repeatCount: 'indefinite'
        })
      ]),
      vue.h('line', {
        y1: '17',
        y2: '29',
        transform: 'translate(32,32) rotate(240)'
      }, [
        vue.h('animate', {
          attributeName: 'stroke-opacity',
          dur: '750ms',
          values: '.1;0;1;.85;.7;.65;.55;.45;.35;.25;.15;.1',
          repeatCount: 'indefinite'
        })
      ]),
      vue.h('line', {
        y1: '17',
        y2: '29',
        transform: 'translate(32,32) rotate(270)'
      }, [
        vue.h('animate', {
          attributeName: 'stroke-opacity',
          dur: '750ms',
          values: '.15;.1;0;1;.85;.7;.65;.55;.45;.35;.25;.15',
          repeatCount: 'indefinite'
        })
      ]),
      vue.h('line', {
        y1: '17',
        y2: '29',
        transform: 'translate(32,32) rotate(300)'
      }, [
        vue.h('animate', {
          attributeName: 'stroke-opacity',
          dur: '750ms',
          values: '.25;.15;.1;0;1;.85;.7;.65;.55;.45;.35;.25',
          repeatCount: 'indefinite'
        })
      ]),
      vue.h('line', {
        y1: '17',
        y2: '29',
        transform: 'translate(32,32) rotate(330)'
      }, [
        vue.h('animate', {
          attributeName: 'stroke-opacity',
          dur: '750ms',
          values: '.35;.25;.15;.1;0;1;.85;.7;.65;.55;.45;.35',
          repeatCount: 'indefinite'
        })
      ]),
      vue.h('line', {
        y1: '17',
        y2: '29',
        transform: 'translate(32,32) rotate(0)'
      }, [
        vue.h('animate', {
          attributeName: 'stroke-opacity',
          dur: '750ms',
          values: '.45;.35;.25;.15;.1;0;1;.85;.7;.65;.55;.45',
          repeatCount: 'indefinite'
        })
      ]),
      vue.h('line', {
        y1: '17',
        y2: '29',
        transform: 'translate(32,32) rotate(30)'
      }, [
        vue.h('animate', {
          attributeName: 'stroke-opacity',
          dur: '750ms',
          values: '.55;.45;.35;.25;.15;.1;0;1;.85;.7;.65;.55',
          repeatCount: 'indefinite'
        })
      ]),
      vue.h('line', {
        y1: '17',
        y2: '29',
        transform: 'translate(32,32) rotate(60)'
      }, [
        vue.h('animate', {
          attributeName: 'stroke-opacity',
          dur: '750ms',
          values: '.65;.55;.45;.35;.25;.15;.1;0;1;.85;.7;.65',
          repeatCount: 'indefinite'
        })
      ]),
      vue.h('line', {
        y1: '17',
        y2: '29',
        transform: 'translate(32,32) rotate(90)'
      }, [
        vue.h('animate', {
          attributeName: 'stroke-opacity',
          dur: '750ms',
          values: '.7;.65;.55;.45;.35;.25;.15;.1;0;1;.85;.7',
          repeatCount: 'indefinite'
        })
      ]),
      vue.h('line', {
        y1: '17',
        y2: '29',
        transform: 'translate(32,32) rotate(120)'
      }, [
        vue.h('animate', {
          attributeName: 'stroke-opacity',
          dur: '750ms',
          values: '.85;.7;.65;.55;.45;.35;.25;.15;.1;0;1;.85',
          repeatCount: 'indefinite'
        })
      ]),
      vue.h('line', {
        y1: '17',
        y2: '29',
        transform: 'translate(32,32) rotate(150)'
      }, [
        vue.h('animate', {
          attributeName: 'stroke-opacity',
          dur: '750ms',
          values: '1;.85;.7;.65;.55;.45;.35;.25;.15;.1;0;1',
          repeatCount: 'indefinite'
        })
      ])
    ])
  ];

  var QSpinnerIos = vue.defineComponent({
    name: 'QSpinnerIos',

    props: useSpinnerProps,

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value,
        width: cSize.value,
        height: cSize.value,
        stroke: 'currentColor',
        fill: 'currentColor',
        viewBox: '0 0 64 64'
      }, svg$7)
    }
  });

  const svg$6 = [
    vue.h('circle', {
      cx: '50',
      cy: '50',
      r: '44',
      fill: 'none',
      'stroke-width': '4',
      'stroke-opacity': '.5',
      stroke: 'currentColor'
    }),
    vue.h('circle', {
      cx: '8',
      cy: '54',
      r: '6',
      fill: 'currentColor',
      'stroke-width': '3',
      stroke: 'currentColor'
    }, [
      vue.h('animateTransform', {
        attributeName: 'transform',
        type: 'rotate',
        from: '0 50 48',
        to: '360 50 52',
        dur: '2s',
        repeatCount: 'indefinite'
      })
    ])
  ];

  var QSpinnerOrbit = vue.defineComponent({
    name: 'QSpinnerOrbit',

    props: useSpinnerProps,

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value,
        width: cSize.value,
        height: cSize.value,
        viewBox: '0 0 100 100',
        preserveAspectRatio: 'xMidYMid',
        xmlns: 'http://www.w3.org/2000/svg'
      }, svg$6)
    }
  });

  const svg$5 = [
    vue.h('g', {
      transform: 'translate(1 1)',
      'stroke-width': '2',
      fill: 'none',
      'fill-rule': 'evenodd'
    }, [
      vue.h('circle', {
        'stroke-opacity': '.5',
        cx: '18',
        cy: '18',
        r: '18'
      }),
      vue.h('path', {
        d: 'M36 18c0-9.94-8.06-18-18-18'
      }, [
        vue.h('animateTransform', {
          attributeName: 'transform',
          type: 'rotate',
          from: '0 18 18',
          to: '360 18 18',
          dur: '1s',
          repeatCount: 'indefinite'
        })
      ])
    ])
  ];

  var QSpinnerOval = vue.defineComponent({
    name: 'QSpinnerOval',

    props: useSpinnerProps,

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value,
        stroke: 'currentColor',
        width: cSize.value,
        height: cSize.value,
        viewBox: '0 0 38 38',
        xmlns: 'http://www.w3.org/2000/svg'
      }, svg$5)
    }
  });

  const svg$4 = [
    vue.h('path', {
      d: 'M0 50A50 50 0 0 1 50 0L50 50L0 50',
      fill: 'currentColor',
      opacity: '0.5'
    }, [
      vue.h('animateTransform', {
        attributeName: 'transform',
        type: 'rotate',
        from: '0 50 50',
        to: '360 50 50',
        dur: '0.8s',
        repeatCount: 'indefinite'
      })
    ]),
    vue.h('path', {
      d: 'M50 0A50 50 0 0 1 100 50L50 50L50 0',
      fill: 'currentColor',
      opacity: '0.5'
    }, [
      vue.h('animateTransform', {
        attributeName: 'transform',
        type: 'rotate',
        from: '0 50 50',
        to: '360 50 50',
        dur: '1.6s',
        repeatCount: 'indefinite'
      })
    ]),
    vue.h('path', {
      d: 'M100 50A50 50 0 0 1 50 100L50 50L100 50',
      fill: 'currentColor',
      opacity: '0.5'
    }, [
      vue.h('animateTransform', {
        attributeName: 'transform',
        type: 'rotate',
        from: '0 50 50',
        to: '360 50 50',
        dur: '2.4s',
        repeatCount: 'indefinite'
      })
    ]),
    vue.h('path', {
      d: 'M50 100A50 50 0 0 1 0 50L50 50L50 100',
      fill: 'currentColor',
      opacity: '0.5'
    }, [
      vue.h('animateTransform', {
        attributeName: 'transform',
        type: 'rotate',
        from: '0 50 50',
        to: '360 50 50',
        dur: '3.2s',
        repeatCount: 'indefinite'
      })
    ])
  ];

  var QSpinnerPie = vue.defineComponent({
    name: 'QSpinnerPie',

    props: useSpinnerProps,

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value,
        width: cSize.value,
        height: cSize.value,
        viewBox: '0 0 100 100',
        preserveAspectRatio: 'xMidYMid',
        xmlns: 'http://www.w3.org/2000/svg'
      }, svg$4)
    }
  });

  const svg$3 = [
    vue.h('g', {
      fill: 'none',
      'fill-rule': 'evenodd',
      'stroke-width': '2'
    }, [
      vue.h('circle', {
        cx: '22',
        cy: '22',
        r: '1'
      }, [
        vue.h('animate', {
          attributeName: 'r',
          begin: '0s',
          dur: '1.8s',
          values: '1; 20',
          calcMode: 'spline',
          keyTimes: '0; 1',
          keySplines: '0.165, 0.84, 0.44, 1',
          repeatCount: 'indefinite'
        }),
        vue.h('animate', {
          attributeName: 'stroke-opacity',
          begin: '0s',
          dur: '1.8s',
          values: '1; 0',
          calcMode: 'spline',
          keyTimes: '0; 1',
          keySplines: '0.3, 0.61, 0.355, 1',
          repeatCount: 'indefinite'
        })
      ]),
      vue.h('circle', {
        cx: '22',
        cy: '22',
        r: '1'
      }, [
        vue.h('animate', {
          attributeName: 'r',
          begin: '-0.9s',
          dur: '1.8s',
          values: '1; 20',
          calcMode: 'spline',
          keyTimes: '0; 1',
          keySplines: '0.165, 0.84, 0.44, 1',
          repeatCount: 'indefinite'
        }),
        vue.h('animate', {
          attributeName: 'stroke-opacity',
          begin: '-0.9s',
          dur: '1.8s',
          values: '1; 0',
          calcMode: 'spline',
          keyTimes: '0; 1',
          keySplines: '0.3, 0.61, 0.355, 1',
          repeatCount: 'indefinite'
        })
      ])
    ])
  ];

  var QSpinnerPuff = vue.defineComponent({
    name: 'QSpinnerPuff',

    props: useSpinnerProps,

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value,
        stroke: 'currentColor',
        width: cSize.value,
        height: cSize.value,
        viewBox: '0 0 44 44',
        xmlns: 'http://www.w3.org/2000/svg'
      }, svg$3)
    }
  });

  const svg$2 = [
    vue.h('g', {
      transform: 'scale(0.55)'
    }, [
      vue.h('circle', {
        cx: '30',
        cy: '150',
        r: '30',
        fill: 'currentColor'
      }, [
        vue.h('animate', {
          attributeName: 'opacity',
          from: '0',
          to: '1',
          dur: '1s',
          begin: '0',
          repeatCount: 'indefinite',
          keyTimes: '0;0.5;1',
          values: '0;1;1'
        })
      ]),
      vue.h('path', {
        d: 'M90,150h30c0-49.7-40.3-90-90-90v30C63.1,90,90,116.9,90,150z',
        fill: 'currentColor'
      }, [
        vue.h('animate', {
          attributeName: 'opacity',
          from: '0',
          to: '1',
          dur: '1s',
          begin: '0.1',
          repeatCount: 'indefinite',
          keyTimes: '0;0.5;1',
          values: '0;1;1'
        })
      ]),
      vue.h('path', {
        d: 'M150,150h30C180,67.2,112.8,0,30,0v30C96.3,30,150,83.7,150,150z',
        fill: 'currentColor'
      }, [
        vue.h('animate', {
          attributeName: 'opacity',
          from: '0',
          to: '1',
          dur: '1s',
          begin: '0.2',
          repeatCount: 'indefinite',
          keyTimes: '0;0.5;1',
          values: '0;1;1'
        })
      ])
    ])
  ];

  var QSpinnerRadio = vue.defineComponent({
    name: 'QSpinnerRadio',

    props: useSpinnerProps,

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value,
        width: cSize.value,
        height: cSize.value,
        viewBox: '0 0 100 100',
        preserveAspectRatio: 'xMidYMid',
        xmlns: 'http://www.w3.org/2000/svg'
      }, svg$2)
    }
  });

  const svg$1 = [
    vue.h('g', {
      fill: 'none',
      'fill-rule': 'evenodd',
      transform: 'translate(1 1)',
      'stroke-width': '2'
    }, [
      vue.h('circle', {
        cx: '22',
        cy: '22',
        r: '6'
      }, [
        vue.h('animate', {
          attributeName: 'r',
          begin: '1.5s',
          dur: '3s',
          values: '6;22',
          calcMode: 'linear',
          repeatCount: 'indefinite'
        }),
        vue.h('animate', {
          attributeName: 'stroke-opacity',
          begin: '1.5s',
          dur: '3s',
          values: '1;0',
          calcMode: 'linear',
          repeatCount: 'indefinite'
        }),
        vue.h('animate', {
          attributeName: 'stroke-width',
          begin: '1.5s',
          dur: '3s',
          values: '2;0',
          calcMode: 'linear',
          repeatCount: 'indefinite'
        })
      ]),
      vue.h('circle', {
        cx: '22',
        cy: '22',
        r: '6'
      }, [
        vue.h('animate', {
          attributeName: 'r',
          begin: '3s',
          dur: '3s',
          values: '6;22',
          calcMode: 'linear',
          repeatCount: 'indefinite'
        }),
        vue.h('animate', {
          attributeName: 'stroke-opacity',
          begin: '3s',
          dur: '3s',
          values: '1;0',
          calcMode: 'linear',
          repeatCount: 'indefinite'
        }),
        vue.h('animate', {
          attributeName: 'stroke-width',
          begin: '3s',
          dur: '3s',
          values: '2;0',
          calcMode: 'linear',
          repeatCount: 'indefinite'
        })
      ]),
      vue.h('circle', {
        cx: '22',
        cy: '22',
        r: '8'
      }, [
        vue.h('animate', {
          attributeName: 'r',
          begin: '0s',
          dur: '1.5s',
          values: '6;1;2;3;4;5;6',
          calcMode: 'linear',
          repeatCount: 'indefinite'
        })
      ])
    ])
  ];

  var QSpinnerRings = vue.defineComponent({
    name: 'QSpinnerRings',

    props: useSpinnerProps,

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value,
        stroke: 'currentColor',
        width: cSize.value,
        height: cSize.value,
        viewBox: '0 0 45 45',
        xmlns: 'http://www.w3.org/2000/svg'
      }, svg$1)
    }
  });

  const svg = [
    vue.h('defs', [
      vue.h('linearGradient', {
        x1: '8.042%',
        y1: '0%',
        x2: '65.682%',
        y2: '23.865%',
        id: 'a'
      }, [
        vue.h('stop', {
          'stop-color': 'currentColor',
          'stop-opacity': '0',
          offset: '0%'
        }),
        vue.h('stop', {
          'stop-color': 'currentColor',
          'stop-opacity': '.631',
          offset: '63.146%'
        }),
        vue.h('stop', {
          'stop-color': 'currentColor',
          offset: '100%'
        })
      ])
    ]),
    vue.h('g', {
      transform: 'translate(1 1)',
      fill: 'none',
      'fill-rule': 'evenodd'
    }, [
      vue.h('path', {
        d: 'M36 18c0-9.94-8.06-18-18-18',
        stroke: 'url(#a)',
        'stroke-width': '2'
      }, [
        vue.h('animateTransform', {
          attributeName: 'transform',
          type: 'rotate',
          from: '0 18 18',
          to: '360 18 18',
          dur: '0.9s',
          repeatCount: 'indefinite'
        })
      ]),
      vue.h('circle', {
        fill: 'currentColor',
        cx: '36',
        cy: '18',
        r: '1'
      }, [
        vue.h('animateTransform', {
          attributeName: 'transform',
          type: 'rotate',
          from: '0 18 18',
          to: '360 18 18',
          dur: '0.9s',
          repeatCount: 'indefinite'
        })
      ])
    ])
  ];

  var QSpinnerTail = vue.defineComponent({
    name: 'QSpinnerTail',

    props: useSpinnerProps,

    setup (props) {
      const { cSize, classes } = useSpinner(props);

      return () => vue.h('svg', {
        class: classes.value,
        width: cSize.value,
        height: cSize.value,
        viewBox: '0 0 38 38',
        xmlns: 'http://www.w3.org/2000/svg'
      }, svg)
    }
  });

  var QSplitter = vue.defineComponent({
    name: 'QSplitter',

    props: {
      ...useDarkProps,

      modelValue: {
        type: Number,
        required: true
      },
      reverse: Boolean,
      unit: {
        type: String,
        default: '%',
        validator: v => [ '%', 'px' ].includes(v)
      },

      limits: {
        type: Array,
        validator: v => {
          if (v.length !== 2) return false
          if (typeof v[ 0 ] !== 'number' || typeof v[ 1 ] !== 'number') return false
          return v[ 0 ] >= 0 && v[ 0 ] <= v[ 1 ]
        }
      },

      emitImmediately: Boolean,

      horizontal: Boolean,
      disable: Boolean,

      beforeClass: [ Array, String, Object ],
      afterClass: [ Array, String, Object ],

      separatorClass: [ Array, String, Object ],
      separatorStyle: [ Array, String, Object ]
    },

    emits: [ 'update:modelValue' ],

    setup (props, { slots, emit }) {
      const { proxy: { $q } } = vue.getCurrentInstance();
      const isDark = useDark(props, $q);

      const rootRef = vue.ref(null);
      const sideRefs = {
        before: vue.ref(null),
        after: vue.ref(null)
      };

      const classes = vue.computed(() =>
        'q-splitter no-wrap '
        + `${ props.horizontal === true ? 'q-splitter--horizontal column' : 'q-splitter--vertical row' }`
        + ` q-splitter--${ props.disable === true ? 'disabled' : 'workable' }`
        + (isDark.value === true ? ' q-splitter--dark' : '')
      );

      const propName = vue.computed(() => (props.horizontal === true ? 'height' : 'width'));
      const side = vue.computed(() => (props.reverse !== true ? 'before' : 'after'));

      const computedLimits = vue.computed(() => (
        props.limits !== void 0
          ? props.limits
          : (props.unit === '%' ? [ 10, 90 ] : [ 50, Infinity ])
      ));

      function getCSSValue (value) {
        return (props.unit === '%' ? value : Math.round(value)) + props.unit
      }

      const styles = vue.computed(() => ({
        [ side.value ]: {
          [ propName.value ]: getCSSValue(props.modelValue)
        }
      }));

      let __dir, __maxValue, __value, __multiplier, __normalized;

      function pan (evt) {
        if (evt.isFirst === true) {
          const size = rootRef.value.getBoundingClientRect()[ propName.value ];

          __dir = props.horizontal === true ? 'up' : 'left';
          __maxValue = props.unit === '%' ? 100 : size;
          __value = Math.min(__maxValue, computedLimits.value[ 1 ], Math.max(computedLimits.value[ 0 ], props.modelValue));
          __multiplier = (props.reverse !== true ? 1 : -1)
            * (props.horizontal === true ? 1 : ($q.lang.rtl === true ? -1 : 1))
            * (props.unit === '%' ? (size === 0 ? 0 : 100 / size) : 1);

          rootRef.value.classList.add('q-splitter--active');
          return
        }

        if (evt.isFinal === true) {
          if (__normalized !== props.modelValue) {
            emit('update:modelValue', __normalized);
          }

          rootRef.value.classList.remove('q-splitter--active');
          return
        }

        const val = __value
          + __multiplier
          * (evt.direction === __dir ? -1 : 1)
          * evt.distance[ props.horizontal === true ? 'y' : 'x' ];

        __normalized = Math.min(__maxValue, computedLimits.value[ 1 ], Math.max(computedLimits.value[ 0 ], val));

        sideRefs[ side.value ].value.style[ propName.value ] = getCSSValue(__normalized);

        if (props.emitImmediately === true && props.modelValue !== __normalized) {
          emit('update:modelValue', __normalized);
        }
      }

      const sepDirective = vue.computed(() => {
        // if props.disable !== true
        return [ [
          TouchPan,
          pan,
          void 0,
          {
            [ props.horizontal === true ? 'vertical' : 'horizontal' ]: true,
            prevent: true,
            stop: true,
            mouse: true,
            mouseAllDir: true
          }
        ] ]
      });

      function normalize (val, limits) {
        if (val < limits[ 0 ]) {
          emit('update:modelValue', limits[ 0 ]);
        }
        else if (val > limits[ 1 ]) {
          emit('update:modelValue', limits[ 1 ]);
        }
      }

      vue.watch(() => props.modelValue, v => {
        normalize(v, computedLimits.value);
      });

      vue.watch(() => props.limits, () => {
        vue.nextTick(() => {
          normalize(props.modelValue, computedLimits.value);
        });
      });

      return () => {
        const child = [
          vue.h('div', {
            ref: sideRefs.before,
            class: [
              'q-splitter__panel q-splitter__before' + (props.reverse === true ? ' col' : ''),
              props.beforeClass
            ],
            style: styles.value.before
          }, hSlot(slots.before)),

          vue.h('div', {
            class: [
              'q-splitter__separator',
              props.separatorClass
            ],
            style: props.separatorStyle,
            'aria-disabled': props.disable === true ? 'true' : void 0
          }, [
            hDir(
              'div',
              { class: 'q-splitter__separator-area absolute-full' },
              hSlot(slots.separator),
              'sep',
              props.disable !== true,
              () => sepDirective.value
            )
          ]),

          vue.h('div', {
            ref: sideRefs.after,
            class: [
              'q-splitter__panel q-splitter__after' + (props.reverse === true ? '' : ' col'),
              props.afterClass
            ],
            style: styles.value.after
          }, hSlot(slots.after))
        ];

        return vue.h('div', {
          class: classes.value,
          ref: rootRef
        }, hMergeSlot(slots.default, child))
      }
    }
  });

  var StepHeader = vue.defineComponent({
    name: 'StepHeader',

    props: {
      stepper: {},
      step: {},
      goToPanel: Function
    },

    setup (props, { attrs }) {
      const { proxy: { $q } } = vue.getCurrentInstance();
      const blurRef = vue.ref(null);

      const isActive = vue.computed(() => props.stepper.modelValue === props.step.name);

      const isDisable = vue.computed(() => {
        const opt = props.step.disable;
        return opt === true || opt === ''
      });

      const isError = vue.computed(() => {
        const opt = props.step.error;
        return opt === true || opt === ''
      });

      const isDone = vue.computed(() => {
        const opt = props.step.done;
        return isDisable.value === false && (opt === true || opt === '')
      });

      const headerNav = vue.computed(() => {
        const
          opt = props.step.headerNav,
          nav = opt === true || opt === '' || opt === void 0;

        return isDisable.value === false
          && props.stepper.headerNav
          && nav
      });

      const hasPrefix = vue.computed(() => {
        return props.step.prefix
          && isActive.value === false
          && isError.value === false
          && isDone.value === false
      });

      const icon = vue.computed(() => {
        if (isActive.value === true) {
          return props.step.activeIcon || props.stepper.activeIcon || $q.iconSet.stepper.active
        }
        if (isError.value === true) {
          return props.step.errorIcon || props.stepper.errorIcon || $q.iconSet.stepper.error
        }
        if (isDisable.value === false && isDone.value === true) {
          return props.step.doneIcon || props.stepper.doneIcon || $q.iconSet.stepper.done
        }

        return props.step.icon || props.stepper.inactiveIcon
      });

      const color = vue.computed(() => {
        const errorColor = isError.value === true
          ? props.step.errorColor || props.stepper.errorColor
          : void 0;

        if (isActive.value === true) {
          const color = props.step.activeColor || props.stepper.activeColor || props.step.color;
          return color !== void 0
            ? color
            : errorColor
        }
        if (errorColor !== void 0) {
          return errorColor
        }
        if (isDisable.value === false && isDone.value === true) {
          return props.step.doneColor || props.stepper.doneColor || props.step.color || props.stepper.inactiveColor
        }

        return props.step.color || props.stepper.inactiveColor
      });

      const classes = vue.computed(() => {
        return 'q-stepper__tab col-grow flex items-center no-wrap relative-position'
          + (color.value !== void 0 ? ` text-${ color.value }` : '')
          + (isError.value === true ? ' q-stepper__tab--error' : '')
          + (isActive.value === true ? ' q-stepper__tab--active' : '')
          + (isDone.value === true ? ' q-stepper__tab--done' : '')
          + (headerNav.value === true ? ' q-stepper__tab--navigation q-focusable q-hoverable' : '')
          + (isDisable.value === true ? ' q-stepper__tab--disabled' : '')
      });

      function onActivate () {
        blurRef.value !== null && blurRef.value.focus();
        isActive.value === false && props.goToPanel(props.step.name);
      }

      function onKeyup (e) {
        if (e.keyCode === 13 && isActive.value === false) {
          props.goToPanel(props.step.name);
        }
      }

      return () => {
        const data = { class: classes.value };

        if (headerNav.value === true) {
          data.onClick = onActivate;
          data.onKeyup = onKeyup;

          Object.assign(data,
            isDisable.value === true
              ? { tabindex: -1, 'aria-disabled': 'true' }
              : { tabindex: attrs.tabindex || 0 }
          );
        }

        const child = [
          vue.h('div', { class: 'q-focus-helper', tabindex: -1, ref: blurRef }),

          vue.h('div', { class: 'q-stepper__dot row flex-center q-stepper__line relative-position' }, [
            vue.h('span', { class: 'row flex-center' }, [
              hasPrefix.value === true
                ? props.step.prefix
                : vue.h(QIcon, { name: icon.value })
            ])
          ])
        ];

        if (props.step.title !== void 0 && props.step.title !== null) {
          const content = [
            vue.h('div', { class: 'q-stepper__title' }, props.step.title)
          ];

          if (props.step.caption !== void 0 && props.step.caption !== null) {
            content.push(
              vue.h('div', { class: 'q-stepper__caption' }, props.step.caption)
            );
          }

          child.push(
            vue.h('div', {
              class: 'q-stepper__label q-stepper__line relative-position'
            }, content)
          );
        }

        return hDir(
          'div',
          data,
          child,
          'head',
          props.stepper.headerNav === true && headerNav.value !== false,
          () => [ [ Ripple, headerNav.value ] ]
        )
      }
    }
  });

  function getStepWrapper (slots) {
    return vue.h('div', {
      class: 'q-stepper__step-content'
    }, [
      vue.h('div', {
        class: 'q-stepper__step-inner'
      }, hSlot(slots.default))
    ])
  }

  const PanelWrapper = {
    setup (_, { slots }) {
      return () => getStepWrapper(slots)
    }
  };

  var QStep = vue.defineComponent({
    name: 'QStep',

    props: {
      ...usePanelChildProps,

      icon: String,
      color: String,
      title: {
        type: String,
        required: true
      },
      caption: String,
      prefix: [ String, Number ],

      doneIcon: String,
      doneColor: String,
      activeIcon: String,
      activeColor: String,
      errorIcon: String,
      errorColor: String,

      headerNav: {
        type: Boolean,
        default: true
      },
      done: Boolean,
      error: Boolean
    },

    setup (props, { slots }) {
      const $stepper = vue.inject(stepperKey, () => {
        console.error('QStep needs to be child of QStepper');
      });

      const { getCacheWithFn } = useCache();

      const rootRef = vue.ref(null);

      const isActive = vue.computed(() => $stepper.value.modelValue === props.name);

      vue.watch(isActive, active => {
        if (
          active === true
          && $stepper.value.vertical === true
        ) {
          vue.nextTick(() => {
            if (rootRef.value !== null) {
              rootRef.value.scrollTop = 0;
            }
          });
        }
      });

      const contentKey = vue.computed(() => (
        typeof props.name === 'string' || typeof props.name === 'number'
          ? props.name
          : String(props.name)
      ));

      function getStepContent () {
        const vertical = $stepper.value.vertical;

        if (vertical === true && $stepper.value.keepAlive === true) {
          return vue.h(
            vue.KeepAlive,
            $stepper.value.keepAliveProps.value,
            isActive.value === true
              ? [
                  vue.h(
                    $stepper.value.needsUniqueKeepAliveWrapper.value === true
                      ? getCacheWithFn(contentKey.value, () => ({ ...PanelWrapper, name: contentKey.value }))
                      : PanelWrapper,
                    { key: contentKey.value },
                    slots.default
                  )
                ]
              : void 0
          )
        }

        return vertical !== true || isActive.value === true
          ? getStepWrapper(slots)
          : void 0
      }

      return () => vue.h(
        'div',
        { ref: rootRef, class: 'q-stepper__step' },
        $stepper.value.vertical === true
          ? [
              vue.h(StepHeader, {
                stepper: $stepper.value,
                step: props,
                goToPanel: $stepper.value.goToPanel
              }),

              $stepper.value.animated === true
                ? vue.h(QSlideTransition, getStepContent)
                : getStepContent()
            ]
          : [ getStepContent() ]
      )
    }
  });

  const camelRE = /(-\w)/g;

  function camelizeProps (props) {
    const acc = {};
    Object.keys(props).forEach(key => {
      const newKey = key.replace(camelRE, m => m[ 1 ].toUpperCase());
      acc[ newKey ] = props[ key ];
    });
    return acc
  }

  var QStepper = vue.defineComponent({
    name: 'QStepper',

    props: {
      ...useDarkProps,
      ...usePanelProps,

      flat: Boolean,
      bordered: Boolean,
      alternativeLabels: Boolean,
      headerNav: Boolean,
      contracted: Boolean,
      headerClass: String,

      inactiveColor: String,
      inactiveIcon: String,
      doneIcon: String,
      doneColor: String,
      activeIcon: String,
      activeColor: String,
      errorIcon: String,
      errorColor: String
    },

    emits: usePanelEmits,

    setup (props, { slots }) {
      const vm = vue.getCurrentInstance();
      const isDark = useDark(props, vm.proxy.$q);

      const {
        updatePanelsList, isValidPanelName,
        updatePanelIndex, getPanelContent,
        getPanels, panelDirectives, goToPanel,
        keepAliveProps, needsUniqueKeepAliveWrapper
      } = usePanel();

      vue.provide(stepperKey, vue.computed(() => ({
        goToPanel,
        keepAliveProps,
        needsUniqueKeepAliveWrapper,
        ...props
      })));

      const classes = vue.computed(() =>
        `q-stepper q-stepper--${ props.vertical === true ? 'vertical' : 'horizontal' }`
        + (props.flat === true || isDark.value === true ? ' q-stepper--flat no-shadow' : '')
        + (props.bordered === true || (isDark.value === true && props.flat === false) ? ' q-stepper--bordered' : '')
        + (props.contracted === true ? ' q-stepper--contracted' : '')
        + (isDark.value === true ? ' q-stepper--dark q-dark' : '')
      );

      const headerClasses = vue.computed(() =>
        'q-stepper__header row items-stretch justify-between'
        + ` q-stepper__header--${ props.alternativeLabels === true ? 'alternative' : 'standard' }-labels`
        + (props.flat === false || props.bordered === true ? ' q-stepper__header--border' : '')
        + (props.headerClass !== void 0 ? ` ${ props.headerClass }` : '')
      );

      function getContent () {
        const top = hSlot(slots.message, []);

        if (props.vertical === true) {
          isValidPanelName(props.modelValue) && updatePanelIndex();

          const content = vue.h('div', {
            class: 'q-stepper__content'
          }, hSlot(slots.default));

          return top === void 0
            ? [ content ]
            : top.concat(content)
        }

        return [
          vue.h(
            'div',
            { class: headerClasses.value },
            getPanels().map(panel => {
              const step = camelizeProps(panel.props);

              return vue.h(StepHeader, {
                key: step.name,
                stepper: props,
                step,
                goToPanel
              })
            })
          ),

          top,

          hDir(
            'div',
            { class: 'q-stepper__content q-panel-parent' },
            getPanelContent(),
            'cont',
            props.swipeable,
            () => panelDirectives.value
          )
        ]
      }

      return () => {
        updatePanelsList(slots);

        return vue.h('div', {
          class: classes.value
        }, hMergeSlot(slots.navigation, getContent()))
      }
    }
  });

  var QStepperNavigation = vue.defineComponent({
    name: 'QStepperNavigation',

    setup (_, { slots }) {
      return () => vue.h('div', { class: 'q-stepper__nav' }, hSlot(slots.default))
    }
  });

  var QTh = vue.defineComponent({
    name: 'QTh',

    props: {
      props: Object,
      autoWidth: Boolean
    },

    emits: [ 'click' ],

    setup (props, { slots, emit }) {
      const vm = vue.getCurrentInstance();
      const { proxy: { $q } } = vm;

      return () => {
        if (props.props === void 0) {
          return vue.h('th', {
            class: props.autoWidth === true ? 'q-table--col-auto-width' : ''
          }, hSlot(slots.default))
        }

        let col, child;
        const name = vm.vnode.key;

        if (name) {
          col = props.props.colsMap[ name ];
          if (col === void 0) { return }
        }
        else {
          col = props.props.col;
        }

        if (col.sortable === true) {
          const action = col.align === 'right'
            ? 'unshift'
            : 'push';

          child = hUniqueSlot(slots.default, []);
          child[ action ](
            vue.h(QIcon, {
              class: col.__iconClass,
              name: $q.iconSet.table.arrowUp
            })
          );
        }
        else {
          child = hSlot(slots.default);
        }

        const data = {
          class: col.__thClass
            + (props.autoWidth === true ? ' q-table--col-auto-width' : ''),
          style: col.headerStyle
        };

        if (col.sortable === true) {
          data.onClick = evt => {
            props.props.sort(col); // eslint-disable-line
            emit('click', evt);
          };
        }

        return vue.h('th', data, child)
      }
    }
  });

  function getTableMiddle (props, content) {
    return vue.h('div', props, [
      vue.h('table', { class: 'q-table' }, content)
    ])
  }

  const comps = {
    list: QList,
    table: QMarkupTable
  };

  const typeOptions = [ 'list', 'table', '__qtable' ];

  var QVirtualScroll = vue.defineComponent({
    name: 'QVirtualScroll',

    props: {
      ...useVirtualScrollProps,

      type: {
        type: String,
        default: 'list',
        validator: v => typeOptions.includes(v)
      },

      items: {
        type: Array,
        default: () => []
      },

      itemsFn: Function,
      itemsSize: Number,

      scrollTarget: {
        default: void 0
      }
    },

    setup (props, { slots, attrs }) {
      let localScrollTarget;
      const rootRef = vue.ref(null);

      const virtualScrollLength = vue.computed(() => (
        props.itemsSize >= 0 && props.itemsFn !== void 0
          ? parseInt(props.itemsSize, 10)
          : (Array.isArray(props.items) ? props.items.length : 0)
      ));

      const {
        virtualScrollSliceRange,
        localResetVirtualScroll,
        padVirtualScroll,
        onVirtualScrollEvt
      } = useVirtualScroll({
        virtualScrollLength, getVirtualScrollTarget, getVirtualScrollEl
      });

      const virtualScrollScope = vue.computed(() => {
        if (virtualScrollLength.value === 0) {
          return []
        }

        const mapFn = (item, i) => ({
          index: virtualScrollSliceRange.value.from + i,
          item
        });

        return props.itemsFn === void 0
          ? props.items.slice(virtualScrollSliceRange.value.from, virtualScrollSliceRange.value.to).map(mapFn)
          : props.itemsFn(virtualScrollSliceRange.value.from, virtualScrollSliceRange.value.to - virtualScrollSliceRange.value.from).map(mapFn)
      });

      const classes = vue.computed(() =>
        'q-virtual-scroll q-virtual-scroll' + (props.virtualScrollHorizontal === true ? '--horizontal' : '--vertical')
        + (props.scrollTarget !== void 0 ? '' : ' scroll')
      );

      const attributes = vue.computed(() => (
        props.scrollTarget !== void 0 ? {} : { tabindex: 0 }
      ));

      vue.watch(virtualScrollLength, () => {
        localResetVirtualScroll();
      });

      vue.watch(() => props.scrollTarget, () => {
        unconfigureScrollTarget();
        configureScrollTarget();
      });

      function getVirtualScrollEl () {
        return rootRef.value.$el || rootRef.value
      }

      function getVirtualScrollTarget () {
        return localScrollTarget
      }

      function configureScrollTarget () {
        localScrollTarget = getScrollTarget(getVirtualScrollEl(), props.scrollTarget);
        localScrollTarget.addEventListener('scroll', onVirtualScrollEvt, listenOpts.passive);
      }

      function unconfigureScrollTarget () {
        if (localScrollTarget !== void 0) {
          localScrollTarget.removeEventListener('scroll', onVirtualScrollEvt, listenOpts.passive);
          localScrollTarget = void 0;
        }
      }

      function __getVirtualChildren () {
        let child = padVirtualScroll(
          props.type === 'list' ? 'div' : 'tbody',
          virtualScrollScope.value.map(slots.default)
        );

        if (slots.before !== void 0) {
          child = slots.before().concat(child);
        }

        return hMergeSlot(slots.after, child)
      }

      vue.onBeforeMount(() => {
        localResetVirtualScroll();
      });

      vue.onMounted(() => {
        configureScrollTarget();
      });

      vue.onBeforeUnmount(() => {
        unconfigureScrollTarget();
      });

      return () => {
        if (slots.default === void 0) {
          console.error('QVirtualScroll: default scoped slot is required for rendering');
          return
        }

        return props.type === '__qtable'
          ? getTableMiddle(
              { ref: rootRef, class: 'q-table__middle ' + classes.value },
              __getVirtualChildren()
            )
          : vue.h(comps[ props.type ], {
            ...attrs,
            ref: rootRef,
            class: [ attrs.class, classes.value ],
            ...attributes.value
          }, __getVirtualChildren)
      }
    }
  });

  function sortDate (a, b) {
    return (new Date(a)) - (new Date(b))
  }

  const useTableSortProps = {
    sortMethod: Function,
    binaryStateSort: Boolean,
    columnSortOrder: {
      type: String,
      validator: v => v === 'ad' || v === 'da',
      default: 'ad'
    }
  };

  function useTableSort (props, computedPagination, colList, setPagination) {
    const columnToSort = vue.computed(() => {
      const { sortBy } = computedPagination.value;

      return sortBy
        ? colList.value.find(def => def.name === sortBy) || null
        : null
    });

    const computedSortMethod = vue.computed(() => (
      props.sortMethod !== void 0
        ? props.sortMethod
        : (data, sortBy, descending) => {
            const col = colList.value.find(def => def.name === sortBy);
            if (col === void 0 || col.field === void 0) {
              return data
            }

            const
              dir = descending === true ? -1 : 1,
              val = typeof col.field === 'function'
                ? v => col.field(v)
                : v => v[ col.field ];

            return data.sort((a, b) => {
              let
                A = val(a),
                B = val(b);

              if (A === null || A === void 0) {
                return -1 * dir
              }
              if (B === null || B === void 0) {
                return 1 * dir
              }
              if (col.sort !== void 0) {
                return col.sort(A, B, a, b) * dir
              }
              if (isNumber(A) === true && isNumber(B) === true) {
                return (A - B) * dir
              }
              if (isDate(A) === true && isDate(B) === true) {
                return sortDate(A, B) * dir
              }
              if (typeof A === 'boolean' && typeof B === 'boolean') {
                return (A - B) * dir
              }

              [ A, B ] = [ A, B ].map(s => (s + '').toLocaleString().toLowerCase());

              return A < B
                ? -1 * dir
                : (A === B ? 0 : dir)
            })
          }
    ));

    function sort (col /* String(col name) or Object(col definition) */) {
      let sortOrder = props.columnSortOrder;

      if (col === Object(col)) {
        if (col.sortOrder) {
          sortOrder = col.sortOrder;
        }

        col = col.name;
      }
      else {
        const def = colList.value.find(def => def.name === col);
        if (def !== void 0 && def.sortOrder) {
          sortOrder = def.sortOrder;
        }
      }

      let { sortBy, descending } = computedPagination.value;

      if (sortBy !== col) {
        sortBy = col;
        descending = sortOrder === 'da';
      }
      else if (props.binaryStateSort === true) {
        descending = !descending;
      }
      else if (descending === true) {
        if (sortOrder === 'ad') {
          sortBy = null;
        }
        else {
          descending = false;
        }
      }
      else { // ascending
        if (sortOrder === 'ad') {
          descending = true;
        }
        else {
          sortBy = null;
        }
      }

      setPagination({ sortBy, descending, page: 1 });
    }

    return {
      columnToSort,
      computedSortMethod,
      sort
    }
  }

  const useTableFilterProps = {
    filter: [ String, Object ],
    filterMethod: Function
  };

  function useTableFilter (props, setPagination) {
    const computedFilterMethod = vue.computed(() => (
      props.filterMethod !== void 0
        ? props.filterMethod
        : (rows, terms, cols, cellValue) => {
            const lowerTerms = terms ? terms.toLowerCase() : '';
            return rows.filter(
              row => cols.some(col => {
                const val = cellValue(col, row) + '';
                const haystack = (val === 'undefined' || val === 'null') ? '' : val.toLowerCase();
                return haystack.indexOf(lowerTerms) !== -1
              })
            )
          }
    ));

    vue.watch(
      () => props.filter,
      () => {
        vue.nextTick(() => {
          setPagination({ page: 1 }, true);
        });
      },
      { deep: true }
    );

    return { computedFilterMethod }
  }

  function samePagination (oldPag, newPag) {
    for (const prop in newPag) {
      if (newPag[ prop ] !== oldPag[ prop ]) {
        return false
      }
    }
    return true
  }

  function fixPagination (p) {
    if (p.page < 1) {
      p.page = 1;
    }
    if (p.rowsPerPage !== void 0 && p.rowsPerPage < 1) {
      p.rowsPerPage = 0;
    }
    return p
  }

  const useTablePaginationProps = {
    pagination: Object,
    rowsPerPageOptions: {
      type: Array,
      default: () => [ 5, 7, 10, 15, 20, 25, 50, 0 ]
    },

    'onUpdate:pagination': Function
  };

  function useTablePaginationState (vm, getCellValue) {
    const { props, emit } = vm;

    const innerPagination = vue.ref(
      Object.assign({
        sortBy: null,
        descending: false,
        page: 1,
        rowsPerPage: props.rowsPerPageOptions.length > 0
          ? props.rowsPerPageOptions[ 0 ]
          : 5
      }, props.pagination)
    );

    const computedPagination = vue.computed(() => {
      const pag = props[ 'onUpdate:pagination' ] !== void 0
        ? { ...innerPagination.value, ...props.pagination }
        : innerPagination.value;

      return fixPagination(pag)
    });

    const isServerSide = vue.computed(() => computedPagination.value.rowsNumber !== void 0);

    function sendServerRequest (pagination) {
      requestServerInteraction({
        pagination,
        filter: props.filter
      });
    }

    function requestServerInteraction (prop = {}) {
      vue.nextTick(() => {
        emit('request', {
          pagination: prop.pagination || computedPagination.value,
          filter: prop.filter || props.filter,
          getCellValue
        });
      });
    }

    function setPagination (val, forceServerRequest) {
      const newPagination = fixPagination({
        ...computedPagination.value,
        ...val
      });

      if (samePagination(computedPagination.value, newPagination)) {
        if (isServerSide.value === true && forceServerRequest === true) {
          sendServerRequest(newPagination);
        }
        return
      }

      if (isServerSide.value === true) {
        sendServerRequest(newPagination);
        return
      }

      if (
        props.pagination !== void 0
        && props[ 'onUpdate:pagination' ] !== void 0
      ) {
        emit('update:pagination', newPagination);
      }
      else {
        innerPagination.value = newPagination;
      }
    }

    return {
      innerPagination,
      computedPagination,
      isServerSide,

      requestServerInteraction,
      setPagination
    }
  }

  function useTablePagination (vm, innerPagination, computedPagination, isServerSide, setPagination, filteredSortedRowsNumber) {
    const { props, emit, proxy: { $q } } = vm;

    const computedRowsNumber = vue.computed(() => (
      isServerSide.value === true
        ? computedPagination.value.rowsNumber || 0
        : filteredSortedRowsNumber.value
    ));

    const firstRowIndex = vue.computed(() => {
      const { page, rowsPerPage } = computedPagination.value;
      return (page - 1) * rowsPerPage
    });

    const lastRowIndex = vue.computed(() => {
      const { page, rowsPerPage } = computedPagination.value;
      return page * rowsPerPage
    });

    const isFirstPage = vue.computed(() => computedPagination.value.page === 1);

    const pagesNumber = vue.computed(() => (
      computedPagination.value.rowsPerPage === 0
        ? 1
        : Math.max(
          1,
          Math.ceil(computedRowsNumber.value / computedPagination.value.rowsPerPage)
        )
    ));

    const isLastPage = vue.computed(() => (
      lastRowIndex.value === 0
        ? true
        : computedPagination.value.page >= pagesNumber.value
    ));

    const computedRowsPerPageOptions = vue.computed(() => {
      const opts = props.rowsPerPageOptions.includes(innerPagination.value.rowsPerPage)
        ? props.rowsPerPageOptions
        : [ innerPagination.value.rowsPerPage ].concat(props.rowsPerPageOptions);

      return opts.map(count => ({
        label: count === 0 ? $q.lang.table.allRows : '' + count,
        value: count
      }))
    });

    vue.watch(pagesNumber, (lastPage, oldLastPage) => {
      if (lastPage === oldLastPage) {
        return
      }

      const currentPage = computedPagination.value.page;
      if (lastPage && !currentPage) {
        setPagination({ page: 1 });
      }
      else if (lastPage < currentPage) {
        setPagination({ page: lastPage });
      }
    });

    function firstPage () {
      setPagination({ page: 1 });
    }

    function prevPage () {
      const { page } = computedPagination.value;
      if (page > 1) {
        setPagination({ page: page - 1 });
      }
    }

    function nextPage () {
      const { page, rowsPerPage } = computedPagination.value;
      if (lastRowIndex.value > 0 && page * rowsPerPage < computedRowsNumber.value) {
        setPagination({ page: page + 1 });
      }
    }

    function lastPage () {
      setPagination({ page: pagesNumber.value });
    }

    if (props[ 'onUpdate:pagination' ] !== void 0) {
      emit('update:pagination', { ...computedPagination.value });
    }

    return {
      firstRowIndex,
      lastRowIndex,
      isFirstPage,
      isLastPage,
      pagesNumber,
      computedRowsPerPageOptions,
      computedRowsNumber,

      firstPage,
      prevPage,
      nextPage,
      lastPage
    }
  }

  const useTableRowSelectionProps = {
    selection: {
      type: String,
      default: 'none',
      validator: v => [ 'single', 'multiple', 'none' ].includes(v)
    },
    selected: {
      type: Array,
      default: () => []
    }
  };

  const useTableRowSelectionEmits = [ 'update:selected', 'selection' ];

  function useTableRowSelection (props, emit, computedRows, getRowKey) {
    const selectedKeys = vue.computed(() => {
      const keys = {};
      props.selected.map(getRowKey.value).forEach(key => {
        keys[ key ] = true;
      });
      return keys
    });

    const hasSelectionMode = vue.computed(() => {
      return props.selection !== 'none'
    });

    const singleSelection = vue.computed(() => {
      return props.selection === 'single'
    });

    const multipleSelection = vue.computed(() => {
      return props.selection === 'multiple'
    });

    const allRowsSelected = vue.computed(() =>
      computedRows.value.length > 0 && computedRows.value.every(
        row => selectedKeys.value[ getRowKey.value(row) ] === true
      )
    );

    const someRowsSelected = vue.computed(() =>
      allRowsSelected.value !== true
      && computedRows.value.some(row => selectedKeys.value[ getRowKey.value(row) ] === true)
    );

    const rowsSelectedNumber = vue.computed(() => props.selected.length);

    function isRowSelected (key) {
      return selectedKeys.value[ key ] === true
    }

    function clearSelection () {
      emit('update:selected', []);
    }

    function updateSelection (keys, rows, added, evt) {
      emit('selection', { rows, added, keys, evt });

      const payload = singleSelection.value === true
        ? (added === true ? rows : [])
        : (
            added === true
              ? props.selected.concat(rows)
              : props.selected.filter(
                row => keys.includes(getRowKey.value(row)) === false
              )
          );

      emit('update:selected', payload);
    }

    return {
      hasSelectionMode,
      singleSelection,
      multipleSelection,
      allRowsSelected,
      someRowsSelected,
      rowsSelectedNumber,

      isRowSelected,
      clearSelection,
      updateSelection
    }
  }

  function getVal (val) {
    return Array.isArray(val)
      ? val.slice()
      : []
  }

  const useTableRowExpandProps = {
    expanded: Array // v-model:expanded
  };

  const useTableRowExpandEmits = [ 'update:expanded' ];

  function useTableRowExpand (props, emit) {
    const innerExpanded = vue.ref(getVal(props.expanded));

    vue.watch(() => props.expanded, val => {
      innerExpanded.value = getVal(val);
    });

    function isRowExpanded (key) {
      return innerExpanded.value.includes(key)
    }

    function setExpanded (val) {
      if (props.expanded !== void 0) {
        emit('update:expanded', val);
      }
      else {
        innerExpanded.value = val;
      }
    }

    function updateExpanded (key, add) {
      const target = innerExpanded.value.slice();
      const index = target.indexOf(key);

      if (add === true) {
        if (index === -1) {
          target.push(key);
          setExpanded(target);
        }
      }
      else if (index !== -1) {
        target.splice(index, 1);
        setExpanded(target);
      }
    }

    return {
      isRowExpanded,
      setExpanded,
      updateExpanded
    }
  }

  const useTableColumnSelectionProps = {
    visibleColumns: Array
  };

  function useTableColumnSelection (props, computedPagination, hasSelectionMode) {
    const colList = vue.computed(() => {
      if (props.columns !== void 0) {
        return props.columns
      }

      // we infer columns from first row
      const row = props.rows[ 0 ];

      return row !== void 0
        ? Object.keys(row).map(name => ({
            name,
            label: name.toUpperCase(),
            field: name,
            align: isNumber(row[ name ]) ? 'right' : 'left',
            sortable: true
          }))
        : []
    });

    const computedCols = vue.computed(() => {
      const { sortBy, descending } = computedPagination.value;

      const cols = props.visibleColumns !== void 0
        ? colList.value.filter(col => col.required === true || props.visibleColumns.includes(col.name) === true)
        : colList.value;

      return cols.map(col => {
        const align = col.align || 'right';
        const alignClass = `text-${ align }`;

        return {
          ...col,
          align,
          __iconClass: `q-table__sort-icon q-table__sort-icon--${ align }`,
          __thClass: alignClass
            + (col.headerClasses !== void 0 ? ' ' + col.headerClasses : '')
            + (col.sortable === true ? ' sortable' : '')
            + (col.name === sortBy ? ` sorted ${ descending === true ? 'sort-desc' : '' }` : ''),

          __tdStyle: col.style !== void 0
            ? (
                typeof col.style !== 'function'
                  ? () => col.style
                  : col.style
              )
            : () => null,

          __tdClass: col.classes !== void 0
            ? (
                typeof col.classes !== 'function'
                  ? () => alignClass + ' ' + col.classes
                  : row => alignClass + ' ' + col.classes(row)
              )
            : () => alignClass
        }
      })
    });

    const computedColsMap = vue.computed(() => {
      const names = {};
      computedCols.value.forEach(col => {
        names[ col.name ] = col;
      });
      return names
    });

    const computedColspan = vue.computed(() => {
      return props.tableColspan !== void 0
        ? props.tableColspan
        : computedCols.value.length + (hasSelectionMode.value === true ? 1 : 0)
    });

    return {
      colList,
      computedCols,
      computedColsMap,
      computedColspan
    }
  }

  const bottomClass = 'q-table__bottom row items-center';

  const commonVirtPropsObj = {};
  commonVirtPropsList.forEach(p => { commonVirtPropsObj[ p ] = {}; });

  var QTable = vue.defineComponent({
    name: 'QTable',

    props: {
      rows: {
        type: Array,
        default: () => []
      },
      rowKey: {
        type: [ String, Function ],
        default: 'id'
      },

      columns: Array,
      loading: Boolean,

      iconFirstPage: String,
      iconPrevPage: String,
      iconNextPage: String,
      iconLastPage: String,

      title: String,

      hideHeader: Boolean,

      grid: Boolean,
      gridHeader: Boolean,

      dense: Boolean,
      flat: Boolean,
      bordered: Boolean,
      square: Boolean,
      separator: {
        type: String,
        default: 'horizontal',
        validator: v => [ 'horizontal', 'vertical', 'cell', 'none' ].includes(v)
      },
      wrapCells: Boolean,

      virtualScroll: Boolean,
      ...commonVirtPropsObj,

      noDataLabel: String,
      noResultsLabel: String,
      loadingLabel: String,
      selectedRowsLabel: Function,
      rowsPerPageLabel: String,
      paginationLabel: Function,

      color: {
        type: String,
        default: 'grey-8'
      },

      titleClass: [ String, Array, Object ],
      tableStyle: [ String, Array, Object ],
      tableClass: [ String, Array, Object ],
      tableHeaderStyle: [ String, Array, Object ],
      tableHeaderClass: [ String, Array, Object ],
      cardContainerClass: [ String, Array, Object ],
      cardContainerStyle: [ String, Array, Object ],
      cardStyle: [ String, Array, Object ],
      cardClass: [ String, Array, Object ],

      hideBottom: Boolean,
      hideSelectedBanner: Boolean,
      hideNoData: Boolean,
      hidePagination: Boolean,

      onRowClick: Function,
      onRowDblclick: Function,
      onRowContextmenu: Function,

      ...useDarkProps,
      ...useFullscreenProps,

      ...useTableColumnSelectionProps,
      ...useTableFilterProps,
      ...useTablePaginationProps,
      ...useTableRowExpandProps,
      ...useTableRowSelectionProps,
      ...useTableSortProps
    },

    emits: [
      'request', 'virtual-scroll',
      ...useFullscreenEmits,
      ...useTableRowExpandEmits,
      ...useTableRowSelectionEmits
    ],

    setup (props, { slots, emit }) {
      const vm = vue.getCurrentInstance();
      const { proxy: { $q } } = vm;

      const isDark = useDark(props, $q);
      const { inFullscreen, toggleFullscreen } = useFullscreen();

      const getRowKey = vue.computed(() => (
        typeof props.rowKey === 'function'
          ? props.rowKey
          : row => row[ props.rowKey ]
      ));

      const rootRef = vue.ref(null);
      const virtScrollRef = vue.ref(null);
      const hasVirtScroll = vue.computed(() => props.grid !== true && props.virtualScroll === true);

      const cardDefaultClass = vue.computed(() =>
        ' q-table__card'
        + (isDark.value === true ? ' q-table__card--dark q-dark' : '')
        + (props.square === true ? ' q-table--square' : '')
        + (props.flat === true ? ' q-table--flat' : '')
        + (props.bordered === true ? ' q-table--bordered' : '')
      );

      const __containerClass = vue.computed(() =>
        `q-table__container q-table--${ props.separator }-separator column no-wrap`
        + (props.loading === true ? ' q-table--loading' : '')
        + (props.grid === true ? ' q-table--grid' : cardDefaultClass.value)
        + (isDark.value === true ? ' q-table--dark' : '')
        + (props.dense === true ? ' q-table--dense' : '')
        + (props.wrapCells === false ? ' q-table--no-wrap' : '')
        + (inFullscreen.value === true ? ' fullscreen scroll' : '')
      );

      const containerClass = vue.computed(() =>
        __containerClass.value + (props.loading === true ? ' q-table--loading' : '')
      );

      vue.watch(
        () => props.tableStyle + props.tableClass + props.tableHeaderStyle + props.tableHeaderClass + __containerClass.value,
        () => { hasVirtScroll.value === true && virtScrollRef.value !== null && virtScrollRef.value.reset(); }
      );

      const {
        innerPagination,
        computedPagination,
        isServerSide,

        requestServerInteraction,
        setPagination
      } = useTablePaginationState(vm, getCellValue);

      const { computedFilterMethod } = useTableFilter(props, setPagination);
      const { isRowExpanded, setExpanded, updateExpanded } = useTableRowExpand(props, emit);

      const filteredSortedRows = vue.computed(() => {
        let rows = props.rows;

        if (isServerSide.value === true || rows.length === 0) {
          return rows
        }

        const { sortBy, descending } = computedPagination.value;

        if (props.filter) {
          rows = computedFilterMethod.value(rows, props.filter, computedCols.value, getCellValue);
        }

        if (columnToSort.value !== null) {
          rows = computedSortMethod.value(
            props.rows === rows ? rows.slice() : rows,
            sortBy,
            descending
          );
        }

        return rows
      });

      const filteredSortedRowsNumber = vue.computed(() => filteredSortedRows.value.length);

      const computedRows = vue.computed(() => {
        let rows = filteredSortedRows.value;

        if (isServerSide.value === true) {
          return rows
        }

        const { rowsPerPage } = computedPagination.value;

        if (rowsPerPage !== 0) {
          if (firstRowIndex.value === 0 && props.rows !== rows) {
            if (rows.length > lastRowIndex.value) {
              rows = rows.slice(0, lastRowIndex.value);
            }
          }
          else {
            rows = rows.slice(firstRowIndex.value, lastRowIndex.value);
          }
        }

        return rows
      });

      const {
        hasSelectionMode,
        singleSelection,
        multipleSelection,
        allRowsSelected,
        someRowsSelected,
        rowsSelectedNumber,

        isRowSelected,
        clearSelection,
        updateSelection
      } = useTableRowSelection(props, emit, computedRows, getRowKey);

      const { colList, computedCols, computedColsMap, computedColspan } = useTableColumnSelection(props, computedPagination, hasSelectionMode);

      const { columnToSort, computedSortMethod, sort } = useTableSort(props, computedPagination, colList, setPagination);

      const {
        firstRowIndex,
        lastRowIndex,
        isFirstPage,
        isLastPage,
        pagesNumber,
        computedRowsPerPageOptions,
        computedRowsNumber,

        firstPage,
        prevPage,
        nextPage,
        lastPage
      } = useTablePagination(vm, innerPagination, computedPagination, isServerSide, setPagination, filteredSortedRowsNumber);

      const nothingToDisplay = vue.computed(() => computedRows.value.length === 0);

      const virtProps = vue.computed(() => {
        const acc = {};

        commonVirtPropsList
          .forEach(p => { acc[ p ] = props[ p ]; });

        if (acc.virtualScrollItemSize === void 0) {
          acc.virtualScrollItemSize = props.dense === true ? 28 : 48;
        }

        return acc
      });

      function resetVirtualScroll () {
        hasVirtScroll.value === true && virtScrollRef.value.reset();
      }

      function getBody () {
        if (props.grid === true) {
          return getGridBody()
        }

        const header = props.hideHeader !== true ? getTHead : null;

        if (hasVirtScroll.value === true) {
          const topRow = slots[ 'top-row' ];
          const bottomRow = slots[ 'bottom-row' ];

          const virtSlots = {
            default: props => getTBodyTR(props.item, slots.body, props.index)
          };

          if (topRow !== void 0) {
            const topContent = vue.h('tbody', topRow({ cols: computedCols.value }));

            virtSlots.before = header === null
              ? () => topContent
              : () => [ header() ].concat(topContent);
          }
          else if (header !== null) {
            virtSlots.before = header;
          }

          if (bottomRow !== void 0) {
            virtSlots.after = () => vue.h('tbody', bottomRow({ cols: computedCols.value }));
          }

          return vue.h(QVirtualScroll, {
            ref: virtScrollRef,
            class: props.tableClass,
            style: props.tableStyle,
            ...virtProps.value,
            items: computedRows.value,
            type: '__qtable',
            tableColspan: computedColspan.value,
            onVirtualScroll: onVScroll
          }, virtSlots)
        }

        const child = [
          getTBody()
        ];

        if (header !== null) {
          child.unshift(header());
        }

        return getTableMiddle({
          class: [ 'q-table__middle scroll', props.tableClass ],
          style: props.tableStyle
        }, child)
      }

      function scrollTo (toIndex, edge) {
        if (virtScrollRef.value !== null) {
          virtScrollRef.value.scrollTo(toIndex, edge);
          return
        }

        toIndex = parseInt(toIndex, 10);
        const rowEl = rootRef.value.querySelector(`tbody tr:nth-of-type(${ toIndex + 1 })`);

        if (rowEl !== null) {
          const scrollTarget = rootRef.value.querySelector('.q-table__middle.scroll');
          const { offsetTop } = rowEl;
          const direction = offsetTop < scrollTarget.scrollTop ? 'decrease' : 'increase';

          scrollTarget.scrollTop = offsetTop;

          emit('virtual-scroll', {
            index: toIndex,
            from: 0,
            to: innerPagination.value.rowsPerPage - 1,
            direction
          });
        }
      }

      function onVScroll (info) {
        emit('virtual-scroll', info);
      }

      function getProgress () {
        return [
          vue.h(QLinearProgress, {
            class: 'q-table__linear-progress',
            color: props.color,
            dark: isDark.value,
            indeterminate: true,
            trackColor: 'transparent'
          })
        ]
      }

      function getTBodyTR (row, bodySlot, pageIndex) {
        const
          key = getRowKey.value(row),
          selected = isRowSelected(key);

        if (bodySlot !== void 0) {
          return bodySlot(
            getBodyScope({
              key,
              row,
              pageIndex,
              __trClass: selected ? 'selected' : ''
            })
          )
        }

        const
          bodyCell = slots[ 'body-cell' ],
          child = computedCols.value.map(col => {
            const
              bodyCellCol = slots[ `body-cell-${ col.name }` ],
              slot = bodyCellCol !== void 0 ? bodyCellCol : bodyCell;

            return slot !== void 0
              ? slot(getBodyCellScope({ key, row, pageIndex, col }))
              : vue.h('td', {
                class: col.__tdClass(row),
                style: col.__tdStyle(row)
              }, getCellValue(col, row))
          });

        if (hasSelectionMode.value === true) {
          const slot = slots[ 'body-selection' ];
          const content = slot !== void 0
            ? slot(getBodySelectionScope({ key, row, pageIndex }))
            : [
                vue.h(QCheckbox, {
                  modelValue: selected,
                  color: props.color,
                  dark: isDark.value,
                  dense: props.dense,
                  'onUpdate:modelValue': (adding, evt) => {
                    updateSelection([ key ], [ row ], adding, evt);
                  }
                })
              ];

          child.unshift(
            vue.h('td', { class: 'q-table--col-auto-width' }, content)
          );
        }

        const data = { key, class: { selected } };

        if (props.onRowClick !== void 0) {
          data.class[ 'cursor-pointer' ] = true;
          data.onClick = evt => {
            emit('RowClick', evt, row, pageIndex);
          };
        }

        if (props.onRowDblclick !== void 0) {
          data.class[ 'cursor-pointer' ] = true;
          data.onDblclick = evt => {
            emit('RowDblclick', evt, row, pageIndex);
          };
        }

        if (props.onRowContextmenu !== void 0) {
          data.class[ 'cursor-pointer' ] = true;
          data.onContextmenu = evt => {
            emit('RowContextmenu', evt, row, pageIndex);
          };
        }

        return vue.h('tr', data, child)
      }

      function getTBody () {
        const
          body = slots.body,
          topRow = slots[ 'top-row' ],
          bottomRow = slots[ 'bottom-row' ];

        let child = computedRows.value.map(
          (row, pageIndex) => getTBodyTR(row, body, pageIndex)
        );

        if (topRow !== void 0) {
          child = topRow({ cols: computedCols.value }).concat(child);
        }
        if (bottomRow !== void 0) {
          child = child.concat(bottomRow({ cols: computedCols.value }));
        }

        return vue.h('tbody', child)
      }

      function getBodyScope (data) {
        injectBodyCommonScope(data);

        data.cols = data.cols.map(col => {
          const c = { ...col };
          Object.defineProperty(c, 'value', {
            get: () => getCellValue(col, data.row),
            configurable: true,
            enumerable: true
          });
          return c
        });

        return data
      }

      function getBodyCellScope (data) {
        injectBodyCommonScope(data);

        Object.defineProperty(data, 'value', {
          get: () => getCellValue(data.col, data.row),
          configurable: true,
          enumerable: true
        });

        return data
      }

      function getBodySelectionScope (data) {
        injectBodyCommonScope(data);
        return data
      }

      function injectBodyCommonScope (data) {
        Object.assign(data, {
          cols: computedCols.value,
          colsMap: computedColsMap.value,
          sort,
          rowIndex: firstRowIndex.value + data.pageIndex,
          color: props.color,
          dark: isDark.value,
          dense: props.dense
        });

        hasSelectionMode.value === true && Object.defineProperty(data, 'selected', {
          get: () => isRowSelected(data.key),
          set: (adding, evt) => {
            updateSelection([ data.key ], [ data.row ], adding, evt);
          },
          configurable: true,
          enumerable: true
        });

        Object.defineProperty(data, 'expand', {
          get: () => isRowExpanded(data.key),
          set: adding => {
            updateExpanded(data.key, adding);
          },
          configurable: true,
          enumerable: true
        });
      }

      function getCellValue (col, row) {
        const val = typeof col.field === 'function' ? col.field(row) : row[ col.field ];
        return col.format !== void 0 ? col.format(val, row) : val
      }

      const marginalsScope = vue.computed(() => ({
        pagination: computedPagination.value,
        pagesNumber: pagesNumber.value,
        isFirstPage: isFirstPage.value,
        isLastPage: isLastPage.value,
        firstPage,
        prevPage,
        nextPage,
        lastPage,

        inFullscreen: inFullscreen.value,
        toggleFullscreen
      }));

      function getTopDiv () {
        const
          top = slots.top,
          topLeft = slots[ 'top-left' ],
          topRight = slots[ 'top-right' ],
          topSelection = slots[ 'top-selection' ],
          hasSelection = hasSelectionMode.value === true
            && topSelection !== void 0
            && rowsSelectedNumber.vaue > 0,
          topClass = 'q-table__top relative-position row items-center';

        if (top !== void 0) {
          return vue.h('div', { class: topClass }, [ top(marginalsScope.value) ])
        }

        let child;

        if (hasSelection === true) {
          child = topSelection(marginalsScope.value).slice();
        }
        else {
          child = [];

          if (topLeft !== void 0) {
            child.push(
              vue.h('div', { class: 'q-table-control' }, [
                topLeft(marginalsScope.value)
              ])
            );
          }
          else if (props.title) {
            child.push(
              vue.h('div', { class: 'q-table__control' }, [
                vue.h('div', {
                  class: [ 'q-table__title', props.titleClass ]
                }, props.title)
              ])
            );
          }
        }

        if (topRight !== void 0) {
          child.push(
            vue.h('div', { class: 'q-table__separator col' })
          );
          child.push(
            vue.h('div', { class: 'q-table__control' }, [
              topRight(marginalsScope.value)
            ])
          );
        }

        if (child.length === 0) {
          return
        }

        return vue.h('div', { class: topClass }, child)
      }

      const headerSelectedValue = vue.computed(() => (
        someRowsSelected.value === true
          ? null
          : allRowsSelected.value
      ));

      function getTHead () {
        const child = getTHeadTR();

        if (props.loading === true && slots.loading === void 0) {
          child.push(
            vue.h('tr', { class: 'q-table__progress' }, [
              vue.h('th', {
                class: 'relative-position',
                colspan: computedColspan.value
              }, getProgress())
            ])
          );
        }

        return vue.h('thead', child)
      }

      function getTHeadTR () {
        const
          header = slots.header,
          headerCell = slots[ 'header-cell' ];

        if (header !== void 0) {
          return header(
            getHeaderScope({ header: true })
          ).slice()
        }

        const child = computedCols.value.map(col => {
          const
            headerCellCol = slots[ `header-cell-${ col.name }` ],
            slot = headerCellCol !== void 0 ? headerCellCol : headerCell,
            props = getHeaderScope({ col });

          return slot !== void 0
            ? slot(props)
            : vue.h(QTh, {
              key: col.name,
              props
            }, () => col.label)
        });

        if (singleSelection.value === true && props.grid !== true) {
          child.unshift(
            vue.h('th', { class: 'q-table--col-auto-width' }, ' ')
          );
        }
        else if (multipleSelection.value === true) {
          const slot = slots[ 'header-selection' ];
          const content = slot !== void 0
            ? slot(getHeaderScope({}))
            : [
                vue.h(QCheckbox, {
                  color: props.color,
                  modelValue: headerSelectedValue.value,
                  dark: isDark.value,
                  dense: props.dense,
                  'onUpdate:modelValue': onMultipleSelectionSet
                })
              ];

          child.unshift(
            vue.h('th', { class: 'q-table--col-auto-width' }, content)
          );
        }

        return [
          vue.h('tr', {
            class: props.tableHeaderClass,
            style: props.tableHeaderStyle
          }, child)
        ]
      }

      function getHeaderScope (data) {
        Object.assign(data, {
          cols: computedCols.value,
          sort,
          colsMap: computedColsMap.value,
          color: props.color,
          dark: isDark.value,
          dense: props.dense
        });

        if (multipleSelection.value === true) {
          Object.defineProperty(data, 'selected', {
            get: () => headerSelectedValue.value,
            set: onMultipleSelectionSet,
            configurable: true,
            enumerable: true
          });
        }

        return data
      }

      function onMultipleSelectionSet (val) {
        if (someRowsSelected.value === true) {
          val = false;
        }

        updateSelection(
          computedRows.value.map(getRowKey.value),
          computedRows.value,
          val
        );
      }

      const navIcon = vue.computed(() => {
        const ico = [
          props.iconFirstPage || $q.iconSet.table.firstPage,
          props.iconPrevPage || $q.iconSet.table.prevPage,
          props.iconNextPage || $q.iconSet.table.nextPage,
          props.iconLastPage || $q.iconSet.table.lastPage
        ];
        return $q.lang.rtl === true ? ico.reverse() : ico
      });

      function getBottomDiv () {
        if (props.hideBottom === true) {
          return
        }

        if (nothingToDisplay.value === true) {
          if (props.hideNoData === true) {
            return
          }

          const message = props.loading === true
            ? props.loadingLabel || $q.lang.table.loading
            : (props.filter ? props.noResultsLabel || $q.lang.table.noResults : props.noDataLabel || $q.lang.table.noData);

          const noData = slots[ 'no-data' ];
          const children = noData !== void 0
            ? [ noData({ message, icon: $q.iconSet.table.warning, filter: props.filter }) ]
            : [
                vue.h(QIcon, {
                  class: 'q-table__bottom-nodata-icon',
                  name: $q.iconSet.table.warning
                }),
                message
              ];

          return vue.h('div', { class: bottomClass + ' q-table__bottom--nodata' }, children)
        }

        const bottom = slots.bottom;

        if (bottom !== void 0) {
          return vue.h('div', { class: bottomClass }, [ bottom(marginalsScope.value) ])
        }

        const child = props.hideSelectedBanner !== true && hasSelectionMode.value === true && rowsSelectedNumber.value > 0
          ? [
              vue.h('div', { class: 'q-table__control' }, [
                vue.h('div', [
                  (props.selectedRowsLabel || $q.lang.table.selectedRecords)(rowsSelectedNumber.value)
                ])
              ])
            ]
          : [];

        if (props.hidePagination !== true) {
          return vue.h('div', {
            class: bottomClass + ' justify-end'
          }, getPaginationDiv(child))
        }

        if (child.length > 0) {
          return vue.h('div', { class: bottomClass }, child)
        }
      }

      function onPagSelection (pag) {
        setPagination({
          page: 1,
          rowsPerPage: pag.value
        });
      }

      function getPaginationDiv (child) {
        let control;
        const
          { rowsPerPage } = computedPagination.value,
          paginationLabel = props.paginationLabel || $q.lang.table.pagination,
          paginationSlot = slots.pagination,
          hasOpts = props.rowsPerPageOptions.length > 1;

        child.push(
          vue.h('div', { class: 'q-table__separator col' })
        );

        if (hasOpts === true) {
          child.push(
            vue.h('div', { class: 'q-table__control' }, [
              vue.h('span', { class: 'q-table__bottom-item' }, [
                props.rowsPerPageLabel || $q.lang.table.recordsPerPage
              ]),
              vue.h(QSelect, {
                class: 'q-table__select inline q-table__bottom-item',
                color: props.color,
                modelValue: rowsPerPage,
                options: computedRowsPerPageOptions.value,
                displayValue: rowsPerPage === 0
                  ? $q.lang.table.allRows
                  : rowsPerPage,
                dark: isDark.value,
                borderless: true,
                dense: true,
                optionsDense: true,
                optionsCover: true,
                'onUpdate:modelValue': onPagSelection
              })
            ])
          );
        }

        if (paginationSlot !== void 0) {
          control = paginationSlot(marginalsScope.value);
        }
        else {
          control = [
            vue.h('span', rowsPerPage !== 0 ? { class: 'q-table__bottom-item' } : {}, [
              rowsPerPage
                ? paginationLabel(firstRowIndex.value + 1, Math.min(lastRowIndex.value, computedRowsNumber.value), computedRowsNumber.value)
                : paginationLabel(1, filteredSortedRowsNumber.value, computedRowsNumber.value)
            ])
          ];

          if (rowsPerPage !== 0 && pagesNumber.value > 1) {
            const btnProps = {
              color: props.color,
              round: true,
              dense: true,
              flat: true
            };

            if (props.dense === true) {
              btnProps.size = 'sm';
            }

            pagesNumber.value > 2 && control.push(
              vue.h(QBtn, {
                key: 'pgFirst',
                ...btnProps,
                icon: navIcon.value[ 0 ],
                disable: isFirstPage.value,
                onClick: firstPage
              })
            );

            control.push(
              vue.h(QBtn, {
                key: 'pgPrev',
                ...btnProps,
                icon: navIcon.value[ 1 ],
                disable: isFirstPage.value,
                onClick: prevPage
              }),

              vue.h(QBtn, {
                key: 'pgNext',
                ...btnProps,
                icon: navIcon.value[ 2 ],
                disable: isLastPage.value,
                onClick: nextPage
              })
            );

            pagesNumber.value > 2 && control.push(
              vue.h(QBtn, {
                key: 'pgLast',
                ...btnProps,
                icon: navIcon.value[ 3 ],
                disable: isLastPage.value,
                onClick: lastPage
              })
            );
          }
        }

        child.push(
          vue.h('div', { class: 'q-table__control' }, control)
        );

        return child
      }

      function getGridHeader () {
        const child = props.gridHeader === true
          ? [
              vue.h('table', { class: 'q-table' }, [
                getTHead()
              ])
            ]
          : (
              props.loading === true && slots.loading === void 0
                ? getProgress()
                : void 0
            );

        return vue.h('div', { class: 'q-table__middle' }, child)
      }

      function getGridBody () {
        const item = slots.item !== void 0
          ? slots.item
          : scope => {
            const child = scope.cols.map(
              col => vue.h('div', { class: 'q-table__grid-item-row' }, [
                vue.h('div', { class: 'q-table__grid-item-title' }, [ col.label ]),
                vue.h('div', { class: 'q-table__grid-item-value' }, [ col.value ])
              ])
            );

            if (hasSelectionMode.value === true) {
              const slot = slots[ 'body-selection' ];
              const content = slot !== void 0
                ? slot(scope)
                : [
                    vue.h(QCheckbox, {
                      modelValue: scope.selected,
                      color: props.color,
                      dark: isDark.value,
                      dense: props.dense,
                      'onUpdate:modelValue': (adding, evt) => {
                        updateSelection([ scope.key ], [ scope.row ], adding, evt);
                      }
                    })
                  ];

              child.unshift(
                vue.h('div', { class: 'q-table__grid-item-row' }, content),
                vue.h(QSeparator, { dark: isDark.value })
              );
            }

            const data = {
              class: [
                'q-table__grid-item-card' + cardDefaultClass.value,
                props.cardClass
              ],
              style: props.cardStyle
            };

            if (
              props.onRowClick !== void 0
              || props.onRowDblclick !== void 0
            ) {
              data.class[ 0 ] += ' cursor-pointer';

              if (props.onRowClick !== void 0) {
                data.onClick = evt => {
                  emit('RowClick', evt, scope.row, scope.pageIndex);
                };
              }

              if (props.onRowDblclick !== void 0) {
                data.onDblclick = evt => {
                  emit('RowDblclick', evt, scope.row, scope.pageIndex);
                };
              }
            }

            return vue.h('div', {
              class: 'q-table__grid-item col-xs-12 col-sm-6 col-md-4 col-lg-3'
                + (scope.selected === true ? 'q-table__grid-item--selected' : '')
            }, [
              vue.h('div', data, child)
            ])
          };

        return vue.h('div', {
          class: [
            'q-table__grid-content row',
            props.cardContainerClass
          ],
          style: props.cardContainerStyle
        }, computedRows.value.map((row, pageIndex) => {
          return item(getBodyScope({
            key: getRowKey.value(row),
            row,
            pageIndex
          }))
        }))
      }

      // expose public methods and needed computed props
      Object.assign(vm.proxy, {
        requestServerInteraction,
        setPagination,
        firstPage,
        prevPage,
        nextPage,
        lastPage,
        isRowSelected,
        clearSelection,
        isRowExpanded,
        setExpanded,
        sort,
        resetVirtualScroll,
        scrollTo,
        getCellValue
      });

      Object.defineProperty(vm.proxy, 'filteredSortedRows', {
        get: () => filteredSortedRows.value,
        enumerable: true
      });

      Object.defineProperty(vm.proxy, 'computedRows', {
        get: () => computedRows.value,
        enumerable: true
      });

      Object.defineProperty(vm.proxy, 'computedRowsNumber', {
        get: () => computedRowsNumber.value,
        enumerable: true
      });

      return () => {
        const child = [ getTopDiv() ];
        const data = { ref: rootRef, class: containerClass.value };

        if (props.grid === true) {
          child.push(getGridHeader());
        }
        else {
          Object.assign(data, {
            class: [ data.class, props.cardClass ],
            style: props.cardStyle
          });
        }

        child.push(
          getBody(),
          getBottomDiv()
        );

        if (props.loading === true && slots.loading !== void 0) {
          child.push(
            slots.loading()
          );
        }

        return vue.h('div', data, child)
      }
    }
  });

  var QTr = vue.defineComponent({
    name: 'QTr',

    props: {
      props: Object,
      noHover: Boolean
    },

    setup (props, { slots }) {
      const classes = vue.computed(() =>
        'q-tr'
        + (props.props === void 0 || props.props.header === true ? '' : ' ' + props.props.__trClass)
        + (props.noHover === true ? ' q-tr--no-hover' : '')
      );

      return () => vue.h('tr', { class: classes.value }, hSlot(slots.default))
    }
  });

  var QTd = vue.defineComponent({
    name: 'QTd',

    props: {
      props: Object,
      autoWidth: Boolean,
      noHover: Boolean
    },

    setup (props, { slots }) {
      const vm = vue.getCurrentInstance();
      const classes = vue.computed(() =>
        'q-td' + (props.autoWidth === true ? ' q-table--col-auto-width' : '')
        + (props.noHover === true ? ' q-td--no-hover' : '')
        + ' '
      );

      return () => {
        if (props.props === void 0) {
          return vue.h('td', { class: classes.value }, hSlot(slots.default))
        }

        const name = vm.vnode.key;
        const col = (
          (props.props.colsMap !== void 0 ? props.props.colsMap[ name ] : null)
          || props.props.col
        );

        if (col === void 0) { return }

        const { row } = props.props;

        return vue.h('td', {
          class: classes.value + col.__tdClass(row),
          style: col.__tdStyle(row)
        }, hSlot(slots.default))
      }
    }
  });

  var QRouteTab = vue.defineComponent({
    name: 'QRouteTab',

    props: {
      ...useRouterLinkProps,
      ...useTabProps,
      to: { required: true }
    },

    emits: useTabEmits,

    setup (props, { slots, emit }) {
      const exact = vue.computed(() => props.exact);
      const { hasLink, linkTag, linkProps, linkRoute, navigateToLink, linkIsExactActive, linkIsActive } = useRouterLink();

      const { renderTab, $tabs } = useTab(
        props,
        slots,
        emit,
        { exact, hasLink, navigateToLink, linkRoute, linkIsExactActive, linkIsActive }
      );

      vue.watch(() => props.name + props.exact + (linkRoute.value || {}).href, () => {
        $tabs.verifyRouteModel();
      });

      return () => renderTab(linkTag.value, linkProps.value)
    }
  });

  function getViewByModel (model, withSeconds) {
    if (model.hour !== null) {
      if (model.minute === null) {
        return 'minute'
      }
      else if (withSeconds === true && model.second === null) {
        return 'second'
      }
    }

    return 'hour'
  }

  function getCurrentTime () {
    const d = new Date();

    return {
      hour: d.getHours(),
      minute: d.getMinutes(),
      second: d.getSeconds(),
      millisecond: d.getMilliseconds()
    }
  }

  var QTime = vue.defineComponent({
    name: 'QTime',

    props: {
      ...useDarkProps,
      ...useFormProps,
      ...useDatetimeProps,

      mask: {
        default: null
      },

      format24h: {
        type: Boolean,
        default: null
      },

      defaultDate: {
        type: String,
        validator: v => /^-?[\d]+\/[0-1]\d\/[0-3]\d$/.test(v)
      },

      options: Function,
      hourOptions: Array,
      minuteOptions: Array,
      secondOptions: Array,

      withSeconds: Boolean,
      nowBtn: Boolean
    },

    emits: useDatetimeEmits,

    setup (props, { slots, emit }) {
      const { proxy: { $q } } = vue.getCurrentInstance();

      const isDark = useDark(props, $q);
      const { tabindex, headerClass, getLocale, getCurrentDate } = useDatetime(props, $q);

      const formAttrs = useFormAttrs(props);
      const injectFormInput = useFormInject(formAttrs);

      let draggingClockRect, dragCache;

      const clockRef = vue.ref(null);

      const mask = vue.computed(() => getMask());
      const locale = vue.computed(() => getLocale());

      const model = __splitDate(
        props.modelValue,
        getMask(),
        getLocale(),
        props.calendar,
        getDefaultDateModel()
      );

      const view = vue.ref(getViewByModel(model));
      const innerModel = vue.ref(model);
      const isAM = vue.ref(model.hour === null || model.hour < 12);

      const classes = vue.computed(() =>
        `q-time q-time--${ props.landscape === true ? 'landscape' : 'portrait' }`
        + (isDark.value === true ? ' q-time--dark q-dark' : '')
        + (props.disable === true ? ' disabled' : (props.readonly === true ? ' q-time--readonly' : ''))
        + (props.bordered === true ? ' q-time--bordered' : '')
        + (props.square === true ? ' q-time--square no-border-radius' : '')
        + (props.flat === true ? ' q-time--flat no-shadow' : '')
      );

      const stringModel = vue.computed(() => {
        const time = innerModel.value;

        return {
          hour: time.hour === null
            ? '--'
            : (
                computedFormat24h.value === true
                  ? pad(time.hour)
                  : String(
                    isAM.value === true
                      ? (time.hour === 0 ? 12 : time.hour)
                      : (time.hour > 12 ? time.hour - 12 : time.hour)
                  )
              ),
          minute: time.minute === null
            ? '--'
            : pad(time.minute),
          second: time.second === null
            ? '--'
            : pad(time.second)
        }
      });

      const defaultDateModel = vue.computed(() => getDefaultDateModel());

      const computedFormat24h = vue.computed(() => (
        props.format24h !== null
          ? props.format24h
          : $q.lang.date.format24h
      ));

      const pointerStyle = vue.computed(() => {
        const
          forHour = view.value === 'hour',
          divider = forHour === true ? 12 : 60,
          amount = innerModel.value[ view.value ],
          degrees = Math.round(amount * (360 / divider)) - 180;

        let transform = `rotate(${ degrees }deg) translateX(-50%)`;

        if (
          forHour === true
          && computedFormat24h.value === true
          && innerModel.value.hour >= 12
        ) {
          transform += ' scale(.7)';
        }

        return { transform }
      });

      const minLink = vue.computed(() => innerModel.value.hour !== null);
      const secLink = vue.computed(() => minLink.value === true && innerModel.value.minute !== null);

      const hourInSelection = vue.computed(() => (
        props.hourOptions !== void 0
          ? val => props.hourOptions.includes(val)
          : (
              props.options !== void 0
                ? val => props.options(val, null, null)
                : null
            )
      ));

      const minuteInSelection = vue.computed(() => (
        props.minuteOptions !== void 0
          ? val => props.minuteOptions.includes(val)
          : (
              props.options !== void 0
                ? val => props.options(innerModel.value.hour, val, null)
                : null
            )
      ));

      const secondInSelection = vue.computed(() => (
        props.secondOptions !== void 0
          ? val => props.secondOptions.includes(val)
          : (
              props.options !== void 0
                ? val => props.options(innerModel.value.hour, innerModel.value.minute, val)
                : null
            )
      ));

      const validHours = vue.computed(() => {
        if (hourInSelection.value === null) {
          return null
        }

        const am = getValidValues(0, 11, hourInSelection.value);
        const pm = getValidValues(12, 11, hourInSelection.value);
        return { am, pm, values: am.values.concat(pm.values) }
      });

      const validMinutes = vue.computed(() => (
        minuteInSelection.value !== null
          ? getValidValues(0, 59, minuteInSelection.value)
          : null
      ));

      const validSeconds = vue.computed(() => (
        secondInSelection.value !== null
          ? getValidValues(0, 59, secondInSelection.value)
          : null
      ));

      const viewValidOptions = vue.computed(() => {
        switch (view.value) {
          case 'hour':
            return validHours.value
          case 'minute':
            return validMinutes.value
          case 'second':
            return validSeconds.value
        }
      });

      const positions = vue.computed(() => {
        let start, end, offset = 0, step = 1;
        const values = viewValidOptions.value !== null
          ? viewValidOptions.value.values
          : void 0;

        if (view.value === 'hour') {
          if (computedFormat24h.value === true) {
            start = 0;
            end = 23;
          }
          else {
            start = 0;
            end = 11;

            if (isAM.value === false) {
              offset = 12;
            }
          }
        }
        else {
          start = 0;
          end = 55;
          step = 5;
        }

        const pos = [];

        for (let val = start, index = start; val <= end; val += step, index++) {
          const
            actualVal = val + offset,
            disable = values !== void 0 && values.includes(actualVal) === false,
            label = view.value === 'hour' && val === 0
              ? (computedFormat24h.value === true ? '00' : '12')
              : val;

          pos.push({ val: actualVal, index, disable, label });
        }

        return pos
      });

      const clockDirectives = vue.computed(() => {
        return [ [
          TouchPan,
          onPan,
          void 0,
          {
            stop: true,
            prevent: true,
            mouse: true
          }
        ] ]
      });

      vue.watch(() => props.modelValue, v => {
        const model = __splitDate(
          v,
          mask.value,
          locale.value,
          props.calendar,
          defaultDateModel.value
        );

        if (
          model.dateHash !== innerModel.value.dateHash
          || model.timeHash !== innerModel.value.timeHash
        ) {
          innerModel.value = model;

          if (model.hour === null) {
            view.value = 'hour';
          }
          else {
            isAM.value = model.hour < 12;
          }
        }
      });

      vue.watch([ mask, locale ], () => {
        vue.nextTick(() => {
          updateValue();
        });
      });

      function setNow () {
        updateValue({
          ...getCurrentDate(),
          ...getCurrentTime()
        });
        view.value = 'hour';
      }

      function getValidValues (start, count, testFn) {
        const values = Array.apply(null, { length: count + 1 })
          .map((_, index) => {
            const i = index + start;
            return {
              index: i,
              val: testFn(i) === true // force boolean
            }
          })
          .filter(v => v.val === true)
          .map(v => v.index);

        return {
          min: values[ 0 ],
          max: values[ values.length - 1 ],
          values,
          threshold: count + 1
        }
      }

      function getWheelDist (a, b, threshold) {
        const diff = Math.abs(a - b);
        return Math.min(diff, threshold - diff)
      }

      function getNormalizedClockValue (val, { min, max, values, threshold }) {
        if (val === min) {
          return min
        }

        if (val < min || val > max) {
          return getWheelDist(val, min, threshold) <= getWheelDist(val, max, threshold)
            ? min
            : max
        }

        const
          index = values.findIndex(v => val <= v),
          before = values[ index - 1 ],
          after = values[ index ];

        return val - before <= after - val
          ? before
          : after
      }

      function getMask () {
        return props.calendar !== 'persian' && props.mask !== null
          ? props.mask
          : `HH:mm${ props.withSeconds === true ? ':ss' : '' }`
      }

      function getDefaultDateModel () {
        if (typeof props.defaultDate !== 'string') {
          const date = getCurrentDate(true);
          date.dateHash = getDayHash(date);
          return date
        }

        return __splitDate(props.defaultDate, 'YYYY/MM/DD', void 0, props.calendar)
      }

      function shouldAbortInteraction () {
        return vm.isDeactivated === true
          || vm.isUnmounted === true
          // if we have limited options, can we actually set any?
          || (
            viewValidOptions.value !== null
            && (
              viewValidOptions.value.values.length === 0
              || (
                view.value === 'hour' && computedFormat24h.value !== true
                && validHours.value[ isAM.value === true ? 'am' : 'pm' ].values.length === 0
              )
            )
          )
      }

      function getClockRect () {
        const
          clock = clockRef.value,
          { top, left, width } = clock.getBoundingClientRect(),
          dist = width / 2;

        return {
          top: top + dist,
          left: left + dist,
          dist: dist * 0.7
        }
      }

      function onPan (event) {
        if (shouldAbortInteraction() === true) {
          return
        }

        if (event.isFirst === true) {
          draggingClockRect = getClockRect();
          dragCache = updateClock(event.evt, draggingClockRect);
          return
        }

        dragCache = updateClock(event.evt, draggingClockRect, dragCache);

        if (event.isFinal === true) {
          draggingClockRect = false;
          dragCache = null;
          goToNextView();
        }
      }

      function goToNextView () {
        if (view.value === 'hour') {
          view.value = 'minute';
        }
        else if (props.withSeconds && view.value === 'minute') {
          view.value = 'second';
        }
      }

      function updateClock (evt, clockRect, cacheVal) {
        const
          pos = position(evt),
          height = Math.abs(pos.top - clockRect.top),
          distance = Math.sqrt(
            Math.pow(Math.abs(pos.top - clockRect.top), 2)
            + Math.pow(Math.abs(pos.left - clockRect.left), 2)
          );

        let
          val,
          angle = Math.asin(height / distance) * (180 / Math.PI);

        if (pos.top < clockRect.top) {
          angle = clockRect.left < pos.left ? 90 - angle : 270 + angle;
        }
        else {
          angle = clockRect.left < pos.left ? angle + 90 : 270 - angle;
        }

        if (view.value === 'hour') {
          val = angle / 30;

          if (validHours.value !== null) {
            const am = computedFormat24h.value !== true
              ? isAM.value === true
              : (
                  validHours.value.am.values.length > 0 && validHours.value.pm.values.length > 0
                    ? distance >= clockRect.dist
                    : validHours.value.am.values.length > 0
                );

            val = getNormalizedClockValue(
              val + (am === true ? 0 : 12),
              validHours.value[ am === true ? 'am' : 'pm' ]
            );
          }
          else {
            val = Math.round(val);

            if (computedFormat24h.value === true) {
              if (distance < clockRect.dist) {
                if (val < 12) {
                  val += 12;
                }
              }
              else if (val === 12) {
                val = 0;
              }
            }
            else if (isAM.value === true && val === 12) {
              val = 0;
            }
            else if (isAM.value === false && val !== 12) {
              val += 12;
            }
          }

          if (computedFormat24h.value === true) {
            isAM.value = val < 12;
          }
        }
        else {
          val = Math.round(angle / 6) % 60;

          if (view.value === 'minute' && validMinutes.value !== null) {
            val = getNormalizedClockValue(val, validMinutes.value);
          }
          else if (view.value === 'second' && validSeconds.value !== null) {
            val = getNormalizedClockValue(val, validSeconds.value);
          }
        }

        if (cacheVal !== val) {
          setModel[ view.value ](val);
        }

        return val
      }

      const setView = {
        hour () { view.value = 'hour'; },
        minute () { view.value = 'minute'; },
        second () { view.value = 'second'; }
      };

      function setAmOnKey (e) {
        e.keyCode === 13 && setAm();
      }

      function setPmOnKey (e) {
        e.keyCode === 13 && setPm();
      }

      function onClick (evt) {
        if (shouldAbortInteraction() !== true) {
          // onMousedown() has already updated the offset
          // (on desktop only, through mousedown event)
          if ($q.platform.is.desktop !== true) {
            updateClock(evt, getClockRect());
          }

          goToNextView();
        }
      }

      function onMousedown (evt) {
        if (shouldAbortInteraction() !== true) {
          updateClock(evt, getClockRect());
        }
      }

      function onKeyupHour (e) {
        if (e.keyCode === 13) { // ENTER
          view.value = 'hour';
        }
        else if ([ 37, 39 ].includes(e.keyCode)) {
          const payload = e.keyCode === 37 ? -1 : 1;

          if (validHours.value !== null) {
            const values = computedFormat24h.value === true
              ? validHours.value.values
              : validHours.value[ isAM.value === true ? 'am' : 'pm' ].values;

            if (values.length === 0) { return }

            if (innerModel.value.hour === null) {
              setHour(values[ 0 ]);
            }
            else {
              const index = (
                values.length
                + values.indexOf(innerModel.value.hour)
                + payload
              ) % values.length;

              setHour(values[ index ]);
            }
          }
          else {
            const
              wrap = computedFormat24h.value === true ? 24 : 12,
              offset = computedFormat24h.value !== true && isAM.value === false ? 12 : 0,
              val = innerModel.value.hour === null ? -payload : innerModel.value.hour;

            setHour(offset + (24 + val + payload) % wrap);
          }
        }
      }

      function onKeyupMinute (e) {
        if (e.keyCode === 13) { // ENTER
          view.value = 'minute';
        }
        else if ([ 37, 39 ].includes(e.keyCode)) {
          const payload = e.keyCode === 37 ? -1 : 1;

          if (validMinutes.value !== null) {
            const values = validMinutes.value.values;

            if (values.length === 0) { return }

            if (innerModel.value.minute === null) {
              setMinute(values[ 0 ]);
            }
            else {
              const index = (
                values.length
                + values.indexOf(innerModel.value.minute)
                + payload
              ) % values.length;

              setMinute(values[ index ]);
            }
          }
          else {
            const val = innerModel.value.minute === null ? -payload : innerModel.value.minute;
            setMinute((60 + val + payload) % 60);
          }
        }
      }

      function onKeyupSecond (e) {
        if (e.keyCode === 13) { // ENTER
          view.value = 'second';
        }
        else if ([ 37, 39 ].includes(e.keyCode)) {
          const payload = e.keyCode === 37 ? -1 : 1;

          if (validSeconds.value !== null) {
            const values = validSeconds.value.values;

            if (values.length === 0) { return }

            if (innerModel.value.seconds === null) {
              setSecond(values[ 0 ]);
            }
            else {
              const index = (
                values.length
                + values.indexOf(innerModel.value.second)
                + payload
              ) % values.length;

              setSecond(values[ index ]);
            }
          }
          else {
            const val = innerModel.value.second === null ? -payload : innerModel.value.second;
            setSecond((60 + val + payload) % 60);
          }
        }
      }

      function setHour (hour) {
        if (innerModel.value.hour !== hour) {
          innerModel.value.hour = hour;
          innerModel.value.minute = null;
          innerModel.value.second = null;
        }
      }

      function setMinute (minute) {
        if (innerModel.value.minute !== minute) {
          innerModel.value.minute = minute;
          innerModel.value.second = null;
          props.withSeconds !== true && updateValue({ minute });
        }
      }

      function setSecond (second) {
        innerModel.value.second !== second && updateValue({ second });
      }

      const setModel = {
        hour: setHour,
        minute: setMinute,
        second: setSecond
      };

      function setAm () {
        if (isAM.value === false) {
          isAM.value = true;

          if (innerModel.value.hour !== null) {
            innerModel.value.hour -= 12;
            verifyAndUpdate();
          }
        }
      }

      function setPm () {
        if (isAM.value === true) {
          isAM.value = false;

          if (innerModel.value.hour !== null) {
            innerModel.value.hour += 12;
            verifyAndUpdate();
          }
        }
      }

      function verifyAndUpdate () {
        if (hourInSelection.value !== null && hourInSelection.value(innerModel.value.hour) !== true) {
          innerModel.value = __splitDate();
          view.value = 'hour';
          return
        }

        if (minuteInSelection.value !== null && minuteInSelection.value(innerModel.value.minute) !== true) {
          innerModel.value.minute = null;
          innerModel.value.second = null;
          view.value = 'minute';
          return
        }

        if (props.withSeconds === true && secondInSelection.value !== null && secondInSelection.value(innerModel.value.second) !== true) {
          innerModel.value.second = null;
          view.value = 'second';
          return
        }

        if (innerModel.value.hour === null || innerModel.value.minute === null || (props.withSeconds === true && innerModel.value.second === null)) {
          return
        }

        updateValue();
      }

      function updateValue (obj) {
        const date = Object.assign({ ...innerModel.value }, obj);

        const val = props.calendar === 'persian'
          ? pad(date.hour) + ':'
            + pad(date.minute)
            + (props.withSeconds === true ? ':' + pad(date.second) : '')
          : formatDate(
            new Date(
              date.year,
              date.month === null ? null : date.month - 1,
              date.day,
              date.hour,
              date.minute,
              date.second,
              date.millisecond
            ),
            mask.value,
            locale.value,
            date.year,
            date.timezoneOffset
          );

        date.changed = val !== props.modelValue;
        emit('update:modelValue', val, date);
      }

      // expose public methods
      const vm = vue.getCurrentInstance();
      Object.assign(vm.proxy, { setNow });

      function getHeader () {
        const label = [
          vue.h('div', {
            class: 'q-time__link '
              + (view.value === 'hour' ? 'q-time__link--active' : 'cursor-pointer'),
            tabindex: tabindex.value,
            onClick: setView.hour,
            onKeyup: onKeyupHour
          }, stringModel.value.hour),

          vue.h('div', ':'),

          vue.h(
            'div',
            minLink.value === true
              ? {
                  class: 'q-time__link '
                  + (view.value === 'minute' ? 'q-time__link--active' : 'cursor-pointer'),
                  tabindex: tabindex.value,
                  onKeyup: onKeyupMinute,
                  onClick: setView.minute
                }
              : { class: 'q-time__link' },
            stringModel.value.minute
          )
        ];

        if (props.withSeconds === true) {
          label.push(
            vue.h('div', ':'),

            vue.h(
              'div',
              secLink.value === true
                ? {
                    class: 'q-time__link '
                    + (view.value === 'second' ? 'q-time__link--active' : 'cursor-pointer'),
                    tabindex: tabindex.value,
                    onKeyup: onKeyupSecond,
                    onClick: setView.second
                  }
                : { class: 'q-time__link' },
              stringModel.value.second
            )
          );
        }

        const child = [
          vue.h('div', {
            class: 'q-time__header-label row items-center no-wrap',
            dir: 'ltr'
          }, label)
        ];

        computedFormat24h.value === false && child.push(
          vue.h('div', {
            class: 'q-time__header-ampm column items-between no-wrap'
          }, [
            vue.h('div', {
              class: 'q-time__link '
                + (isAM.value === true ? 'q-time__link--active' : 'cursor-pointer'),
              tabindex: tabindex.value,
              onClick: setAm,
              onKeyup: setAmOnKey
            }, 'AM'),

            vue.h('div', {
              class: 'q-time__link '
                + (isAM.value !== true ? 'q-time__link--active' : 'cursor-pointer'),
              tabindex: tabindex.value,
              onClick: setPm,
              onKeyup: setPmOnKey
            }, 'PM')
          ])
        );

        return vue.h('div', {
          class: 'q-time__header flex flex-center no-wrap ' + headerClass.value
        }, child)
      }

      function getClock () {
        const current = innerModel.value[ view.value ];

        return vue.h('div', {
          class: 'q-time__content col relative-position'
        }, [
          vue.h(vue.Transition, {
            name: 'q-transition--scale'
          }, () => vue.h('div', {
            key: 'clock' + view.value,
            class: 'q-time__container-parent absolute-full'
          }, [
            vue.h('div', {
              ref: clockRef,
              class: 'q-time__container-child fit overflow-hidden'
            }, [
              vue.withDirectives(
                vue.h('div', {
                  class: 'q-time__clock cursor-pointer non-selectable',
                  onClick,
                  onMousedown
                }, [
                  vue.h('div', { class: 'q-time__clock-circle fit' }, [
                    vue.h('div', {
                      class: 'q-time__clock-pointer'
                        + (innerModel.value[ view.value ] === null ? ' hidden' : (props.color !== void 0 ? ` text-${ props.color }` : '')),
                      style: pointerStyle.value
                    }),

                    positions.value.map(pos => vue.h('div', {
                      class: `q-time__clock-position row flex-center q-time__clock-pos-${ pos.index }`
                        + (pos.val === current
                          ? ' q-time__clock-position--active ' + headerClass.value
                          : (pos.disable === true ? ' q-time__clock-position--disable' : ''))
                    }, [ vue.h('span', pos.label) ]))
                  ])
                ]),
                clockDirectives.value
              )
            ])
          ])),

          props.nowBtn === true ? vue.h(QBtn, {
            class: 'q-time__now-button absolute',
            icon: $q.iconSet.datetime.now,
            unelevated: true,
            size: 'sm',
            round: true,
            color: props.color,
            textColor: props.textColor,
            tabindex: tabindex.value,
            onClick: setNow
          }) : null
        ])
      }

      return () => {
        const child = [ getClock() ];

        const def = hSlot(slots.default);
        def !== void 0 && child.push(
          vue.h('div', { class: 'q-time__actions' }, def)
        );

        if (props.name !== void 0 && props.disable !== true) {
          injectFormInput(child, 'push');
        }

        return vue.h('div', {
          class: classes.value,
          tabindex: -1
        }, [
          getHeader(),
          vue.h('div', { class: 'q-time__main col overflow-auto' }, child)
        ])
      }
    }
  });

  var QTimeline = vue.defineComponent({
    name: 'QTimeline',

    props: {
      ...useDarkProps,

      color: {
        type: String,
        default: 'primary'
      },
      side: {
        type: String,
        default: 'right',
        validator: v => [ 'left', 'right' ].includes(v)
      },
      layout: {
        type: String,
        default: 'dense',
        validator: v => [ 'dense', 'comfortable', 'loose' ].includes(v)
      }
    },

    setup (props, { slots }) {
      const vm = vue.getCurrentInstance();
      const isDark = useDark(props, vm.proxy.$q);

      vue.provide(timelineKey, props);

      const classes = vue.computed(() =>
        `q-timeline q-timeline--${ props.layout } q-timeline--${ props.layout }--${ props.side }`
        + (isDark.value === true ? ' q-timeline--dark' : '')
      );

      return () => vue.h('ul', { class: classes.value }, hSlot(slots.default))
    }
  });

  var QTimelineEntry = vue.defineComponent({
    name: 'QTimelineEntry',

    props: {
      heading: Boolean,
      tag: {
        type: String,
        default: 'h3'
      },
      side: {
        type: String,
        default: 'right',
        validator: v => [ 'left', 'right' ].includes(v)
      },

      icon: String,
      avatar: String,

      color: String,

      title: String,
      subtitle: String,
      body: String
    },

    setup (props, { slots }) {
      const $timeline = vue.inject(timelineKey, () => {
        console.error('QTimelineEntry needs to be child of QTimeline');
      });

      const classes = vue.computed(() =>
        `q-timeline__entry q-timeline__entry--${ props.side }`
        + (props.icon !== void 0 || props.avatar !== void 0 ? ' q-timeline__entry--icon' : '')
      );

      const dotClass = vue.computed(() =>
        `q-timeline__dot text-${ props.color || $timeline.color }`
      );

      const reverse = vue.computed(() =>
        $timeline.layout === 'comfortable' && $timeline.side === 'left'
      );

      return () => {
        const child = hUniqueSlot(slots.default, []);

        if (props.body !== void 0) {
          child.unshift(props.body);
        }

        if (props.heading === true) {
          const content = [
            vue.h('div'),
            vue.h('div'),
            vue.h(
              props.tag,
              { class: 'q-timeline__heading-title' },
              child
            )
          ];

          return vue.h('div', {
            class: 'q-timeline__heading'
          }, reverse.value === true ? content.reverse() : content)
        }

        let dot;

        if (props.icon !== void 0) {
          dot = [
            vue.h(QIcon, {
              class: 'row items-center justify-center',
              name: props.icon
            })
          ];
        }
        else if (props.avatar !== void 0) {
          dot = [
            vue.h('img', {
              class: 'q-timeline__dot-img',
              src: props.avatar
            })
          ];
        }

        const content = [
          vue.h('div', { class: 'q-timeline__subtitle' }, [
            vue.h('span', {}, hSlot(slots.subtitle, [ props.subtitle ]))
          ]),

          vue.h('div', { class: dotClass.value }, dot),

          vue.h('div', { class: 'q-timeline__content' }, [
            vue.h('h6', { class: 'q-timeline__title' }, hSlot(slots.title, [ props.title ]))
          ].concat(child))
        ];

        return vue.h('li', {
          class: classes.value
        }, reverse.value === true ? content.reverse() : content)
      }
    }
  });

  var QToolbar = vue.defineComponent({
    name: 'QToolbar',

    props: {
      inset: Boolean
    },

    setup (props, { slots }) {
      const classes = vue.computed(() =>
        'q-toolbar row no-wrap items-center'
        + (props.inset === true ? ' q-toolbar--inset' : '')
      );

      return () => vue.h('div', { class: classes.value }, hSlot(slots.default))
    }
  });

  var QToolbarTitle = vue.defineComponent({
    name: 'QToolbarTitle',

    props: {
      shrink: Boolean
    },

    setup (props, { slots }) {
      const classes = vue.computed(() =>
        'q-toolbar__title ellipsis'
        + (props.shrink === true ? ' col-shrink' : '')
      );

      return () => vue.h('div', { class: classes.value }, hSlot(slots.default))
    }
  });

  var QTree = vue.defineComponent({
    name: 'QTree',

    props: {
      ...useDarkProps,

      nodes: {
        type: Array,
        required: true
      },
      nodeKey: {
        type: String,
        required: true
      },
      labelKey: {
        type: String,
        default: 'label'
      },
      childrenKey: {
        type: String,
        default: 'children'
      },

      color: String,
      controlColor: String,
      textColor: String,
      selectedColor: String,

      icon: String,

      tickStrategy: {
        type: String,
        default: 'none',
        validator: v => [ 'none', 'strict', 'leaf', 'leaf-filtered' ].includes(v)
      },
      ticked: Array, // v-model:ticked
      expanded: Array, // v-model:expanded
      selected: {}, // v-model:selected

      defaultExpandAll: Boolean,
      accordion: Boolean,

      filter: String,
      filterMethod: Function,

      duration: Number,
      noConnectors: Boolean,

      noNodesLabel: String,
      noResultsLabel: String
    },

    emits: [
      'update:expanded',
      'update:ticked',
      'update:selected',
      'lazy-load',
      'after-show',
      'after-hide'
    ],

    setup (props, { slots, emit }) {
      const { proxy } = vue.getCurrentInstance();
      const { $q } = proxy;

      const isDark = useDark(props, $q);

      const lazy = vue.ref({});
      const innerTicked = vue.ref(props.ticked || []);
      const innerExpanded = vue.ref(props.expanded || []);

      let blurTargets = {};

      vue.onBeforeUpdate(() => {
        blurTargets = {};
      });

      const classes = vue.computed(() =>
        'q-tree'
        + (props.noConnectors === true ? ' q-tree--no-connectors' : '')
        + (isDark.value === true ? ' q-tree--dark' : '')
        + (props.color !== void 0 ? ` text-${ props.color }` : '')
      );

      const hasSelection = vue.computed(() => props.selected !== void 0);

      const computedIcon = vue.computed(() => props.icon || $q.iconSet.tree.icon);

      const computedControlColor = vue.computed(() => props.controlColor || props.color);

      const textColorClass = vue.computed(() => (
        props.textColor !== void 0
          ? ` text-${ props.textColor }`
          : ''
      ));

      const selectedColorClass = vue.computed(() => {
        const color = props.selectedColor || props.color;
        return color ? ` text-${ color }` : ''
      });

      const computedFilterMethod = vue.computed(() => (
        props.filterMethod !== void 0
          ? props.filterMethod
          : (node, filter) => {
              const filt = filter.toLowerCase();
              return node[ props.labelKey ]
              && node[ props.labelKey ].toLowerCase().indexOf(filt) > -1
            }
      ));

      const meta = vue.computed(() => {
        const meta = {};

        const travel = (node, parent) => {
          const tickStrategy = node.tickStrategy || (parent ? parent.tickStrategy : props.tickStrategy);
          const
            key = node[ props.nodeKey ],
            isParent = node[ props.childrenKey ] && node[ props.childrenKey ].length > 0,
            isLeaf = isParent !== true,
            selectable = node.disabled !== true && hasSelection.value === true && node.selectable !== false,
            expandable = node.disabled !== true && node.expandable !== false,
            hasTicking = tickStrategy !== 'none',
            strictTicking = tickStrategy === 'strict',
            leafFilteredTicking = tickStrategy === 'leaf-filtered',
            leafTicking = tickStrategy === 'leaf' || tickStrategy === 'leaf-filtered';

          let tickable = node.disabled !== true && node.tickable !== false;
          if (leafTicking === true && tickable === true && parent && parent.tickable !== true) {
            tickable = false;
          }

          let localLazy = node.lazy;
          if (
            localLazy === true
            && lazy.value[ key ] !== void 0
            && Array.isArray(node[ props.childrenKey ]) === true
          ) {
            localLazy = lazy.value[ key ];
          }

          const m = {
            key,
            parent,
            isParent,
            isLeaf,
            lazy: localLazy,
            disabled: node.disabled,
            link: node.disabled !== true && (selectable === true || (expandable === true && (isParent === true || localLazy === true))),
            children: [],
            matchesFilter: props.filter ? computedFilterMethod.value(node, props.filter) : true,

            selected: key === props.selected && selectable === true,
            selectable,
            expanded: isParent === true ? innerExpanded.value.includes(key) : false,
            expandable,
            noTick: node.noTick === true || (strictTicking !== true && localLazy && localLazy !== 'loaded'),
            tickable,
            tickStrategy,
            hasTicking,
            strictTicking,
            leafFilteredTicking,
            leafTicking,
            ticked: strictTicking === true
              ? innerTicked.value.includes(key)
              : (isLeaf === true ? innerTicked.value.includes(key) : false)
          };

          meta[ key ] = m;

          if (isParent === true) {
            m.children = node[ props.childrenKey ].map(n => travel(n, m));

            if (props.filter) {
              if (m.matchesFilter !== true) {
                m.matchesFilter = m.children.some(n => n.matchesFilter);
              }
              else if (
                m.noTick !== true
                && m.disabled !== true
                && m.tickable === true
                && leafFilteredTicking === true
                && m.children.every(n => n.matchesFilter !== true || n.noTick === true || n.tickable !== true) === true
              ) {
                m.tickable = false;
              }
            }

            if (m.matchesFilter === true) {
              if (m.noTick !== true && strictTicking !== true && m.children.every(n => n.noTick) === true) {
                m.noTick = true;
              }

              if (leafTicking) {
                m.ticked = false;
                m.indeterminate = m.children.some(node => node.indeterminate === true);
                m.tickable = m.tickable === true && m.children.some(node => node.tickable);

                if (m.indeterminate !== true) {
                  const sel = m.children
                    .reduce((acc, meta) => (meta.ticked === true ? acc + 1 : acc), 0);

                  if (sel === m.children.length) {
                    m.ticked = true;
                  }
                  else if (sel > 0) {
                    m.indeterminate = true;
                  }
                }

                if (m.indeterminate === true) {
                  m.indeterminateNextState = m.children
                    .every(meta => meta.tickable !== true || meta.ticked !== true);
                }
              }
            }
          }

          return m
        };

        props.nodes.forEach(node => travel(node, null));
        return meta
      });

      vue.watch(() => props.ticked, val => {
        innerTicked.value = val;
      });

      vue.watch(() => props.expanded, val => {
        innerExpanded.value = val;
      });

      function getNodeByKey (key) {
        const reduce = [].reduce;

        const find = (result, node) => {
          if (result || !node) {
            return result
          }
          if (Array.isArray(node) === true) {
            return reduce.call(Object(node), find, result)
          }
          if (node[ props.nodeKey ] === key) {
            return node
          }
          if (node[ props.childrenKey ]) {
            return find(null, node[ props.childrenKey ])
          }
        };

        return find(null, props.nodes)
      }

      function getTickedNodes () {
        return innerTicked.value.map(key => getNodeByKey(key))
      }

      function getExpandedNodes () {
        return innerExpanded.value.map(key => getNodeByKey(key))
      }

      function isExpanded (key) {
        return key && meta.value[ key ]
          ? meta.value[ key ].expanded
          : false
      }

      function collapseAll () {
        if (props.expanded !== void 0) {
          emit('update:expanded', []);
        }
        else {
          innerExpanded.value = [];
        }
      }

      function expandAll () {
        const
          expanded = innerExpanded.value,
          travel = node => {
            if (node[ props.childrenKey ] && node[ props.childrenKey ].length > 0) {
              if (node.expandable !== false && node.disabled !== true) {
                expanded.push(node[ props.nodeKey ]);
                node[ props.childrenKey ].forEach(travel);
              }
            }
          };

        props.nodes.forEach(travel);

        if (props.expanded !== void 0) {
          emit('update:expanded', expanded);
        }
        else {
          innerExpanded.value = expanded;
        }
      }

      function setExpanded (key, state, node = getNodeByKey(key), m = meta.value[ key ]) {
        if (m.lazy && m.lazy !== 'loaded') {
          if (m.lazy === 'loading') {
            return
          }

          lazy.value[ key ] = 'loading';
          if (Array.isArray(node[ props.childrenKey ]) !== true) {
            node[ props.childrenKey ] = [];
          }
          emit('lazy-load', {
            node,
            key,
            done: children => {
              lazy.value[ key ] = 'loaded';
              node[ props.childrenKey ] = Array.isArray(children) === true ? children : [];
              vue.nextTick(() => {
                const localMeta = meta.value[ key ];
                if (localMeta && localMeta.isParent === true) {
                  localSetExpanded(key, true);
                }
              });
            },
            fail: () => {
              delete lazy.value[ key ];
              if (node[ props.childrenKey ].length === 0) {
                delete node[ props.childrenKey ];
              }
            }
          });
        }
        else if (m.isParent === true && m.expandable === true) {
          localSetExpanded(key, state);
        }
      }

      function localSetExpanded (key, state) {
        let target = innerExpanded.value;
        const shouldEmit = props.expanded !== void 0;

        if (shouldEmit === true) {
          target = target.slice();
        }

        if (state) {
          if (props.accordion) {
            if (meta.value[ key ]) {
              const collapse = [];
              if (meta.value[ key ].parent) {
                meta.value[ key ].parent.children.forEach(m => {
                  if (m.key !== key && m.expandable === true) {
                    collapse.push(m.key);
                  }
                });
              }
              else {
                props.nodes.forEach(node => {
                  const k = node[ props.nodeKey ];
                  if (k !== key) {
                    collapse.push(k);
                  }
                });
              }
              if (collapse.length > 0) {
                target = target.filter(k => collapse.includes(k) === false);
              }
            }
          }

          target = target.concat([ key ])
            .filter((key, index, self) => self.indexOf(key) === index);
        }
        else {
          target = target.filter(k => k !== key);
        }

        if (shouldEmit === true) {
          emit('update:expanded', target);
        }
        else {
          innerExpanded.value = target;
        }
      }

      function isTicked (key) {
        return key && meta.value[ key ]
          ? meta.value[ key ].ticked
          : false
      }

      function setTicked (keys, state) {
        let target = innerTicked.value;
        const shouldEmit = props.ticked !== void 0;

        if (shouldEmit === true) {
          target = target.slice();
        }

        if (state) {
          target = target.concat(keys)
            .filter((key, index, self) => self.indexOf(key) === index);
        }
        else {
          target = target.filter(k => keys.includes(k) === false);
        }

        if (shouldEmit === true) {
          emit('update:ticked', target);
        }
      }

      function getSlotScope (node, meta, key) {
        const scope = { tree: proxy, node, key, color: props.color, dark: isDark.value };

        Object.defineProperty(scope, 'expanded', {
          get: () => { return meta.expanded },
          set: val => { val !== meta.expanded && setExpanded(key, val); },
          configurable: true,
          enumerable: true
        });
        Object.defineProperty(scope, 'ticked', {
          get: () => { return meta.ticked },
          set: val => { val !== meta.ticked && setTicked([ key ], val); },
          configurable: true,
          enumerable: true
        });

        return scope
      }

      function getChildren (nodes) {
        return (
          props.filter
            ? nodes.filter(n => meta.value[ n[ props.nodeKey ] ].matchesFilter)
            : nodes
        ).map(child => getNode(child))
      }

      function getNodeMedia (node) {
        if (node.icon !== void 0) {
          return vue.h(QIcon, {
            class: 'q-tree__icon q-mr-sm',
            name: node.icon,
            color: node.iconColor
          })
        }
        const src = node.img || node.avatar;
        if (src) {
          return vue.h('img', {
            class: `q-tree__${ node.img ? 'img' : 'avatar' } q-mr-sm`,
            src
          })
        }
      }

      function onShow () {
        emit('after-show');
      }

      function onHide () {
        emit('after-hide');
      }

      function getNode (node) {
        const
          key = node[ props.nodeKey ],
          m = meta.value[ key ],
          header = node.header
            ? slots[ `header-${ node.header }` ] || slots[ 'default-header' ]
            : slots[ 'default-header' ];

        const children = m.isParent === true
          ? getChildren(node[ props.childrenKey ])
          : [];

        const isParent = children.length > 0 || (m.lazy && m.lazy !== 'loaded');

        let body = node.body
          ? slots[ `body-${ node.body }` ] || slots[ 'default-body' ]
          : slots[ 'default-body' ];
        const slotScope = header !== void 0 || body !== void 0
          ? getSlotScope(node, m, key)
          : null;

        if (body !== void 0) {
          body = vue.h('div', { class: 'q-tree__node-body relative-position' }, [
            vue.h('div', { class: textColorClass.value }, [
              body(slotScope)
            ])
          ]);
        }

        return vue.h('div', {
          key,
          class: 'q-tree__node relative-position'
            + ` q-tree__node--${ isParent === true ? 'parent' : 'child' }`
        }, [
          vue.h('div', {
            class: 'q-tree__node-header relative-position row no-wrap items-center'
              + (m.link === true ? ' q-tree__node--link q-hoverable q-focusable' : '')
              + (m.selected === true ? ' q-tree__node--selected' : '')
              + (m.disabled === true ? ' q-tree__node--disabled' : ''),
            tabindex: m.link === true ? 0 : -1,
            onClick: (e) => {
              onClick(node, m, e);
            },
            onKeypress (e) {
              if (shouldIgnoreKey(e) !== true) {
                if (e.keyCode === 13) { onClick(node, m, e, true); }
                else if (e.keyCode === 32) { onExpandClick(node, m, e, true); }
              }
            }
          }, [
            vue.h('div', {
              class: 'q-focus-helper',
              tabindex: -1,
              ref: el => { blurTargets[ m.key ] = el; }
            }),

            m.lazy === 'loading'
              ? vue.h(QSpinner, {
                  class: 'q-tree__spinner q-mr-xs',
                  color: computedControlColor.value
                })
              : (
                  isParent === true
                    ? vue.h(QIcon, {
                        class: 'q-tree__arrow q-mr-xs'
                      + (m.expanded === true ? ' q-tree__arrow--rotate' : ''),
                        name: computedIcon.value,
                        onClick (e) { onExpandClick(node, m, e); }
                      })
                    : null
                ),

            m.hasTicking === true && m.noTick !== true
              ? vue.h(QCheckbox, {
                  class: 'q-mr-xs',
                  modelValue: m.indeterminate === true ? null : m.ticked,
                  color: computedControlColor.value,
                  dark: isDark.value,
                  dense: true,
                  keepColor: true,
                  disable: m.tickable !== true,
                  onKeydown: stopAndPrevent,
                  'onUpdate:modelValue': v => {
                    onTickedClick(m, v);
                  }
                })
              : null,

            vue.h('div', {
              class: 'q-tree__node-header-content col row no-wrap items-center'
                + (m.selected === true ? selectedColorClass.value : textColorClass.value)
            }, [
              header
                ? header(slotScope)
                : [
                    getNodeMedia(node),
                    vue.h('div', node[ props.labelKey ])
                  ]
            ])
          ]),

          isParent === true
            ? vue.h(QSlideTransition, {
                duration: props.duration,
                onShow,
                onHide
              }, () => vue.withDirectives(
                vue.h('div', {
                  class: 'q-tree__node-collapsible' + textColorClass.value,
                  key: `${ key }__q`
                }, [
                  body,
                  vue.h('div', {
                    class: 'q-tree__children'
                    + (m.disabled === true ? ' q-tree__node--disabled' : '')
                  }, children)
                ]),
                [ [ vue.vShow, m.expanded ] ]
              ))
            : body
        ])
      }

      function blur (key) {
        const blurTarget = blurTargets[ key ];
        blurTarget && blurTarget.focus();
      }

      function onClick (node, meta, e, keyboard) {
        keyboard !== true && blur(meta.key);

        if (hasSelection.value) {
          if (meta.selectable) {
            emit('update:selected', meta.key !== props.selected ? meta.key : null);
          }
        }
        else {
          onExpandClick(node, meta, e, keyboard);
        }

        if (typeof node.handler === 'function') {
          node.handler(node);
        }
      }

      function onExpandClick (node, meta, e, keyboard) {
        if (e !== void 0) {
          stopAndPrevent(e);
        }
        keyboard !== true && blur(meta.key);
        setExpanded(meta.key, !meta.expanded, node, meta);
      }

      function onTickedClick (meta, state) {
        if (meta.indeterminate === true) {
          state = meta.indeterminateNextState;
        }
        if (meta.strictTicking) {
          setTicked([ meta.key ], state);
        }
        else if (meta.leafTicking) {
          const keys = [];
          const travel = meta => {
            if (meta.isParent) {
              if (state !== true && meta.noTick !== true && meta.tickable === true) {
                keys.push(meta.key);
              }
              if (meta.leafTicking === true) {
                meta.children.forEach(travel);
              }
            }
            else if (
              meta.noTick !== true
              && meta.tickable === true
              && (meta.leafFilteredTicking !== true || meta.matchesFilter === true)
            ) {
              keys.push(meta.key);
            }
          };
          travel(meta);
          setTicked(keys, state);
        }
      }

      // expose public methods
      Object.assign(proxy, {
        getNodeByKey,
        getTickedNodes,
        getExpandedNodes,
        isExpanded,
        collapseAll,
        expandAll,
        setExpanded,
        isTicked,
        setTicked
      });

      props.defaultExpandAll === true && expandAll();

      return () => {
        const children = getChildren(props.nodes);

        return vue.h(
          'div', {
            class: classes.value
          },
          children.length === 0
            ? (
                props.filter
                  ? props.noResultsLabel || $q.lang.tree.noResults
                  : props.noNodesLabel || $q.lang.tree.noNodes
              )
            : children
        )
      }
    }
  });

  function getProgressLabel (p) {
    return (p * 100).toFixed(2) + '%'
  }

  const coreProps = {
    ...useDarkProps,
    ...useFileProps,

    label: String,

    color: String,
    textColor: String,

    square: Boolean,
    flat: Boolean,
    bordered: Boolean,

    noThumbnails: Boolean,
    autoUpload: Boolean,
    hideUploadBtn: Boolean,

    disable: Boolean,
    readonly: Boolean
  };

  const coreEmits = [
    ...useFileEmits,
    'start', 'finish', 'added', 'removed'
  ];

  function getRenderer (getPlugin) {
    const vm = vue.getCurrentInstance();
    const { props, slots, emit, proxy } = vm;
    const { $q } = proxy;

    const isDark = useDark(props, $q);

    function updateFileStatus (file, status, uploadedSize) {
      file.__status = status;

      if (status === 'idle') {
        file.__uploaded = 0;
        file.__progress = 0;
        file.__sizeLabel = humanStorageSize(file.size);
        file.__progressLabel = '0.00%';
        return
      }
      if (status === 'failed') {
        proxy.$forceUpdate();
        return
      }

      file.__uploaded = status === 'uploaded'
        ? file.size
        : uploadedSize;

      file.__progress = status === 'uploaded'
        ? 1
        : Math.min(0.9999, file.__uploaded / file.size);

      file.__progressLabel = getProgressLabel(file.__progress);
      proxy.$forceUpdate();
    }

    const state = {
      files: vue.ref([]),
      queuedFiles: vue.ref([]),
      uploadedFiles: vue.ref([]),
      uploadedSize: vue.ref(0),

      updateFileStatus,
      isAlive () {
        return vm.isDeactivated !== true && vm.isUnmounted !== true
      }
    };

    Object.assign(state, getPlugin({ props, slots, emit, helpers: state }));

    const uploadSize = vue.ref(0);
    const editable = vue.computed(() => props.disable !== true && props.readonly !== true);

    if (state.isBusy === void 0) {
      state.isBusy = vue.ref(false);
    }

    const dnd = vue.ref(false);

    const rootRef = vue.ref(null);
    const inputRef = vue.ref(null);

    vue.provide(uploaderKey, renderInput);

    const {
      pickFiles,
      addFiles,
      onDragover,
      processFiles,
      getDndNode,
      maxFilesNumber,
      maxTotalSizeNumber
    } = useFile({ editable, dnd, getFileInput, addFilesToQueue });

    const canAddFiles = vue.computed(() =>
      editable.value === true
      && state.isUploading.value !== true
      // if single selection and no files are queued:
      && (props.multiple === true || state.queuedFiles.value.length === 0)
      // if max-files is set and current number of files does not exceeds it:
      && (props.maxFiles === void 0 || state.files.value.length < maxFilesNumber.value)
      // if max-total-size is set and current upload size does not exceeds it:
      && (props.maxTotalSize === void 0 || uploadSize.value < maxTotalSizeNumber.value)
    );

    const canUpload = vue.computed(() =>
      editable.value === true
      && state.isBusy.value !== true
      && state.isUploading.value !== true
      && state.queuedFiles.value.length > 0
    );

    const uploadProgress = vue.computed(() => (
      uploadSize.value === 0
        ? 0
        : state.uploadedSize.value / uploadSize.value
    ));

    const uploadProgressLabel = vue.computed(() => getProgressLabel(uploadProgress.value));
    const uploadSizeLabel = vue.computed(() => humanStorageSize(uploadSize.value));

    const classes = vue.computed(() =>
      'q-uploader column no-wrap'
      + (isDark.value === true ? ' q-uploader--dark q-dark' : '')
      + (props.bordered === true ? ' q-uploader--bordered' : '')
      + (props.square === true ? ' q-uploader--square no-border-radius' : '')
      + (props.flat === true ? ' q-uploader--flat no-shadow' : '')
      + (props.disable === true ? ' disabled q-uploader--disable' : '')
    );

    const colorClass = vue.computed(() =>
      'q-uploader__header'
      + (props.color !== void 0 ? ` bg-${ props.color }` : '')
      + (props.textColor !== void 0 ? ` text-${ props.textColor }` : '')
    );

    vue.watch(state.isUploading, (newVal, oldVal) => {
      if (oldVal === false && newVal === true) {
        emit('start');
      }
      else if (oldVal === true && newVal === false) {
        emit('finish');
      }
    });

    function reset () {
      if (props.disable === false) {
        state.abort();
        state.uploadedSize.value = 0;
        uploadSize.value = 0;
        revokeImgURLs();
        state.files.value = [];
        state.queuedFiles.value = [];
        state.uploadedFiles.value = [];
      }
    }

    function removeUploadedFiles () {
      if (props.disable === false) {
        batchRemoveFiles([ 'uploaded' ], () => {
          state.uploadedFiles.value = [];
        });
      }
    }

    function removeQueuedFiles () {
      batchRemoveFiles([ 'idle', 'failed' ], ({ size }) => {
        uploadSize.value -= size;
        state.queuedFiles.value = [];
      });
    }

    function batchRemoveFiles (statusList, cb) {
      if (props.disable === true) {
        return
      }

      const removed = {
        files: [],
        size: 0
      };

      const localFiles = state.files.value.filter(f => {
        if (statusList.indexOf(f.__status) === -1) {
          return true
        }

        removed.size += f.size;
        removed.files.push(f);

        f._img !== void 0 && window.URL.revokeObjectURL(f._img.src);

        return false
      });

      if (removed.files.length > 0) {
        state.files.value = localFiles;
        cb(removed);
        emit('removed', removed.files);
      }
    }

    function removeFile (file) {
      if (props.disable) { return }

      if (file.__status === 'uploaded') {
        state.uploadedFiles.value = state.uploadedFiles.value.filter(f => f.name !== file.name);
      }
      else if (file.__status === 'uploading') {
        file.__abort();
      }
      else {
        uploadSize.value -= file.size;
      }

      state.files.value = state.files.value.filter(f => {
        if (f.name !== file.name) {
          return true
        }

        f._img !== void 0 && window.URL.revokeObjectURL(f._img.src);

        return false
      });
      state.queuedFiles.value = state.queuedFiles.value.filter(f => f.name !== file.name);
      emit('removed', [ file ]);
    }

    function revokeImgURLs () {
      state.files.value.forEach(f => {
        f._img !== void 0 && window.URL.revokeObjectURL(f._img.src);
      });
    }

    function getFileInput () {
      return inputRef.value
        || rootRef.value.getElementsByClassName('q-uploader__input')[ 0 ]
    }

    function addFilesToQueue (e, fileList) {
      const processedFiles = processFiles(e, fileList, state.files.value, true);

      if (processedFiles === void 0) { return }

      const localFiles = processedFiles
        .filter(file => state.files.value.findIndex(f => file.name === f.name) === -1);

      const fileInput = getFileInput();
      if (fileInput !== void 0 && fileInput !== null) {
        fileInput.value = '';
      }

      if (localFiles === void 0) { return }

      localFiles.forEach(file => {
        state.updateFileStatus(file, 'idle');
        uploadSize.value += file.size;

        if (props.noThumbnails !== true && file.type.toUpperCase().startsWith('IMAGE')) {
          const img = new Image();
          img.src = window.URL.createObjectURL(file);
          file.__img = img;
        }
      });

      state.files.value = state.files.value.concat(localFiles);
      state.queuedFiles.value = state.queuedFiles.value.concat(localFiles);
      emit('added', localFiles);
      props.autoUpload === true && state.upload();
    }

    function upload () {
      canUpload.value === true && state.upload();
    }

    function getBtn (show, icon, fn) {
      if (show === true) {
        const data = {
          type: 'a',
          key: icon,
          icon: $q.iconSet.uploader[ icon ],
          flat: true,
          dense: true
        };

        let child = void 0;

        if (icon === 'add') {
          child = renderInput;
        }
        else {
          data.onClick = fn;
        }

        return vue.h(QBtn, data, child)
      }
    }

    function renderInput () {
      return vue.h('input', {
        ref: inputRef,
        class: 'q-uploader__input overflow-hidden absolute-full',
        tabindex: -1,
        type: 'file',
        title: '', // try to remove default tooltip
        accept: props.accept,
        multiple: props.multiple === true ? 'multiple' : void 0,
        capture: props.capture,
        onMousedown: stop, // need to stop refocus from QBtn
        onChange: addFilesToQueue
      })
    }

    function getHeader () {
      if (slots.header !== void 0) {
        return slots.header(slotScope.value)
      }

      return [
        vue.h('div', {
          class: 'q-uploader__header-content flex flex-center no-wrap q-gutter-xs'
        }, [
          getBtn(state.queuedFiles.value.length > 0, 'removeQueue', removeQueuedFiles),
          getBtn(state.uploadedFiles.value.length > 0, 'removeUploaded', removeUploadedFiles),

          state.isUploading.value === true
            ? vue.h(QSpinner, { class: 'q-uploader__spinner' })
            : null,

          vue.h('div', { class: 'col column justify-center' }, [
            props.label !== void 0
              ? vue.h('div', { class: 'q-uploader__title' }, [ props.label ])
              : null,

            vue.h('div', { class: 'q-uploader__subtitle' }, [
              uploadSizeLabel.value + ' / ' + uploadProgressLabel.value
            ])
          ]),

          getBtn(canAddFiles.value, 'add'),
          getBtn(props.hideUploadBtn === false && canUpload.value === true, 'upload', state.upload),
          getBtn(state.isUploading.value, 'clear', state.abort)
        ])
      ]
    }

    function getList () {
      if (slots.list !== void 0) {
        return slots.list(slotScope.value)
      }

      return state.files.value.map(file => vue.h('div', {
        key: file.name,
        class: 'q-uploader__file relative-position'
          + (props.noThumbnails !== true && file.__img !== void 0 ? ' q-uploader__file--img' : '')
          + (
            file.__status === 'failed'
              ? ' q-uploader__file--failed'
              : (file.__status === 'uploaded' ? ' q-uploader__file--uploaded' : '')
          ),
        style: props.noThumbnails !== true && file.__img !== void 0
          ? { backgroundImage: 'url("' + file.__img.src + '")' }
          : null
      }, [
        vue.h('div', {
          class: 'q-uploader__file-header row flex-center no-wrap'
        }, [
          file.__status === 'failed'
            ? vue.h(QIcon, {
                class: 'q-uploader__file-status',
                name: $q.iconSet.type.negative,
                color: 'negative'
              })
            : null,

          vue.h('div', { class: 'q-uploader__file-header-content col' }, [
            vue.h('div', { class: 'q-uploader__title' }, [ file.name ]),
            vue.h('div', {
              class: 'q-uploader__subtitle row items-center no-wrap'
            }, [
              file.__sizeLabel + ' / ' + file.__progressLabel
            ])
          ]),

          file.__status === 'uploading'
            ? vue.h(QCircularProgress, {
                value: file.__progress,
                min: 0,
                max: 1,
                indeterminate: file.__progress === 0
              })
            : vue.h(QBtn, {
              round: true,
              dense: true,
              flat: true,
              icon: $q.iconSet.uploader[ file.__status === 'uploaded' ? 'done' : 'clear' ],
              onClick: () => { removeFile(file); }
            })
        ])
      ]))
    }

    vue.onBeforeUnmount(() => {
      state.isUploading.value === true && state.abort();
      state.files.value.length > 0 && revokeImgURLs();
    });

    const publicMethods = {
      pickFiles,
      addFiles,
      reset,
      removeUploadedFiles,
      removeQueuedFiles,
      removeFile,
      upload,
      abort: state.abort
    };

    const slotScope = vue.computed(() => {
      const acc = {
        canAddFiles: canAddFiles.value,
        canUpload: canUpload.value,
        uploadSizeLabel: uploadSizeLabel.value,
        uploadProgressLabel: uploadProgressLabel.value
      };

      Object.keys(state).forEach(key => {
        acc[ key ] = vue.isRef(state[ key ]) === true
          ? state[ key ].value
          : state[ key ];
      });
      return { ...acc, ...publicMethods }
    });

    // expose public methods
    Object.assign(proxy, publicMethods);

    return () => {
      const children = [
        vue.h('div', { class: colorClass.value }, getHeader()),
        vue.h('div', { class: 'q-uploader__list scroll' }, getList()),
        getDndNode('uploader')
      ];

      state.isBusy.value === true && children.push(
        vue.h('div', {
          class: 'q-uploader__overlay absolute-full flex flex-center'
        }, [ vue.h(QSpinner) ])
      );

      const data = { ref: rootRef, class: classes.value };

      if (canAddFiles.value === true) {
        data.onDragover = onDragover;
      }

      return vue.h('div', data, children)
    }
  }

  var createUploaderComponent = ({ name, props, emits, injectPlugin }) => vue.defineComponent({
    name,

    props: {
      ...coreProps,
      ...props
    },

    emits: [
      ...coreEmits,
      ...emits
    ],

    setup () {
      return getRenderer(injectPlugin)
    }
  });

  function getFn (prop) {
    return typeof prop === 'function'
      ? prop
      : () => prop
  }

  const props$2 = {
    url: [ Function, String ],
    method: {
      type: [ Function, String ],
      default: 'POST'
    },
    fieldName: {
      type: [ Function, String ],
      default: file => file.name
    },
    headers: [ Function, Array ],
    formFields: [ Function, Array ],
    withCredentials: [ Function, Boolean ],
    sendRaw: [ Function, Boolean ],

    batch: [ Function, Boolean ],
    factory: Function
  };

  const emits = [ 'factory-failed', 'uploaded', 'failed', 'uploading' ];

  function injectPlugin ({ props, emit, helpers }) {
    const xhrs = vue.ref([]);
    const promises = vue.ref([]);
    const workingThreads = vue.ref(0);

    const xhrProps = vue.computed(() => ({
      url: getFn(props.url),
      method: getFn(props.method),
      headers: getFn(props.headers),
      formFields: getFn(props.formFields),
      fieldName: getFn(props.fieldName),
      withCredentials: getFn(props.withCredentials),
      sendRaw: getFn(props.sendRaw),
      batch: getFn(props.batch)
    }));

    const isUploading = vue.computed(() => workingThreads.value > 0);
    const isBusy = vue.computed(() => promises.value.length > 0);

    let abortPromises;

    function abort () {
      xhrs.value.forEach(x => { x.abort(); });

      if (promises.value.length > 0) {
        abortPromises = true;
      }
    }

    function upload () {
      const queue = helpers.queuedFiles.value.slice(0);
      helpers.queuedFiles.value = [];

      if (xhrProps.value.batch(queue)) {
        runFactory(queue);
      }
      else {
        queue.forEach(file => {
          runFactory([ file ]);
        });
      }
    }

    function runFactory (files) {
      workingThreads.value++;

      if (typeof props.factory !== 'function') {
        performUpload(files, {});
        return
      }

      const res = props.factory(files);

      if (!res) {
        emit(
          'factory-failed',
          new Error('QUploader: factory() does not return properly'),
          files
        );
        workingThreads.value--;
      }
      else if (typeof res.catch === 'function' && typeof res.then === 'function') {
        promises.value.push(res);

        const failed = err => {
          if (helpers.isAlive() === true) {
            promises.value = promises.value.filter(p => p !== res);

            if (promises.value.length === 0) {
              abortPromises = false;
            }

            helpers.queuedFiles.value = helpers.queuedFiles.value.concat(files);
            files.forEach(f => { helpers.updateFileStatus(f, 'failed'); });

            emit('factory-failed', err, files);
            workingThreads.value--;
          }
        };

        res.then(factory => {
          if (abortPromises === true) {
            failed(new Error('Aborted'));
          }
          else if (helpers.isAlive() === true) {
            promises.value = promises.value.filter(p => p !== res);
            performUpload(files, factory);
          }
        }).catch(failed);
      }
      else {
        performUpload(files, res || {});
      }
    }

    function performUpload (files, factory) {
      const
        form = new FormData(),
        xhr = new XMLHttpRequest();

      const getProp = (name, arg) => {
        return factory[ name ] !== void 0
          ? getFn(factory[ name ])(arg)
          : xhrProps.value[ name ](arg)
      };

      const url = getProp('url', files);

      if (!url) {
        console.error('q-uploader: invalid or no URL specified');
        workingThreads.value--;
        return
      }

      const fields = getProp('formFields', files);
      fields !== void 0 && fields.forEach(field => {
        form.append(field.name, field.value);
      });

      let
        uploadIndex = 0,
        uploadIndexSize = 0,
        localUploadedSize = 0,
        maxUploadSize = 0,
        aborted;

      xhr.upload.addEventListener('progress', e => {
        if (aborted === true) { return }

        const loaded = Math.min(maxUploadSize, e.loaded);

        helpers.uploadedSize.value += loaded - localUploadedSize;
        localUploadedSize = loaded;

        let size = localUploadedSize - uploadIndexSize;
        for (let i = uploadIndex; size > 0 && i < files.length; i++) {
          const
            file = files[ i ],
            uploaded = size > file.size;

          if (uploaded) {
            size -= file.size;
            uploadIndex++;
            uploadIndexSize += file.size;
            helpers.updateFileStatus(file, 'uploading', file.size);
          }
          else {
            helpers.updateFileStatus(file, 'uploading', size);
            return
          }
        }
      }, false);

      xhr.onreadystatechange = () => {
        if (xhr.readyState < 4) {
          return
        }

        if (xhr.status && xhr.status < 400) {
          helpers.uploadedFiles.value = helpers.uploadedFiles.value.concat(files);
          files.forEach(f => { helpers.updateFileStatus(f, 'uploaded'); });
          emit('uploaded', { files, xhr });
        }
        else {
          aborted = true;
          helpers.uploadedSize.value -= localUploadedSize;
          helpers.queuedFiles.value = helpers.queuedFiles.value.concat(files);
          files.forEach(f => { helpers.updateFileStatus(f, 'failed'); });
          emit('failed', { files, xhr });
        }

        workingThreads.value--;
        xhrs.value = xhrs.value.filter(x => x !== xhr);
      };

      xhr.open(
        getProp('method', files),
        url
      );

      if (getProp('withCredentials', files) === true) {
        xhr.withCredentials = true;
      }

      const headers = getProp('headers', files);
      headers !== void 0 && headers.forEach(head => {
        xhr.setRequestHeader(head.name, head.value);
      });

      const sendRaw = getProp('sendRaw', files);

      files.forEach(file => {
        helpers.updateFileStatus(file, 'uploading', 0);
        if (sendRaw !== true) {
          form.append(getProp('fieldName', file), file, file.name);
        }
        file.xhr = xhr;
        file.__abort = () => { xhr.abort(); };
        maxUploadSize += file.size;
      });

      emit('uploading', { files, xhr });
      xhrs.value.push(xhr);

      if (sendRaw === true) {
        xhr.send(new Blob(files));
      }
      else {
        xhr.send(form);
      }
    }

    return {
      isUploading,
      isBusy,

      abort,
      upload
    }
  }

  var xhrUploaderPlugin = {
    name: 'QUploader',
    props: props$2,
    emits,
    injectPlugin
  };

  var QUploader = createUploaderComponent(xhrUploaderPlugin);

  var QUploaderAddTrigger = vue.defineComponent({
    name: 'QUploaderAddTrigger',

    setup () {
      return vue.inject(uploaderKey, () => {
        console.error('QUploaderAddTrigger needs to be child of QUploader');
      })
    }
  });

  var QVideo = vue.defineComponent({
    name: 'QVideo',

    props: {
      ...useRatioProps,

      src: {
        type: String,
        required: true
      }
    },

    setup (props) {
      const ratioStyle = useRatio(props);

      const classes = vue.computed(() =>
        'q-video'
        + (props.ratio !== void 0 ? ' q-video--responsive' : '')
      );

      return () => vue.h('div', {
        class: classes.value,
        style: ratioStyle.value
      }, [
        vue.h('iframe', {
          src: props.src,
          frameborder: '0',
          allowfullscreen: true
        })
      ])
    }
  });

  var components = /*#__PURE__*/Object.freeze({
    __proto__: null,
    QAjaxBar: QAjaxBar,
    QAvatar: QAvatar,
    QBadge: QBadge,
    QBanner: QBanner,
    QBar: QBar,
    QBreadcrumbs: QBreadcrumbs,
    QBreadcrumbsEl: QBreadcrumbsEl,
    QBtn: QBtn,
    QBtnDropdown: QBtnDropdown,
    QBtnGroup: QBtnGroup,
    QBtnToggle: QBtnToggle,
    QCard: QCard,
    QCardSection: QCardSection,
    QCardActions: QCardActions,
    QCarousel: QCarousel,
    QCarouselSlide: QCarouselSlide,
    QCarouselControl: QCarouselControl,
    QChatMessage: QChatMessage,
    QCheckbox: QCheckbox,
    QChip: QChip,
    QCircularProgress: QCircularProgress,
    QColor: QColor,
    QDate: QDate,
    QDialog: QDialog,
    QDrawer: QDrawer,
    QEditor: QEditor,
    QExpansionItem: QExpansionItem,
    QFab: QFab,
    QFabAction: QFabAction,
    QField: QField,
    QFile: QFile,
    QFooter: QFooter,
    QForm: QForm,
    QFormChildMixin: QFormChildMixin,
    QHeader: QHeader,
    QIcon: QIcon,
    QImg: QImg,
    QInfiniteScroll: QInfiniteScroll,
    QInnerLoading: QInnerLoading,
    QInput: QInput,
    QIntersection: QIntersection,
    QList: QList,
    QItem: QItem,
    QItemSection: QItemSection,
    QItemLabel: QItemLabel,
    QKnob: QKnob,
    QLayout: QLayout,
    QMarkupTable: QMarkupTable,
    QMenu: QMenu,
    QNoSsr: QNoSsr,
    QOptionGroup: QOptionGroup,
    QPage: QPage,
    QPageContainer: QPageContainer,
    QPageScroller: QPageScroller,
    QPageSticky: QPageSticky,
    QPagination: QPagination,
    QParallax: QParallax,
    QPopupEdit: QPopupEdit,
    QPopupProxy: QPopupProxy,
    QLinearProgress: QLinearProgress,
    QPullToRefresh: QPullToRefresh,
    QRadio: QRadio,
    QRange: QRange,
    QRating: QRating,
    QResizeObserver: QResizeObserver,
    QResponsive: QResponsive,
    QScrollArea: QScrollArea,
    QScrollObserver: QScrollObserver,
    QSelect: QSelect,
    QSeparator: QSeparator,
    QSkeleton: QSkeleton,
    QSlideItem: QSlideItem,
    QSlideTransition: QSlideTransition,
    QSlider: QSlider,
    QSpace: QSpace,
    QSpinner: QSpinner,
    QSpinnerAudio: QSpinnerAudio,
    QSpinnerBall: QSpinnerBall,
    QSpinnerBars: QSpinnerBars,
    QSpinnerBox: QSpinnerBox,
    QSpinnerClock: QSpinnerClock,
    QSpinnerComment: QSpinnerComment,
    QSpinnerCube: QSpinnerCube,
    QSpinnerDots: QSpinnerDots,
    QSpinnerFacebook: QSpinnerFacebook,
    QSpinnerGears: QSpinnerGears,
    QSpinnerGrid: QSpinnerGrid,
    QSpinnerHearts: QSpinnerHearts,
    QSpinnerHourglass: QSpinnerHourglass,
    QSpinnerInfinity: QSpinnerInfinity,
    QSpinnerIos: QSpinnerIos,
    QSpinnerOrbit: QSpinnerOrbit,
    QSpinnerOval: QSpinnerOval,
    QSpinnerPie: QSpinnerPie,
    QSpinnerPuff: QSpinnerPuff,
    QSpinnerRadio: QSpinnerRadio,
    QSpinnerRings: QSpinnerRings,
    QSpinnerTail: QSpinnerTail,
    QSplitter: QSplitter,
    QStep: QStep,
    QStepper: QStepper,
    QStepperNavigation: QStepperNavigation,
    QTabPanels: QTabPanels,
    QTabPanel: QTabPanel,
    QTable: QTable,
    QTh: QTh,
    QTr: QTr,
    QTd: QTd,
    QTabs: QTabs,
    QTab: QTab,
    QRouteTab: QRouteTab,
    QTime: QTime,
    QTimeline: QTimeline,
    QTimelineEntry: QTimelineEntry,
    QToggle: QToggle,
    QToolbar: QToolbar,
    QToolbarTitle: QToolbarTitle,
    QTooltip: QTooltip,
    QTree: QTree,
    QUploader: QUploader,
    QUploaderAddTrigger: QUploaderAddTrigger,
    QVideo: QVideo,
    QVirtualScroll: QVirtualScroll
  });

  /*
   * depth
   *   < 0  --> close all chain
   *   0    --> disabled
   *   > 0  --> close chain up to N parent
   */

  function getDepth (value) {
    if (value === false) {
      return 0
    }
    if (value === true || value === void 0) {
      return 1
    }

    const depth = parseInt(value, 10);
    return isNaN(depth) ? 0 : depth
  }

  var ClosePopup = {
        name: 'close-popup',

        beforeMount (el, { value }) {
          const ctx = {
            depth: getDepth(value),

            handler (evt) {
              // allow @click to be emitted
              ctx.depth !== 0 && setTimeout(() => {
                const vm = getPortalVm(el);
                if (vm !== void 0) {
                  closePortals(vm, evt, ctx.depth);
                }
              });
            },

            handlerKey (evt) {
              isKeyCode(evt, 13) === true && ctx.handler(evt);
            }
          };

          el.__qclosepopup = ctx;

          el.addEventListener('click', ctx.handler);
          el.addEventListener('keyup', ctx.handlerKey);
        },

        updated (el, { value, oldValue }) {
          if (value !== oldValue) {
            el.__qclosepopup.depth = getDepth(value);
          }
        },

        beforeUnmount (el) {
          const ctx = el.__qclosepopup;
          el.removeEventListener('click', ctx.handler);
          el.removeEventListener('keyup', ctx.handlerKey);
          delete el.__qclosepopup;
        }
      };

  let id = 0;
  let offsetBase = void 0;

  function getAbsolutePosition (el, resize) {
    if (offsetBase === void 0) {
      offsetBase = document.createElement('div');
      offsetBase.style.cssText = 'position: absolute; left: 0; top: 0';
      document.body.appendChild(offsetBase);
    }

    const boundingRect = el.getBoundingClientRect();
    const baseRect = offsetBase.getBoundingClientRect();
    const { marginLeft, marginRight, marginTop, marginBottom } = window.getComputedStyle(el);
    const marginH = parseInt(marginLeft, 10) + parseInt(marginRight, 10);
    const marginV = parseInt(marginTop, 10) + parseInt(marginBottom, 10);

    return {
      left: boundingRect.left - baseRect.left,
      top: boundingRect.top - baseRect.top,
      width: boundingRect.right - boundingRect.left,
      height: boundingRect.bottom - boundingRect.top,
      widthM: boundingRect.right - boundingRect.left + (resize === true ? 0 : marginH),
      heightM: boundingRect.bottom - boundingRect.top + (resize === true ? 0 : marginV),
      marginH: resize === true ? marginH : 0,
      marginV: resize === true ? marginV : 0
    }
  }

  function getAbsoluteSize (el) {
    return {
      width: el.scrollWidth,
      height: el.scrollHeight
    }
  }

  // firefox rulez
  const styleEdges = [ 'Top', 'Right', 'Bottom', 'Left' ];
  const styleBorderRadiuses = [ 'borderTopLeftRadius', 'borderTopRightRadius', 'borderBottomRightRadius', 'borderBottomLeftRadius' ];
  const reStyleSkipKey = /-block|-inline|block-|inline-/;
  const reStyleSkipRule = /(-block|-inline|block-|inline-).*:/;

  function getComputedStyle$1 (el, props) {
    const style = window.getComputedStyle(el);
    const fixed = {};
    for (let i = 0; i < props.length; i++) {
      const prop = props[ i ];

      if (style[ prop ] === '') {
        if (prop === 'cssText') {
          const styleLen = style.length;
          let val = '';

          for (let i = 0; i < styleLen; i++) {
            if (reStyleSkipKey.test(style[ i ]) !== true) {
              val += style[ i ] + ': ' + style[ style[ i ] ] + '; ';
            }
          }

          fixed[ prop ] = val;
        }
        else if ([ 'borderWidth', 'borderStyle', 'borderColor' ].indexOf(prop) > -1) {
          const suffix = prop.replace('border', '');
          let val = '';
          for (let j = 0; j < styleEdges.length; j++) {
            const subProp = 'border' + styleEdges[ j ] + suffix;
            val += style[ subProp ] + ' ';
          }
          fixed[ prop ] = val;
        }
        else if (prop === 'borderRadius') {
          let val1 = '';
          let val2 = '';
          for (let j = 0; j < styleBorderRadiuses.length; j++) {
            const val = style[ styleBorderRadiuses[ j ] ].split(' ');
            val1 += val[ 0 ] + ' ';
            val2 += (val[ 1 ] === void 0 ? val[ 0 ] : val[ 1 ]) + ' ';
          }
          fixed[ prop ] = val1 + '/ ' + val2;
        }
        else {
          fixed[ prop ] = style[ prop ];
        }
      }
      else {
        if (prop === 'cssText') {
          fixed[ prop ] = style[ prop ]
            .split(';')
            .filter(val => reStyleSkipRule.test(val) !== true)
            .join(';');
        }
        else {
          fixed[ prop ] = style[ prop ];
        }
      }
    }

    return fixed
  }

  const zIndexPositions = [ 'absolute', 'fixed', 'relative', 'sticky' ];

  function getMaxZIndex (elStart) {
    let el = elStart;
    let maxIndex = 0;

    while (el !== null && el !== document) {
      const { position, zIndex } = window.getComputedStyle(el);
      const zIndexNum = Number(zIndex);

      if (
        zIndexNum > maxIndex
        && (el === elStart || zIndexPositions.includes(position) === true)
      ) {
        maxIndex = zIndexNum;
      }

      el = el.parentNode;
    }

    return maxIndex
  }

  function normalizeElements (opts) {
    return {
      from: opts.from,
      to: opts.to !== void 0
        ? opts.to
        : opts.from
    }
  }

  function normalizeOptions (options) {
    if (typeof options === 'number') {
      options = {
        duration: options
      };
    }
    else if (typeof options === 'function') {
      options = {
        onEnd: options
      };
    }

    return {
      ...options,

      waitFor: options.waitFor === void 0 ? 0 : options.waitFor,

      duration: isNaN(options.duration) === true ? 300 : parseInt(options.duration, 10),
      easing: typeof options.easing === 'string' && options.easing.length > 0 ? options.easing : 'ease-in-out',
      delay: isNaN(options.delay) === true ? 0 : parseInt(options.delay, 10),
      fill: typeof options.fill === 'string' && options.fill.length > 0 ? options.fill : 'none',

      resize: options.resize === true,
      useCSS: options.useCSS === true,
      hideFromClone: options.hideFromClone === true,
      keepToClone: options.keepToClone === true,

      tween: options.tween === true,
      tweenFromOpacity: isNaN(options.tweenFromOpacity) === true ? 0.6 : parseFloat(options.tweenFromOpacity),
      tweenToOpacity: isNaN(options.tweenToOpacity) === true ? 0.5 : parseFloat(options.tweenToOpacity)
    }
  }

  function getElement (element) {
    const type = typeof element;

    return type === 'function'
      ? element()
      : (
          type === 'string'
            ? document.querySelector(element)
            : element
        )
  }

  function isValidElement (element) {
    return element
      && element.ownerDocument === document
      && element.parentNode !== null
  }

  function morph (_options) {
    let cancel = () => false;
    let cancelStatus = false;
    let endElementTo = true;

    const elements = normalizeElements(_options);
    const options = normalizeOptions(_options);

    const elFrom = getElement(elements.from);
    if (isValidElement(elFrom) !== true) {
      // we return a cancel function that return false, meaning the cancel function failed
      return cancel
    }
    // we clean other morphs running on this element
    typeof elFrom.qMorphCancel === 'function' && elFrom.qMorphCancel();

    let animationFromClone = void 0;
    let animationFromTween = void 0;
    let animationToClone = void 0;
    let animationTo = void 0;

    const elFromParent = elFrom.parentNode;
    const elFromNext = elFrom.nextElementSibling;

    // we get the dimensions and characteristics
    // of the parent of the initial element before changes
    const elFromPosition = getAbsolutePosition(elFrom, options.resize);
    const {
      width: elFromParentWidthBefore,
      height: elFromParentHeightBefore
    } = getAbsoluteSize(elFromParent);
    const {
      borderWidth: elFromBorderWidth,
      borderStyle: elFromBorderStyle,
      borderColor: elFromBorderColor,
      borderRadius: elFromBorderRadius,
      backgroundColor: elFromBackground,
      transform: elFromTransform,
      position: elFromPositioningType,
      cssText: elFromCssText
    } = getComputedStyle$1(elFrom, [ 'borderWidth', 'borderStyle', 'borderColor', 'borderRadius', 'backgroundColor', 'transform', 'position', 'cssText' ]);
    const elFromClassSaved = elFrom.classList.toString();
    const elFromStyleSaved = elFrom.style.cssText;

    // we make a clone of the initial element and
    // use it to display until the final element is ready
    // and to change the occupied space during animation
    const elFromClone = elFrom.cloneNode(true);
    const elFromTween = options.tween === true ? elFrom.cloneNode(true) : void 0;

    if (elFromTween !== void 0) {
      elFromTween.className = elFromTween.classList.toString().split(' ').filter(c => /^bg-/.test(c) === false).join(' ');
    }

    // if the initial element is not going to be removed do not show the placeholder
    options.hideFromClone === true && elFromClone.classList.add('q-morph--internal');

    // prevent interaction with placeholder
    elFromClone.setAttribute('aria-hidden', 'true');
    elFromClone.style.transition = 'none';
    elFromClone.style.animation = 'none';
    elFromClone.style.pointerEvents = 'none';
    elFromParent.insertBefore(elFromClone, elFromNext);

    // we mark the element with its cleanup function
    elFrom.qMorphCancel = () => {
      cancelStatus = true;

      // we clean the clone of the initial element
      elFromClone.remove();
      elFromTween !== void 0 && elFromTween.remove();

      options.hideFromClone === true && elFromClone.classList.remove('q-morph--internal');

      // we remove the cleanup function from the element
      elFrom.qMorphCancel = void 0;
    };

    // will be called after Vue catches up with the changes done by _options.onToggle() function
    const calculateFinalState = () => {
      const elTo = getElement(elements.to);
      if (cancelStatus === true || isValidElement(elTo) !== true) {
        typeof elFrom.qMorphCancel === 'function' && elFrom.qMorphCancel();

        return
      }
      // we clean other morphs running on this element
      elFrom !== elTo && typeof elTo.qMorphCancel === 'function' && elTo.qMorphCancel();

      // we hide the final element and the clone of the initial element
      // we don't hide the final element if we want both it and the animated one visible
      options.keepToClone !== true && elTo.classList.add('q-morph--internal');
      elFromClone.classList.add('q-morph--internal');

      // we get the dimensions of the parent of the initial element after changes
      // the difference is how much we should animate the clone
      const {
        width: elFromParentWidthAfter,
        height: elFromParentHeightAfter
      } = getAbsoluteSize(elFromParent);

      // we get the dimensions of the parent of the final element before changes
      const {
        width: elToParentWidthBefore,
        height: elToParentHeightBefore
      } = getAbsoluteSize(elTo.parentNode);

      // then we show the clone of the initial element if we don't want it hidden
      options.hideFromClone !== true && elFromClone.classList.remove('q-morph--internal');

      // we mark the element with its cleanup function
      elTo.qMorphCancel = () => {
        cancelStatus = true;

        // we clean the clone of the initial element
        elFromClone.remove();
        elFromTween !== void 0 && elFromTween.remove();

        options.hideFromClone === true && elFromClone.classList.remove('q-morph--internal');

        // we show the final element
        options.keepToClone !== true && elTo.classList.remove('q-morph--internal');

        // we remove the cleanup function from the elements
        elFrom.qMorphCancel = void 0;
        elTo.qMorphCancel = void 0;
      };

      // will be called after waitFor (give time to render the final element)
      const animate = () => {
        if (cancelStatus === true) {
          typeof elTo.qMorphCancel === 'function' && elTo.qMorphCancel();

          return
        }

        // now the animation starts, so we only need the clone
        // of the initial element as a spacer
        // we also hide it to calculate the dimensions of the
        // parent of the final element after the changes
        if (options.hideFromClone !== true) {
          elFromClone.classList.add('q-morph--internal');
          elFromClone.innerHTML = '';
          elFromClone.style.left = 0;
          elFromClone.style.right = 'unset';
          elFromClone.style.top = 0;
          elFromClone.style.bottom = 'unset';
          elFromClone.style.transform = 'none';
        }

        // we show the final element
        if (options.keepToClone !== true) {
          elTo.classList.remove('q-morph--internal');
        }

        // we get the dimensions of the parent of the final element after changes
        // the difference is how much we should animate the clone
        const elToParent = elTo.parentNode;
        const {
          width: elToParentWidthAfter,
          height: elToParentHeightAfter
        } = getAbsoluteSize(elToParent);

        const elToClone = elTo.cloneNode(options.keepToClone);
        elToClone.setAttribute('aria-hidden', 'true');
        if (options.keepToClone !== true) {
          elToClone.style.left = 0;
          elToClone.style.right = 'unset';
          elToClone.style.top = 0;
          elToClone.style.bottom = 'unset';
          elToClone.style.transform = 'none';
          elToClone.style.pointerEvents = 'none';
        }
        elToClone.classList.add('q-morph--internal');

        // if elFrom is the same as elTo the next element is elFromClone
        const elToNext = elTo === elFrom && elFromParent === elToParent ? elFromClone : elTo.nextElementSibling;
        elToParent.insertBefore(elToClone, elToNext);

        const {
          borderWidth: elToBorderWidth,
          borderStyle: elToBorderStyle,
          borderColor: elToBorderColor,
          borderRadius: elToBorderRadius,
          backgroundColor: elToBackground,
          transform: elToTransform,
          position: elToPositioningType,
          cssText: elToCssText
        } = getComputedStyle$1(elTo, [ 'borderWidth', 'borderStyle', 'borderColor', 'borderRadius', 'backgroundColor', 'transform', 'position', 'cssText' ]);
        const elToClassSaved = elTo.classList.toString();
        const elToStyleSaved = elTo.style.cssText;

        // we set the computed styles on the element (to be able to remove classes)
        elTo.style.cssText = elToCssText;
        elTo.style.transform = 'none';
        elTo.style.animation = 'none';
        elTo.style.transition = 'none';
        // we strip the background classes (background color can no longer be animated if !important is used)
        elTo.className = elToClassSaved.split(' ').filter(c => /^bg-/.test(c) === false).join(' ');

        const elToPosition = getAbsolutePosition(elTo, options.resize);

        const deltaX = elFromPosition.left - elToPosition.left;
        const deltaY = elFromPosition.top - elToPosition.top;
        const scaleX = elFromPosition.width / (elToPosition.width > 0 ? elToPosition.width : 10);
        const scaleY = elFromPosition.height / (elToPosition.height > 0 ? elToPosition.height : 100);

        const elFromParentWidthDiff = elFromParentWidthBefore - elFromParentWidthAfter;
        const elFromParentHeightDiff = elFromParentHeightBefore - elFromParentHeightAfter;
        const elToParentWidthDiff = elToParentWidthAfter - elToParentWidthBefore;
        const elToParentHeightDiff = elToParentHeightAfter - elToParentHeightBefore;

        const elFromCloneWidth = Math.max(elFromPosition.widthM, elFromParentWidthDiff);
        const elFromCloneHeight = Math.max(elFromPosition.heightM, elFromParentHeightDiff);
        const elToCloneWidth = Math.max(elToPosition.widthM, elToParentWidthDiff);
        const elToCloneHeight = Math.max(elToPosition.heightM, elToParentHeightDiff);

        const elSharedSize = elFrom === elTo
          && [ 'absolute', 'fixed' ].includes(elToPositioningType) === false
          && [ 'absolute', 'fixed' ].includes(elFromPositioningType) === false;

        // if the final element has fixed position or if a parent
        // has fixed position we need to animate it as fixed
        let elToNeedsFixedPosition = elToPositioningType === 'fixed';
        let parent = elToParent;
        while (elToNeedsFixedPosition !== true && parent !== document) {
          elToNeedsFixedPosition = window.getComputedStyle(parent).position === 'fixed';
          parent = parent.parentNode;
        }

        // we show the spacer for the initial element
        if (options.hideFromClone !== true) {
          elFromClone.style.display = 'block';
          elFromClone.style.flex = '0 0 auto';
          elFromClone.style.opacity = 0;
          elFromClone.style.minWidth = 'unset';
          elFromClone.style.maxWidth = 'unset';
          elFromClone.style.minHeight = 'unset';
          elFromClone.style.maxHeight = 'unset';
          elFromClone.classList.remove('q-morph--internal');
        }

        // we show the spacer for the final element
        if (options.keepToClone !== true) {
          elToClone.style.display = 'block';
          elToClone.style.flex = '0 0 auto';
          elToClone.style.opacity = 0;
          elToClone.style.minWidth = 'unset';
          elToClone.style.maxWidth = 'unset';
          elToClone.style.minHeight = 'unset';
          elToClone.style.maxHeight = 'unset';
        }
        elToClone.classList.remove('q-morph--internal');

        // we apply classes specified by user
        if (typeof options.classes === 'string') {
          elTo.className += ' ' + options.classes;
        }

        // we apply styles specified by user
        if (typeof options.style === 'string') {
          elTo.style.cssText += ' ' + options.style;
        }
        else if (options.style === Object(options.style)) {
          for (const prop in options.style) {
            elTo.style[ prop ] = options.style[ prop ];
          }
        }

        const elFromZIndex = getMaxZIndex(elFromClone);
        const elToZIndex = getMaxZIndex(elTo);

        // we position the morphing element
        // if we use fixed position for the final element we need to adjust for scroll
        const documentScroll = elToNeedsFixedPosition === true
          ? document.documentElement
          : { scrollLeft: 0, scrollTop: 0 };
        elTo.style.position = elToNeedsFixedPosition === true ? 'fixed' : 'absolute';
        elTo.style.left = `${ elToPosition.left - documentScroll.scrollLeft }px`;
        elTo.style.right = 'unset';
        elTo.style.top = `${ elToPosition.top - documentScroll.scrollTop }px`;
        elTo.style.margin = 0;

        if (options.resize === true) {
          elTo.style.minWidth = 'unset';
          elTo.style.maxWidth = 'unset';
          elTo.style.minHeight = 'unset';
          elTo.style.maxHeight = 'unset';
          elTo.style.overflow = 'hidden';
          elTo.style.overflowX = 'hidden';
          elTo.style.overflowY = 'hidden';
        }

        document.body.appendChild(elTo);

        if (elFromTween !== void 0) {
          elFromTween.style.cssText = elFromCssText;
          elFromTween.style.transform = 'none';
          elFromTween.style.animation = 'none';
          elFromTween.style.transition = 'none';

          elFromTween.style.position = elTo.style.position;
          elFromTween.style.left = `${ elFromPosition.left - documentScroll.scrollLeft }px`;
          elFromTween.style.right = 'unset';
          elFromTween.style.top = `${ elFromPosition.top - documentScroll.scrollTop }px`;
          elFromTween.style.margin = 0;
          elFromTween.style.pointerEvents = 'none';

          if (options.resize === true) {
            elFromTween.style.minWidth = 'unset';
            elFromTween.style.maxWidth = 'unset';
            elFromTween.style.minHeight = 'unset';
            elFromTween.style.maxHeight = 'unset';
            elFromTween.style.overflow = 'hidden';
            elFromTween.style.overflowX = 'hidden';
            elFromTween.style.overflowY = 'hidden';
          }

          document.body.appendChild(elFromTween);
        }

        const commonCleanup = aborted => {
          // we put the element back in it's place
          // and restore the styles and classes
          if (elFrom === elTo && endElementTo !== true) {
            elTo.style.cssText = elFromStyleSaved;
            elTo.className = elFromClassSaved;
          }
          else {
            elTo.style.cssText = elToStyleSaved;
            elTo.className = elToClassSaved;
          }
          elToClone.parentNode === elToParent && elToParent.insertBefore(elTo, elToClone);

          // we clean the spacers
          elFromClone.remove();
          elToClone.remove();
          elFromTween !== void 0 && elFromTween.remove();

          // cancel will be no longer available
          cancel = () => false;

          elFrom.qMorphCancel = void 0;
          elTo.qMorphCancel = void 0;

          // we are ready
          if (typeof options.onEnd === 'function') {
            options.onEnd(endElementTo === true ? 'to' : 'from', aborted === true);
          }
        };

        if (options.useCSS !== true && typeof elTo.animate === 'function') {
          const resizeFrom = options.resize === true
            ? {
                transform: `translate(${ deltaX }px, ${ deltaY }px)`,
                width: `${ elFromCloneWidth }px`,
                height: `${ elFromCloneHeight }px`
              }
            : {
                transform: `translate(${ deltaX }px, ${ deltaY }px) scale(${ scaleX }, ${ scaleY })`
              };
          const resizeTo = options.resize === true
            ? {
                width: `${ elToCloneWidth }px`,
                height: `${ elToCloneHeight }px`
              }
            : {};
          const resizeFromTween = options.resize === true
            ? {
                width: `${ elFromCloneWidth }px`,
                height: `${ elFromCloneHeight }px`
              }
            : {};
          const resizeToTween = options.resize === true
            ? {
                transform: `translate(${ -1 * deltaX }px, ${ -1 * deltaY }px)`,
                width: `${ elToCloneWidth }px`,
                height: `${ elToCloneHeight }px`
              }
            : {
                transform: `translate(${ -1 * deltaX }px, ${ -1 * deltaY }px) scale(${ 1 / scaleX }, ${ 1 / scaleY })`
              };
          const tweenFrom = elFromTween !== void 0
            ? { opacity: options.tweenToOpacity }
            : { backgroundColor: elFromBackground };
          const tweenTo = elFromTween !== void 0
            ? { opacity: 1 }
            : { backgroundColor: elToBackground };
          animationTo = elTo.animate([
            {
              margin: 0,
              borderWidth: elFromBorderWidth,
              borderStyle: elFromBorderStyle,
              borderColor: elFromBorderColor,
              borderRadius: elFromBorderRadius,
              zIndex: elFromZIndex,
              transformOrigin: '0 0',
              ...resizeFrom,
              ...tweenFrom
            },
            {
              margin: 0,
              borderWidth: elToBorderWidth,
              borderStyle: elToBorderStyle,
              borderColor: elToBorderColor,
              borderRadius: elToBorderRadius,
              zIndex: elToZIndex,
              transformOrigin: '0 0',
              transform: elToTransform,
              ...resizeTo,
              ...tweenTo
            }
          ], {
            duration: options.duration,
            easing: options.easing,
            fill: options.fill,
            delay: options.delay
          });

          animationFromTween = elFromTween === void 0 ? void 0 : elFromTween.animate([
            {
              opacity: options.tweenFromOpacity,
              margin: 0,
              borderWidth: elFromBorderWidth,
              borderStyle: elFromBorderStyle,
              borderColor: elFromBorderColor,
              borderRadius: elFromBorderRadius,
              zIndex: elFromZIndex,
              transformOrigin: '0 0',
              transform: elFromTransform,
              ...resizeFromTween
            },
            {
              opacity: 0,
              margin: 0,
              borderWidth: elToBorderWidth,
              borderStyle: elToBorderStyle,
              borderColor: elToBorderColor,
              borderRadius: elToBorderRadius,
              zIndex: elToZIndex,
              transformOrigin: '0 0',
              ...resizeToTween
            }
          ], {
            duration: options.duration,
            easing: options.easing,
            fill: options.fill,
            delay: options.delay
          });

          animationFromClone = options.hideFromClone === true || elSharedSize === true ? void 0 : elFromClone.animate([
            {
              margin: `${ elFromParentHeightDiff < 0 ? elFromParentHeightDiff / 2 : 0 }px ${ elFromParentWidthDiff < 0 ? elFromParentWidthDiff / 2 : 0 }px`,
              width: `${ elFromCloneWidth + elFromPosition.marginH }px`,
              height: `${ elFromCloneHeight + elFromPosition.marginV }px`
            },
            {
              margin: 0,
              width: 0,
              height: 0
            }
          ], {
            duration: options.duration,
            easing: options.easing,
            fill: options.fill,
            delay: options.delay
          });

          animationToClone = options.keepToClone === true ? void 0 : elToClone.animate([
            elSharedSize === true
              ? {
                  margin: `${ elFromParentHeightDiff < 0 ? elFromParentHeightDiff / 2 : 0 }px ${ elFromParentWidthDiff < 0 ? elFromParentWidthDiff / 2 : 0 }px`,
                  width: `${ elFromCloneWidth + elFromPosition.marginH }px`,
                  height: `${ elFromCloneHeight + elFromPosition.marginV }px`
                }
              : {
                  margin: 0,
                  width: 0,
                  height: 0
                },
            {
              margin: `${ elToParentHeightDiff < 0 ? elToParentHeightDiff / 2 : 0 }px ${ elToParentWidthDiff < 0 ? elToParentWidthDiff / 2 : 0 }px`,
              width: `${ elToCloneWidth + elToPosition.marginH }px`,
              height: `${ elToCloneHeight + elToPosition.marginV }px`
            }
          ], {
            duration: options.duration,
            easing: options.easing,
            fill: options.fill,
            delay: options.delay
          });

          const cleanup = abort => {
            animationFromClone !== void 0 && animationFromClone.cancel();
            animationFromTween !== void 0 && animationFromTween.cancel();
            animationToClone !== void 0 && animationToClone.cancel();
            animationTo.cancel();

            animationTo.removeEventListener('finish', cleanup);
            animationTo.removeEventListener('cancel', cleanup);

            commonCleanup(abort);

            // we clean the animations
            animationFromClone = void 0;
            animationFromTween = void 0;
            animationToClone = void 0;
            animationTo = void 0;
          };

          elFrom.qMorphCancel = () => {
            elFrom.qMorphCancel = void 0;
            cancelStatus = true;
            cleanup();
          };
          elTo.qMorphCancel = () => {
            elTo.qMorphCancel = void 0;
            cancelStatus = true;
            cleanup();
          };

          animationTo.addEventListener('finish', cleanup);
          animationTo.addEventListener('cancel', cleanup);

          cancel = abort => {
            // we are not in a morph that we can cancel
            if (cancelStatus === true || animationTo === void 0) {
              return false
            }

            if (abort === true) {
              cleanup(true);
              return true
            }

            endElementTo = endElementTo !== true;

            animationFromClone !== void 0 && animationFromClone.reverse();
            animationFromTween !== void 0 && animationFromTween.reverse();
            animationToClone !== void 0 && animationToClone.reverse();
            animationTo.reverse();

            return true
          };
        }
        else {
          const qAnimId = `q-morph-anim-${ ++id }`;
          const style = document.createElement('style');
          const resizeFrom = options.resize === true
            ? `
            transform: translate(${ deltaX }px, ${ deltaY }px);
            width: ${ elFromCloneWidth }px;
            height: ${ elFromCloneHeight }px;
          `
            : `transform: translate(${ deltaX }px, ${ deltaY }px) scale(${ scaleX }, ${ scaleY });`;
          const resizeTo = options.resize === true
            ? `
            width: ${ elToCloneWidth }px;
            height: ${ elToCloneHeight }px;
          `
            : '';
          const resizeFromTween = options.resize === true
            ? `
            width: ${ elFromCloneWidth }px;
            height: ${ elFromCloneHeight }px;
          `
            : '';
          const resizeToTween = options.resize === true
            ? `
            transform: translate(${ -1 * deltaX }px, ${ -1 * deltaY }px);
            width: ${ elToCloneWidth }px;
            height: ${ elToCloneHeight }px;
          `
            : `transform: translate(${ -1 * deltaX }px, ${ -1 * deltaY }px) scale(${ 1 / scaleX }, ${ 1 / scaleY });`;
          const tweenFrom = elFromTween !== void 0
            ? `opacity: ${ options.tweenToOpacity };`
            : `background-color: ${ elFromBackground };`;
          const tweenTo = elFromTween !== void 0
            ? 'opacity: 1;'
            : `background-color: ${ elToBackground };`;
          const keyframesFromTween = elFromTween === void 0
            ? ''
            : `
            @keyframes ${ qAnimId }-from-tween {
              0% {
                opacity: ${ options.tweenFromOpacity };
                margin: 0;
                border-width: ${ elFromBorderWidth };
                border-style: ${ elFromBorderStyle };
                border-color: ${ elFromBorderColor };
                border-radius: ${ elFromBorderRadius };
                z-index: ${ elFromZIndex };
                transform-origin: 0 0;
                transform: ${ elFromTransform };
                ${ resizeFromTween }
              }

              100% {
                opacity: 0;
                margin: 0;
                border-width: ${ elToBorderWidth };
                border-style: ${ elToBorderStyle };
                border-color: ${ elToBorderColor };
                border-radius: ${ elToBorderRadius };
                z-index: ${ elToZIndex };
                transform-origin: 0 0;
                ${ resizeToTween }
              }
            }
          `;
          const keyframesFrom = options.hideFromClone === true || elSharedSize === true
            ? ''
            : `
            @keyframes ${ qAnimId }-from {
              0% {
                margin: ${ elFromParentHeightDiff < 0 ? elFromParentHeightDiff / 2 : 0 }px ${ elFromParentWidthDiff < 0 ? elFromParentWidthDiff / 2 : 0 }px;
                width: ${ elFromCloneWidth + elFromPosition.marginH }px;
                height: ${ elFromCloneHeight + elFromPosition.marginV }px;
              }

              100% {
                margin: 0;
                width: 0;
                height: 0;
              }
            }
          `;
          const keyframeToStart = elSharedSize === true
            ? `
            margin: ${ elFromParentHeightDiff < 0 ? elFromParentHeightDiff / 2 : 0 }px ${ elFromParentWidthDiff < 0 ? elFromParentWidthDiff / 2 : 0 }px;
            width: ${ elFromCloneWidth + elFromPosition.marginH }px;
            height: ${ elFromCloneHeight + elFromPosition.marginV }px;
          `
            : `
            margin: 0;
            width: 0;
            height: 0;
          `;
          const keyframesTo = options.keepToClone === true
            ? ''
            : `
            @keyframes ${ qAnimId }-to {
              0% {
                ${ keyframeToStart }
              }

              100% {
                margin: ${ elToParentHeightDiff < 0 ? elToParentHeightDiff / 2 : 0 }px ${ elToParentWidthDiff < 0 ? elToParentWidthDiff / 2 : 0 }px;
                width: ${ elToCloneWidth + elToPosition.marginH }px;
                height: ${ elToCloneHeight + elToPosition.marginV }px;
              }
            }
          `;
          style.innerHTML = `
          @keyframes ${ qAnimId } {
            0% {
              margin: 0;
              border-width: ${ elFromBorderWidth };
              border-style: ${ elFromBorderStyle };
              border-color: ${ elFromBorderColor };
              border-radius: ${ elFromBorderRadius };
              background-color: ${ elFromBackground };
              z-index: ${ elFromZIndex };
              transform-origin: 0 0;
              ${ resizeFrom }
              ${ tweenFrom }
            }

            100% {
              margin: 0;
              border-width: ${ elToBorderWidth };
              border-style: ${ elToBorderStyle };
              border-color: ${ elToBorderColor };
              border-radius: ${ elToBorderRadius };
              background-color: ${ elToBackground };
              z-index: ${ elToZIndex };
              transform-origin: 0 0;
              transform: ${ elToTransform };
              ${ resizeTo }
              ${ tweenTo }
            }
          }

          ${ keyframesFrom }

          ${ keyframesFromTween }

          ${ keyframesTo }
        `;
          document.head.appendChild(style);

          let animationDirection = 'normal';

          elFromClone.style.animation = `${ options.duration }ms ${ options.easing } ${ options.delay }ms ${ animationDirection } ${ options.fill } ${ qAnimId }-from`;
          if (elFromTween !== void 0) {
            elFromTween.style.animation = `${ options.duration }ms ${ options.easing } ${ options.delay }ms ${ animationDirection } ${ options.fill } ${ qAnimId }-from-tween`;
          }
          elToClone.style.animation = `${ options.duration }ms ${ options.easing } ${ options.delay }ms ${ animationDirection } ${ options.fill } ${ qAnimId }-to`;
          elTo.style.animation = `${ options.duration }ms ${ options.easing } ${ options.delay }ms ${ animationDirection } ${ options.fill } ${ qAnimId }`;

          const cleanup = ev => {
            if (ev === Object(ev) && ev.animationName !== qAnimId) {
              return
            }

            elTo.removeEventListener('animationend', cleanup);
            elTo.removeEventListener('animationcancel', cleanup);

            commonCleanup();

            // we clean the animations
            style.remove();
          };

          elFrom.qMorphCancel = () => {
            elFrom.qMorphCancel = void 0;
            cancelStatus = true;
            cleanup();
          };
          elTo.qMorphCancel = () => {
            elTo.qMorphCancel = void 0;
            cancelStatus = true;
            cleanup();
          };

          elTo.addEventListener('animationend', cleanup);
          elTo.addEventListener('animationcancel', cleanup);

          cancel = abort => {
            // we are not in a morph that we can cancel
            if (cancelStatus === true || !elTo || !elFromClone || !elToClone) {
              return false
            }

            if (abort === true) {
              cleanup();

              return true
            }

            endElementTo = endElementTo !== true;

            animationDirection = animationDirection === 'normal' ? 'reverse' : 'normal';

            elFromClone.style.animationDirection = animationDirection;
            elFromTween.style.animationDirection = animationDirection;
            elToClone.style.animationDirection = animationDirection;
            elTo.style.animationDirection = animationDirection;

            return true
          };
        }
      };

      if (
        options.waitFor > 0
        || options.waitFor === 'transitionend'
        || (options.waitFor === Object(options.waitFor) && typeof options.waitFor.then === 'function')
      ) {
        const delayPromise = options.waitFor > 0
          ? new Promise(resolve => setTimeout(resolve, options.waitFor))
          : (
              options.waitFor === 'transitionend'
                ? new Promise(resolve => {
                    const timer = setTimeout(() => {
                      endFn();
                    }, 400);

                    const endFn = ev => {
                      clearTimeout(timer);

                      if (elTo) {
                        elTo.removeEventListener('transitionend', endFn);
                        elTo.removeEventListener('transitioncancel', endFn);
                      }

                      resolve();
                    };

                    elTo.addEventListener('transitionend', endFn);
                    elTo.addEventListener('transitioncancel', endFn);
                  })
                : options.waitFor
            );

        delayPromise
          .then(animate)
          .catch(() => {
            typeof elTo.qMorphCancel === 'function' && elTo.qMorphCancel();
          });
      }
      else {
        animate();
      }
    };

    typeof _options.onToggle === 'function' && _options.onToggle();
    requestAnimationFrame(calculateFinalState);

    // we return the cancel function
    // returns:
    //   false if the cancel cannot be performed (the morph ended already or has not started)
    //   true else
    return abort => cancel(abort)
  }

  const morphGroups = {};
  const props$1 = [
    'duration', 'delay', 'easing', 'fill',
    'classes', 'style', 'duration', 'resize',
    'useCSS', 'hideFromClone', 'keepToClone', 'tween',
    'tweenFromOpacity', 'tweenToOpacity',
    'waitFor', 'onEnd'
  ];
  const mods = [
    'resize', 'useCSS', 'hideFromClone', 'keepToClone', 'tween'
  ];

  function changeClass (ctx, action) {
    if (ctx.clsAction !== action) {
      ctx.clsAction = action;
      ctx.el.classList[ action ]('q-morph--invisible');
    }
  }

  function trigger (group) {
    if (group.animating === true || group.queue.length < 2) {
      return
    }

    const [ from, to ] = group.queue;

    group.animating = true;
    from.animating = true;
    to.animating = true;

    changeClass(from, 'remove');
    changeClass(to, 'remove');

    const cancelFn = morph({
      from: from.el,
      to: to.el,
      onToggle () {
        changeClass(from, 'add');
        changeClass(to, 'remove');
      },
      ...to.opts,
      onEnd (dir, aborted) {
        to.opts.onEnd !== void 0 && to.opts.onEnd(dir, aborted);

        if (aborted === true) {
          return
        }

        from.animating = false;
        to.animating = false;

        group.animating = false;
        group.cancel = void 0;
        group.queue.shift();

        trigger(group);
      }
    });

    group.cancel = () => {
      cancelFn(true); // abort
      group.cancel = void 0;
    };
  }

  function updateModifiers (mod, ctx) {
    const opts = ctx.opts;

    mods.forEach(name => {
      opts[ name ] = mod[ name ] === true;
    });
  }

  function insertArgs (arg, ctx) {
    const opts = typeof arg === 'string' && arg.length > 0
      ? arg.split(':') : [];

    ctx.name = opts[ 0 ];
    ctx.group = opts[ 1 ];

    Object.assign(ctx.opts, {
      duration: isNaN(opts[ 2 ]) === true
        ? 300
        : parseFloat(opts[ 2 ]),
      waitFor: opts[ 3 ]
    });
  }

  function updateArgs (arg, ctx) {
    if (arg.group !== void 0) {
      ctx.group = arg.group;
    }
    if (arg.name !== void 0) {
      ctx.name = arg.name;
    }

    const opts = ctx.opts;

    props$1.forEach(name => {
      if (arg[ name ] !== void 0) {
        opts[ name ] = arg[ name ];
      }
    });
  }

  function updateModel (name, ctx) {
    if (ctx.name === name) {
      const group = morphGroups[ ctx.group ];

      // if group is not registered
      if (group === void 0) {
        morphGroups[ ctx.group ] = {
          name: ctx.group,
          model: name,
          queue: [ ctx ],
          animating: false
        };

        changeClass(ctx, 'remove');
      }
      // if model changed
      else if (group.model !== name) {
        group.model = name;
        group.queue.push(ctx);

        if (group.animating === false && group.queue.length === 2) {
          trigger(group);
        }
      }

      return
    }

    if (ctx.animating === false) {
      changeClass(ctx, 'add');
    }
  }

  function updateValue (ctx, value) {
    let model;

    if (Object(value) === value) {
      model = '' + value.model;
      updateArgs(value, ctx);
      updateModifiers(value, ctx);
    }
    else {
      model = '' + value;
    }

    if (model !== ctx.model) {
      ctx.model = model;
      updateModel(model, ctx);
    }
    else if (ctx.animating === false && ctx.clsAction !== void 0) {
      // ensure HMR
      ctx.el.classList[ ctx.clsAction ]('q-morph--invisible');
    }
  }

  var Morph = {
        name: 'morph',

        mounted (el, binding) {
          const ctx = {
            el,
            animating: false,
            opts: {}
          };

          updateModifiers(binding.modifiers, ctx);
          insertArgs(binding.arg, ctx);
          updateValue(ctx, binding.value);

          el.__qmorph = ctx;
        },

        updated (el, binding) {
          updateValue(el.__qmorph, binding.value);
        },

        beforeUnmount (el) {
          const ctx = el.__qmorph;

          const group = morphGroups[ ctx.group ];

          if (group !== void 0) {
            const index = group.queue.indexOf(ctx);

            if (index !== -1) {
              group.queue = group.queue.filter(item => item !== ctx);

              if (group.queue.length === 0) {
                group.cancel !== void 0 && group.cancel();
                delete morphGroups[ ctx.group ];
              }
            }
          }

          if (ctx.clsAction === 'add') {
            el.classList.remove('q-morph--invisible');
          }

          delete el.__qmorph;
        }
      };

  const defaultCfg = {
    childList: true,
    subtree: true,
    attributes: true,
    characterData: true,
    attributeOldValue: true,
    characterDataOldValue: true
  };

  function update$2 (el, ctx, value) {
    ctx.handler = value;
    ctx.observer !== void 0 && ctx.observer.disconnect();

    ctx.observer = new MutationObserver(list => {
      if (typeof ctx.handler === 'function') {
        const res = ctx.handler(list);
        if (res === false || ctx.once === true) {
          destroy(el);
        }
      }
    });

    ctx.observer.observe(el, ctx.opts);
  }

  function destroy (el) {
    const ctx = el.__qmutation;

    if (ctx !== void 0) {
      ctx.observer !== void 0 && ctx.observer.disconnect();
      delete el.__qmutation;
    }
  }

  var Mutation = {
        name: 'mutation',

        mounted (el, { modifiers: { once, ...mod }, value }) {
          const ctx = {
            once,
            opts: Object.keys(mod).length === 0
              ? defaultCfg
              : mod
          };

          update$2(el, ctx, value);

          el.__qmutation = ctx;
        },

        updated (el, { oldValue, value }) {
          const ctx = el.__qmutation;
          if (ctx !== void 0 && oldValue !== value) {
            update$2(el, ctx, value);
          }
        },

        beforeUnmount: destroy
      };

  const { passive } = listenOpts;

  function update$1 (ctx, { value, oldValue }) {
    if (typeof value !== 'function') {
      ctx.scrollTarget.removeEventListener('scroll', ctx.scroll, passive);
      return
    }

    ctx.handler = value;
    if (typeof oldValue !== 'function') {
      ctx.scrollTarget.addEventListener('scroll', ctx.scroll, passive);
      ctx.scroll();
    }
  }

  var ScrollFire = {
        name: 'scroll-fire',

        mounted (el, binding) {
          const ctx = {
            scrollTarget: getScrollTarget(el),
            scroll: debounce(() => {
              let containerBottom, elBottom;

              if (ctx.scrollTarget === window) {
                elBottom = el.getBoundingClientRect().bottom;
                containerBottom = window.innerHeight;
              }
              else {
                elBottom = offset(el).top + height(el);
                containerBottom = offset(ctx.scrollTarget).top + height(ctx.scrollTarget);
              }

              if (elBottom > 0 && elBottom < containerBottom) {
                ctx.scrollTarget.removeEventListener('scroll', ctx.scroll, passive);
                ctx.handler(el);
              }
            }, 25)
          };

          update$1(ctx, binding);

          el.__qscrollfire = ctx;
        },

        updated (el, binding) {
          if (binding.value !== binding.oldValue) {
            update$1(el.__qscrollfire, binding);
          }
        },

        beforeUnmount (el) {
          const ctx = el.__qscrollfire;
          ctx.scrollTarget.removeEventListener('scroll', ctx.scroll, passive);
          delete el.__qscrollfire;
        }
      };

  function update (ctx, { value, oldValue }) {
    if (typeof value !== 'function') {
      ctx.scrollTarget.removeEventListener('scroll', ctx.scroll, listenOpts.passive);
      return
    }

    ctx.handler = value;
    if (typeof oldValue !== 'function') {
      ctx.scrollTarget.addEventListener('scroll', ctx.scroll, listenOpts.passive);
    }
  }

  var Scroll = {
        name: 'scroll',

        mounted (el, binding) {
          const ctx = {
            scrollTarget: getScrollTarget(el),
            scroll () {
              ctx.handler(
                getVerticalScrollPosition(ctx.scrollTarget),
                getHorizontalScrollPosition(ctx.scrollTarget)
              );
            }
          };

          update(ctx, binding);

          el.__qscroll = ctx;
        },

        updated (el, binding) {
          if (el.__qscroll !== void 0 && binding.oldValue !== binding.value) {
            update(el.__qscroll, binding);
          }
        },

        beforeUnmount (el) {
          const ctx = el.__qscroll;
          ctx.scrollTarget.removeEventListener('scroll', ctx.scroll, listenOpts.passive);
          delete el.__qscroll;
        }
      };

  var TouchHold = {
        name: 'touch-hold',

        beforeMount (el, binding) {
          const { modifiers } = binding;

          // early return, we don't need to do anything
          if (modifiers.mouse !== true && client.has.touch !== true) {
            return
          }

          const ctx = {
            handler: binding.value,
            noop,

            mouseStart (evt) {
              if (typeof ctx.handler === 'function' && leftClick(evt) === true) {
                addEvt(ctx, 'temp', [
                  [ document, 'mousemove', 'move', 'passiveCapture' ],
                  [ document, 'click', 'end', 'notPassiveCapture' ]
                ]);
                ctx.start(evt, true);
              }
            },

            touchStart (evt) {
              if (evt.target !== void 0 && typeof ctx.handler === 'function') {
                const target = getTouchTarget(evt.target);
                addEvt(ctx, 'temp', [
                  [ target, 'touchmove', 'move', 'passiveCapture' ],
                  [ target, 'touchcancel', 'end', 'notPassiveCapture' ],
                  [ target, 'touchend', 'end', 'notPassiveCapture' ]
                ]);
                ctx.start(evt);
              }
            },

            start (evt, mouseEvent) {
              ctx.origin = position(evt);

              const startTime = Date.now();

              if (client.is.mobile === true) {
                document.body.classList.add('non-selectable');
                clearSelection();

                ctx.styleCleanup = withDelay => {
                  ctx.styleCleanup = void 0;

                  const remove = () => {
                    document.body.classList.remove('non-selectable');
                  };

                  if (withDelay === true) {
                    clearSelection();
                    setTimeout(remove, 10);
                  }
                  else { remove(); }
                };
              }

              ctx.triggered = false;
              ctx.sensitivity = mouseEvent === true
                ? ctx.mouseSensitivity
                : ctx.touchSensitivity;

              ctx.timer = setTimeout(() => {
                clearSelection();
                ctx.triggered = true;

                ctx.handler({
                  evt,
                  touch: mouseEvent !== true,
                  mouse: mouseEvent === true,
                  position: ctx.origin,
                  duration: Date.now() - startTime
                });
              }, ctx.duration);
            },

            move (evt) {
              const { top, left } = position(evt);
              if (
                Math.abs(left - ctx.origin.left) >= ctx.sensitivity
                || Math.abs(top - ctx.origin.top) >= ctx.sensitivity
              ) {
                clearTimeout(ctx.timer);
              }
            },

            end (evt) {
              cleanEvt(ctx, 'temp');

              // delay needed otherwise selection still occurs
              ctx.styleCleanup !== void 0 && ctx.styleCleanup(ctx.triggered);

              if (ctx.triggered === true) {
                evt !== void 0 && stopAndPrevent(evt);
              }
              else {
                clearTimeout(ctx.timer);
              }
            }
          };

          // duration in ms, touch in pixels, mouse in pixels
          const data = [ 600, 5, 7 ];

          if (typeof binding.arg === 'string' && binding.arg.length > 0) {
            binding.arg.split(':').forEach((val, index) => {
              const v = parseInt(val, 10);
              v && (data[ index ] = v);
            });
          }

          [ ctx.duration, ctx.touchSensitivity, ctx.mouseSensitivity ] = data;

          el.__qtouchhold = ctx;

          modifiers.mouse === true && addEvt(ctx, 'main', [
            [ el, 'mousedown', 'mouseStart', `passive${ modifiers.mouseCapture === true ? 'Capture' : '' }` ]
          ]);

          client.has.touch === true && addEvt(ctx, 'main', [
            [ el, 'touchstart', 'touchStart', `passive${ modifiers.capture === true ? 'Capture' : '' }` ],
            [ el, 'touchend', 'noop', 'notPassiveCapture' ]
          ]);
        },

        updated (el, binding) {
          const ctx = el.__qtouchhold;

          if (ctx !== void 0 && binding.oldValue !== binding.value) {
            typeof binding.value !== 'function' && ctx.end();
            ctx.handler = binding.value;
          }
        },

        beforeUnmount (el) {
          const ctx = el.__qtouchhold;

          if (ctx !== void 0) {
            cleanEvt(ctx, 'main');
            cleanEvt(ctx, 'temp');

            clearTimeout(ctx.timer);
            ctx.styleCleanup !== void 0 && ctx.styleCleanup();

            delete el.__qtouchhold;
          }
        }
      };

  const
    keyCodes = {
      esc: 27,
      tab: 9,
      enter: 13,
      space: 32,
      up: 38,
      left: 37,
      right: 39,
      down: 40,
      delete: [ 8, 46 ]
    },
    keyRegex = new RegExp(`^([\\d+]+|${ Object.keys(keyCodes).join('|') })$`, 'i');

  function shouldEnd (evt, origin) {
    const { top, left } = position(evt);

    return Math.abs(left - origin.left) >= 7
      || Math.abs(top - origin.top) >= 7
  }

  var TouchRepeat = {
        name: 'touch-repeat',

        beforeMount (el, { modifiers, value, arg }) {
          const keyboard = Object.keys(modifiers).reduce((acc, key) => {
            if (keyRegex.test(key) === true) {
              const keyCode = isNaN(parseInt(key, 10)) ? keyCodes[ key.toLowerCase() ] : parseInt(key, 10);
              keyCode >= 0 && acc.push(keyCode);
            }
            return acc
          }, []);

          // early return, we don't need to do anything
          if (
            modifiers.mouse !== true
            && client.has.touch !== true
            && keyboard.length === 0
          ) {
            return
          }

          const durations = typeof arg === 'string' && arg.length > 0
            ? arg.split(':').map(val => parseInt(val, 10))
            : [ 0, 600, 300 ];

          const durationsLast = durations.length - 1;

          const ctx = {
            keyboard,
            handler: value,

            noop,

            mouseStart (evt) {
              if (ctx.event === void 0 && typeof ctx.handler === 'function' && leftClick(evt) === true) {
                addEvt(ctx, 'temp', [
                  [ document, 'mousemove', 'move', 'passiveCapture' ],
                  [ document, 'click', 'end', 'notPassiveCapture' ]
                ]);
                ctx.start(evt, true);
              }
            },

            keyboardStart (evt) {
              if (typeof ctx.handler === 'function' && isKeyCode(evt, keyboard) === true) {
                if (durations[ 0 ] === 0 || ctx.event !== void 0) {
                  stopAndPrevent(evt);
                  el.focus();
                  if (ctx.event !== void 0) {
                    return
                  }
                }

                addEvt(ctx, 'temp', [
                  [ document, 'keyup', 'end', 'notPassiveCapture' ],
                  [ document, 'click', 'end', 'notPassiveCapture' ]
                ]);
                ctx.start(evt, false, true);
              }
            },

            touchStart (evt) {
              if (evt.target !== void 0 && typeof ctx.handler === 'function') {
                const target = getTouchTarget(evt.target);
                addEvt(ctx, 'temp', [
                  [ target, 'touchmove', 'move', 'passiveCapture' ],
                  [ target, 'touchcancel', 'end', 'notPassiveCapture' ],
                  [ target, 'touchend', 'end', 'notPassiveCapture' ]
                ]);
                ctx.start(evt);
              }
            },

            start (evt, mouseEvent, keyboardEvent) {
              if (keyboardEvent !== true) {
                ctx.origin = position(evt);
              }

              function styleCleanup (withDelay) {
                ctx.styleCleanup = void 0;

                document.documentElement.style.cursor = '';

                const remove = () => {
                  document.body.classList.remove('non-selectable');
                };

                if (withDelay === true) {
                  clearSelection();
                  setTimeout(remove, 10);
                }
                else { remove(); }
              }

              if (client.is.mobile === true) {
                document.body.classList.add('non-selectable');
                clearSelection();
                ctx.styleCleanup = styleCleanup;
              }

              ctx.event = {
                touch: mouseEvent !== true && keyboardEvent !== true,
                mouse: mouseEvent === true,
                keyboard: keyboardEvent === true,
                startTime: Date.now(),
                repeatCount: 0
              };

              const fn = () => {
                if (ctx.event === void 0) {
                  return
                }

                if (ctx.event.repeatCount === 0) {
                  ctx.event.evt = evt;

                  if (keyboardEvent === true) {
                    ctx.event.keyCode = evt.keyCode;
                  }
                  else {
                    ctx.event.position = position(evt);
                  }

                  if (client.is.mobile !== true) {
                    document.documentElement.style.cursor = 'pointer';
                    document.body.classList.add('non-selectable');
                    clearSelection();
                    ctx.styleCleanup = styleCleanup;
                  }
                }

                ctx.event.duration = Date.now() - ctx.event.startTime;
                ctx.event.repeatCount += 1;

                ctx.handler(ctx.event);

                const index = durationsLast < ctx.event.repeatCount
                  ? durationsLast
                  : ctx.event.repeatCount;

                ctx.timer = setTimeout(fn, durations[ index ]);
              };

              if (durations[ 0 ] === 0) {
                fn();
              }
              else {
                ctx.timer = setTimeout(fn, durations[ 0 ]);
              }
            },

            move (evt) {
              if (ctx.event !== void 0 && shouldEnd(evt, ctx.origin) === true) {
                clearTimeout(ctx.timer);
              }
            },

            end (evt) {
              if (ctx.event === void 0) {
                return
              }

              ctx.styleCleanup !== void 0 && ctx.styleCleanup(true);
              evt !== void 0 && ctx.event.repeatCount > 0 && stopAndPrevent(evt);

              cleanEvt(ctx, 'temp');
              clearTimeout(ctx.timer);

              ctx.event = void 0;
            }
          };

          el.__qtouchrepeat = ctx;

          modifiers.mouse === true && addEvt(ctx, 'main', [
            [ el, 'mousedown', 'mouseStart', `passive${ modifiers.mouseCapture === true ? 'Capture' : '' }` ]
          ]);

          client.has.touch === true && addEvt(ctx, 'main', [
            [ el, 'touchstart', 'touchStart', `passive${ modifiers.capture === true ? 'Capture' : '' }` ],
            [ el, 'touchend', 'noop', 'notPassiveCapture' ]
          ]);

          keyboard.length > 0 && addEvt(ctx, 'main', [
            [ el, 'keydown', 'keyboardStart', `notPassive${ modifiers.keyCapture === true ? 'Capture' : '' }` ]
          ]);
        },

        updated (el, { oldValue, value }) {
          const ctx = el.__qtouchrepeat;

          if (ctx !== void 0 && oldValue !== value) {
            typeof value !== 'function' && ctx.end();
            ctx.handler = value;
          }
        },

        beforeUnmount (el) {
          const ctx = el.__qtouchrepeat;

          if (ctx !== void 0) {
            clearTimeout(ctx.timer);

            cleanEvt(ctx, 'main');
            cleanEvt(ctx, 'temp');

            ctx.styleCleanup !== void 0 && ctx.styleCleanup();

            delete el.__qtouchrepeat;
          }
        }
      };

  var directives = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ClosePopup: ClosePopup,
    Intersection: Intersection,
    Morph: Morph,
    Mutation: Mutation,
    Ripple: Ripple,
    ScrollFire: ScrollFire,
    Scroll: Scroll,
    TouchHold: TouchHold,
    TouchPan: TouchPan,
    TouchRepeat: TouchRepeat,
    TouchSwipe: TouchSwipe
  });

  function getCssVar (propName, element = document.body) {
    if (typeof propName !== 'string') {
      throw new TypeError('Expected a string as propName')
    }
    if (!(element instanceof Element)) {
      throw new TypeError('Expected a DOM element')
    }

    return getComputedStyle(element).getPropertyValue(`--q-${ propName }`).trim() || null
  }

  let metaValue;

  function getProp () {
    return client.is.winphone
      ? 'msapplication-navbutton-color'
      : (
          client.is.safari
            ? 'apple-mobile-web-app-status-bar-style'
            : 'theme-color' // Chrome, Firefox OS, Opera, Vivaldi, ...
        )
  }

  function getMetaTag (v) {
    const els = document.getElementsByTagName('META');
    for (const i in els) {
      if (els[ i ].name === v) {
        return els[ i ]
      }
    }
  }

  function setColor (hexColor) {
    if (metaValue === void 0) {
      // cache it
      metaValue = getProp();
    }

    let metaTag = getMetaTag(metaValue);
    const newTag = metaTag === void 0;

    if (newTag) {
      metaTag = document.createElement('meta');
      metaTag.setAttribute('name', metaValue);
    }

    metaTag.setAttribute('content', hexColor);

    if (newTag) {
      document.head.appendChild(metaTag);
    }
  }

  var AddressbarColor = {
    set: client.is.mobile === true && (
      client.is.nativeMobile === true
      || client.is.winphone === true || client.is.safari === true
      || client.is.webkit === true || client.is.vivaldi === true
    )
      ? hexColor => {
          const val = hexColor || getCssVar('primary');

          if (client.is.nativeMobile === true && window.StatusBar) {
            window.StatusBar.backgroundColorByHexString(val);
          }
          else {
            setColor(val);
          }
        }
      : noop,

    install ({ $q }) {
      $q.addressbarColor = this;
      $q.config.addressbarColor && this.set($q.config.addressbarColor);
    }
  };

  const prefixes = {};

  function getFullscreenElement () {
    return (
      document.fullscreenElement
      || document.mozFullScreenElement
      || document.webkitFullscreenElement
      || document.msFullscreenElement
    )
  }

  // needed for consistency across browsers
  function promisify (target, fn) {
    try {
      const res = target[ fn ]();
      return res === void 0
        ? Promise.resolve()
        : res
    }
    catch (err) {
      return Promise.reject(err)
    }
  }

  const Plugin$5 = defineReactivePlugin({
    isActive: false,
    activeEl: null
  }, {
    isCapable: false,

    request (target) {
      if (Plugin$5.isCapable === true && Plugin$5.isActive === false) {
        const el = target || document.documentElement;
        return promisify(el, prefixes.request)
      }

      return Plugin$5.__getErr()
    },

    exit () {
      return Plugin$5.isCapable === true && Plugin$5.isActive === true
        ? promisify(document, prefixes.exit)
        : Plugin$5.__getErr()
    },

    toggle (target) {
      return Plugin$5.isActive === true
        ? Plugin$5.exit()
        : Plugin$5.request(target)
    },

    install ({ $q }) {
      $q.fullscreen = this;
    }
  });

  {
    function init () {
      prefixes.request = [
        'requestFullscreen',
        'msRequestFullscreen', 'mozRequestFullScreen', 'webkitRequestFullscreen'
      ].find(request => document.documentElement[ request ] !== void 0);

      Plugin$5.isCapable = prefixes.request !== void 0;

      if (Plugin$5.isCapable === false) {
        // it means the browser does NOT support it
        Plugin$5.__getErr = () => Promise.reject('Not capable');
        return
      }

      Plugin$5.__getErr = () => Promise.resolve();

      prefixes.exit = [
        'exitFullscreen',
        'msExitFullscreen', 'mozCancelFullScreen', 'webkitExitFullscreen'
      ].find(exit => document[ exit ]);

      Plugin$5.isActive = !!getFullscreenElement()

      ;[
        'onfullscreenchange',
        'onmsfullscreenchange', 'onwebkitfullscreenchange'
      ].forEach(evt => {
        document[ evt ] = () => {
          Plugin$5.isActive = Plugin$5.isActive === false;

          if (Plugin$5.isActive === false) {
            Plugin$5.activeEl = null;
            changeGlobalNodesTarget(document.body);
          }
          else {
            Plugin$5.activeEl = getFullscreenElement();
            changeGlobalNodesTarget(
              Plugin$5.activeEl === document.documentElement
                ? document.body
                : Plugin$5.activeEl
            );
          }
        };
      });
    }

    init();
  }

  const Plugin$4 = defineReactivePlugin({
    appVisible: true
  }, {
    install ({ $q }) {

      Object.defineProperty($q, 'appVisible', {
        get: () => this.appVisible
      });
    }
  });

  {
    let prop, evt;

    if (typeof document.hidden !== 'undefined') { // Opera 12.10 and Firefox 18 and later support
      prop = 'hidden';
      evt = 'visibilitychange';
    }
    else if (typeof document.msHidden !== 'undefined') {
      prop = 'msHidden';
      evt = 'msvisibilitychange';
    }
    else if (typeof document.webkitHidden !== 'undefined') {
      prop = 'webkitHidden';
      evt = 'webkitvisibilitychange';
    }

    if (evt && typeof document[ prop ] !== 'undefined') {
      const update = () => { Plugin$4.appVisible = !document[ prop ]; };
      document.addEventListener(evt, update, false);
    }
  }

  var BottomSheet$1 = vue.defineComponent({
    name: 'BottomSheetPlugin',

    props: {
      ...useDarkProps,

      title: String,
      message: String,
      actions: Array,

      grid: Boolean,

      cardClass: [ String, Array, Object ],
      cardStyle: [ String, Array, Object ]
    },

    emits: [ 'ok', 'hide' ],

    setup (props, { emit }) {
      const { proxy } = vue.getCurrentInstance();
      const isDark = useDark(props, proxy.$q);

      const dialogRef = vue.ref(null);

      function show () {
        dialogRef.value.show();
      }

      function hide () {
        dialogRef.value.hide();
      }

      function onOk (action) {
        emit('ok', action);
        hide();
      }

      function onHide () {
        emit('hide');
      }

      function getGrid () {
        return props.actions.map(action => {
          const img = action.avatar || action.img;

          return action.label === void 0
            ? vue.h(QSeparator, {
                class: 'col-all',
                dark: isDark.value
              })
            : vue.h('div', {
              class: [
                'q-bottom-sheet__item q-hoverable q-focusable cursor-pointer relative-position',
                action.class
              ],
              tabindex: 0,
              onClick () { onOk(action); },
              onKeyup (e) { e.keyCode === 13 && onOk(action); }
            }, [
              vue.h('div', { class: 'q-focus-helper' }),

              action.icon
                ? vue.h(QIcon, { name: action.icon, color: action.color })
                : (
                    img
                      ? vue.h('img', {
                          class: action.avatar ? 'q-bottom-sheet__avatar' : '',
                          src: img
                        })
                      : vue.h('div', { class: 'q-bottom-sheet__empty-icon' })
                  ),

              vue.h('div', action.label)
            ])
        })
      }

      function getList () {
        return props.actions.map(action => {
          const img = action.avatar || action.img;

          return action.label === void 0
            ? vue.h(QSeparator, { spaced: true, dark: isDark.value })
            : vue.h(QItem, {
              class: [ 'q-bottom-sheet__item', action.classes ],
              tabindex: 0,
              clickable: true,
              dark: isDark.value,
              onClick () { onOk(action); },
              onKeyup (e) { e.keyCode === 13 && onOk(action); }
            }, () => [
              vue.h(
                QItemSection,
                { avatar: true },
                () => (
                  action.icon
                    ? vue.h(QIcon, { name: action.icon, color: action.color })
                    : (
                        img
                          ? vue.h('img', {
                              class: action.avatar ? 'q-bottom-sheet__avatar' : '',
                              src: img
                            })
                          : null
                      )
                )
              ),

              vue.h(QItemSection, () => action.label)
            ])
        })
      }

      function getCardContent () {
        const child = [];

        props.title && child.push(
          vue.h(QCardSection, {
            class: 'q-dialog__title'
          }, () => props.title)
        );

        props.message && child.push(
          vue.h(QCardSection, {
            class: 'q-dialog__message'
          }, () => props.message)
        );

        child.push(
          props.grid === true
            ? vue.h('div', {
                class: 'row items-stretch justify-start'
              }, getGrid())
            : vue.h('div', getList())
        );

        return child
      }

      function getContent () {
        return [
          vue.h(QCard, {
            class: [
              `q-bottom-sheet q-bottom-sheet--${ props.grid === true ? 'grid' : 'list' }`
              + (isDark.value === true ? ' q-bottom-sheet--dark q-dark' : ''),
              props.cardClass
            ],
            style: props.cardStyle
          }, getCardContent)
        ]
      }

      // expose public methods
      Object.assign(proxy, { show, hide });

      return () => vue.h(QDialog, {
        ref: dialogRef,
        position: 'bottom',
        onHide
      }, getContent)
    }
  });

  function merge (target, source) {
    for (const key in source) {
      if (key !== 'spinner' && Object(source[ key ]) === source[ key ]) {
        target[ key ] = Object(target[ key ]) !== target[ key ]
          ? {}
          : { ...target[ key ] };

        merge(target[ key ], source[ key ]);
      }
      else {
        target[ key ] = source[ key ];
      }
    }
  }

  function globalDialog (DefaultComponent, supportsCustomComponent, parentApp) {
    return pluginProps => {

      let DialogComponent, props;
      const isCustom = supportsCustomComponent === true
        && pluginProps.component !== void 0;

      if (isCustom === true) {
        const { component, componentProps } = pluginProps;

        DialogComponent = (typeof component === 'string')
          ? parentApp.component(component)
          : component;

        props = componentProps;
      }
      else {
        const { class: klass, style, ...otherProps } = pluginProps;

        DialogComponent = DefaultComponent;
        props = otherProps;
        klass !== void 0 && (otherProps.cardClass = klass);
        style !== void 0 && (otherProps.cardStyle = style);
      }

      const
        okFns = [],
        cancelFns = [],
        API = {
          onOk (fn) {
            okFns.push(fn);
            return API
          },
          onCancel (fn) {
            cancelFns.push(fn);
            return API
          },
          onDismiss (fn) {
            okFns.push(fn);
            cancelFns.push(fn);
            return API
          },
          hide () {
            if (dialogRef.value !== null) {
              dialogRef.value.hide();
            }
            return API
          },
          update (componentProps) {
            if (vm !== null) {
              if (isCustom === true) {
                Object.assign(props, componentProps);
              }
              else {
                const { class: klass, style, ...cfg } = componentProps;

                klass !== void 0 && (cfg.cardClass = klass);
                style !== void 0 && (cfg.cardStyle = style);
                merge(props, cfg);
              }

              vm.$forceUpdate();
            }

            return API
          }
        };

      const el = createGlobalNode();

      let emittedOK = false;

      const onOk = data => {
        emittedOK = true;
        okFns.forEach(fn => { fn(data); });
      };

      const onHide = () => {
        app.unmount(el);
        removeGlobalNode(el);
        app = null;
        vm = null;

        if (emittedOK !== true) {
          cancelFns.forEach(fn => { fn(); });
        }
      };

      const dialogRef = vue.ref(null);

      let app = createChildApp({
        name: 'QGlobalDialog',
        setup () {
          return () => vue.h(DialogComponent, {
            ref: dialogRef,
            ...props,
            onOk,
            onHide
          })
        }
      }, parentApp);

      let vm = app.mount(el);

      function show () {
        if (dialogRef.value.show !== void 0) {
          dialogRef.value.show();
        }
        else if ( // account for "script setup" way of declaring component
          vm.$.subTree
          && vm.$.subTree.component
          && vm.$.subTree.component.proxy
          && vm.$.subTree.component.proxy.show
        ) {
          vm.$.subTree.component.proxy.show();
        }
        else {
          console.error('[Quasar] Incorrectly defined Dialog component');
        }
      }

      if (dialogRef.value !== null) {
        show();
      }
      else if (typeof DialogComponent.__asyncLoader === 'function') {
        DialogComponent.__asyncLoader().then(() => {
          vue.nextTick(show);
        });
      }

      return API
    }
  }

  var BottomSheet = {
    install ({ $q, parentApp }) {
      if (this.__installed === true) {
        $q.bottomSheet = globalDialog(BottomSheet$1, false, parentApp);
      }
      else {
        this.create = $q.bottomSheet = globalDialog(BottomSheet$1, false, parentApp);
      }
    }
  };

  function encode$1 (string) {
    return encodeURIComponent(string)
  }

  function decode$1 (string) {
    return decodeURIComponent(string)
  }

  function stringifyCookieValue (value) {
    return encode$1(value === Object(value) ? JSON.stringify(value) : '' + value)
  }

  function read (string) {
    if (string === '') {
      return string
    }

    if (string.indexOf('"') === 0) {
      // This is a quoted cookie as according to RFC2068, unescape...
      string = string.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
    }

    // Replace server-side written pluses with spaces.
    // If we can't decode the cookie, ignore it, it's unusable.
    // If we can't parse the cookie, ignore it, it's unusable.
    string = decode$1(string.replace(/\+/g, ' '));

    try {
      string = JSON.parse(string);
    }
    catch (e) {}

    return string
  }

  function getString (msOffset) {
    const time = new Date();
    time.setMilliseconds(time.getMilliseconds() + msOffset);
    return time.toUTCString()
  }

  function parseExpireString (str) {
    let timestamp = 0;

    const days = str.match(/(\d+)d/);
    const hours = str.match(/(\d+)h/);
    const minutes = str.match(/(\d+)m/);
    const seconds = str.match(/(\d+)s/);

    if (days) { timestamp += days[ 1 ] * 864e+5; }
    if (hours) { timestamp += hours[ 1 ] * 36e+5; }
    if (minutes) { timestamp += minutes[ 1 ] * 6e+4; }
    if (seconds) { timestamp += seconds[ 1 ] * 1000; }

    return timestamp === 0
      ? str
      : getString(timestamp)
  }

  function set (key, val, opts = {}, ssr) {
    let expire, expireValue;

    if (opts.expires !== void 0) {
      // if it's a Date Object
      if (Object.prototype.toString.call(opts.expires) === '[object Date]') {
        expire = opts.expires.toUTCString();
      }
      // if it's a String (eg. "15m", "1h", "13d", "1d 15m", "31s")
      // possible units: d (days), h (hours), m (minutes), s (seconds)
      else if (typeof opts.expires === 'string') {
        expire = parseExpireString(opts.expires);
      }
      // otherwise it must be a Number (defined in days)
      else {
        expireValue = parseFloat(opts.expires);
        expire = isNaN(expireValue) === false
          ? getString(expireValue * 864e+5)
          : opts.expires;
      }
    }

    const keyValue = `${ encode$1(key) }=${ stringifyCookieValue(val) }`;

    const cookie = [
      keyValue,
      expire !== void 0 ? '; Expires=' + expire : '', // use expires attribute, max-age is not supported by IE
      opts.path ? '; Path=' + opts.path : '',
      opts.domain ? '; Domain=' + opts.domain : '',
      opts.sameSite ? '; SameSite=' + opts.sameSite : '',
      opts.httpOnly ? '; HttpOnly' : '',
      opts.secure ? '; Secure' : '',
      opts.other ? '; ' + opts.other : ''
    ].join('');

    if (ssr) {
      if (ssr.req.qCookies) {
        ssr.req.qCookies.push(cookie);
      }
      else {
        ssr.req.qCookies = [ cookie ];
      }

      ssr.res.setHeader('Set-Cookie', ssr.req.qCookies);

      // make temporary update so future get()
      // within same SSR timeframe would return the set value

      let all = ssr.req.headers.cookie || '';

      if (expire !== void 0 && expireValue < 0) {
        const val = get(key, ssr);
        if (val !== undefined) {
          all = all
            .replace(`${ key }=${ val }; `, '')
            .replace(`; ${ key }=${ val }`, '')
            .replace(`${ key }=${ val }`, '');
        }
      }
      else {
        all = all
          ? `${ keyValue }; ${ all }`
          : cookie;
      }

      ssr.req.headers.cookie = all;
    }
    else {
      document.cookie = cookie;
    }
  }

  function get (key, ssr) {
    const
      cookieSource = ssr ? ssr.req.headers : document,
      cookies = cookieSource.cookie ? cookieSource.cookie.split('; ') : [],
      l = cookies.length;
    let
      result = key ? null : {},
      i = 0,
      parts,
      name,
      cookie;

    for (; i < l; i++) {
      parts = cookies[ i ].split('=');
      name = decode$1(parts.shift());
      cookie = parts.join('=');

      if (!key) {
        result[ name ] = cookie;
      }
      else if (key === name) {
        result = read(cookie);
        break
      }
    }

    return result
  }

  function remove (key, options, ssr) {
    set(
      key,
      '',
      { expires: -1, ...options },
      ssr
    );
  }

  function has (key, ssr) {
    return get(key, ssr) !== null
  }

  function getObject (ssr) {
    return {
      get: key => get(key, ssr),
      set: (key, val, opts) => set(key, val, opts, ssr),
      has: key => has(key, ssr),
      remove: (key, options) => remove(key, options, ssr),
      getAll: () => get(null, ssr)
    }
  }

  const Plugin$3 = {
    install ({ $q, ssrContext }) {
      {
        $q.cookies = this;
      }
    }
  };

  {
    Object.assign(Plugin$3, getObject());
  }

  var DialogPlugin = vue.defineComponent({
    name: 'DialogPlugin',

    props: {
      ...useDarkProps,

      title: String,
      message: String,
      prompt: Object,
      options: Object,
      progress: [ Boolean, Object ],

      html: Boolean,

      ok: {
        type: [ String, Object, Boolean ],
        default: true
      },
      cancel: [ String, Object, Boolean ],
      focus: {
        type: String,
        default: 'ok',
        validator: v => [ 'ok', 'cancel', 'none' ].includes(v)
      },

      stackButtons: Boolean,
      color: String,

      cardClass: [ String, Array, Object ],
      cardStyle: [ String, Array, Object ]
    },

    emits: [ 'ok', 'hide' ],

    setup (props, { emit }) {
      const { proxy } = vue.getCurrentInstance();
      const { $q } = proxy;

      const isDark = useDark(props, $q);

      const dialogRef = vue.ref(null);

      const model = vue.ref(
        props.prompt !== void 0
          ? props.prompt.model
          : (props.options !== void 0 ? props.options.model : void 0)
      );

      const classes = vue.computed(() =>
        'q-dialog-plugin'
        + (isDark.value === true ? ' q-dialog-plugin--dark q-dark' : '')
        + (props.progress !== false ? ' q-dialog-plugin--progress' : '')
      );

      const vmColor = vue.computed(() =>
        props.color || (isDark.value === true ? 'amber' : 'primary')
      );

      const spinner = vue.computed(() => (
        props.progress === false
          ? null
          : (
              Object(props.progress) === props.progress
                ? {
                    component: props.progress.spinner || QSpinner,
                    props: { color: props.progress.color || vmColor.value }
                  }
                : {
                    component: QSpinner,
                    props: { color: vmColor.value }
                  }
            )
      ));

      const hasForm = vue.computed(() =>
        props.prompt !== void 0 || props.options !== void 0
      );

      const formProps = vue.computed(() => {
        if (hasForm.value !== true) {
          return {}
        }

        const { model, isValid, items, ...formProps } = props.prompt !== void 0
          ? props.prompt
          : props.options;

        return formProps
      });

      const okLabel = vue.computed(() => (
        Object(props.ok) === props.ok
          ? $q.lang.label.ok
          : (
              props.ok === true
                ? $q.lang.label.ok
                : props.ok
            )
      ));

      const cancelLabel = vue.computed(() => (
        Object(props.cancel) === props.cancel
          ? $q.lang.label.cancel
          : (
              props.cancel === true
                ? $q.lang.label.cancel
                : props.cancel
            )
      ));

      const okDisabled = vue.computed(() => {
        if (props.prompt !== void 0) {
          return props.prompt.isValid !== void 0
            && props.prompt.isValid(model.value) !== true
        }
        if (props.options !== void 0) {
          return props.options.isValid !== void 0
            && props.options.isValid(model.value) !== true
        }
        return false
      });

      const okProps = vue.computed(() => ({
        color: vmColor.value,
        label: okLabel.value,
        ripple: false,
        ...(Object(props.ok) === props.ok ? props.ok : { flat: true }),
        disable: okDisabled.value,
        'data-autofocus': (props.focus === 'ok' && hasForm.value !== true) || void 0,
        onClick: onOk
      }));

      const cancelProps = vue.computed(() => ({
        color: vmColor.value,
        label: cancelLabel.value,
        ripple: false,
        ...(Object(props.cancel) === props.cancel ? props.cancel : { flat: true }),
        'data-autofocus': (props.focus === 'cancel' && hasForm.value !== true) || void 0,
        onClick: onCancel
      }));

      vue.watch(() => props.prompt && props.prompt.model, onUpdateModel);
      vue.watch(() => props.options && props.options.model, onUpdateModel);

      function show () {
        dialogRef.value.show();
      }

      function hide () {
        dialogRef.value.hide();
      }

      function onOk () {
        emit('ok', vue.toRaw(model.value));
        hide();
      }

      function onCancel () {
        hide();
      }

      function onDialogHide () {
        emit('hide');
      }

      function onUpdateModel (val) {
        model.value = val;
      }

      function onInputKeyup (evt) {
        // if ENTER key
        if (
          okDisabled.value !== true
          && props.prompt.type !== 'textarea'
          && isKeyCode(evt, 13) === true
        ) {
          onOk();
        }
      }

      function getSection (classes, text) {
        return props.html === true
          ? vue.h(QCardSection, {
              class: classes,
              innerHTML: text
            })
          : vue.h(QCardSection, { class: classes }, () => text)
      }

      function getPrompt () {
        return [
          vue.h(QInput, {
            modelValue: model.value,
            ...formProps.value,
            color: vmColor.value,
            dense: true,
            autofocus: true,
            dark: isDark.value,
            'onUpdate:modelValue': onUpdateModel,
            onKeyup: onInputKeyup
          })
        ]
      }

      function getOptions () {
        return [
          vue.h(QOptionGroup, {
            modelValue: model.value,
            ...formProps.value,
            color: vmColor.value,
            options: props.options.items,
            dark: isDark.value,
            'onUpdate:modelValue': onUpdateModel
          })
        ]
      }

      function getButtons () {
        const child = [];

        props.cancel && child.push(
          vue.h(QBtn, cancelProps.value)
        );

        props.ok && child.push(
          vue.h(QBtn, okProps.value)
        );

        return vue.h(QCardActions, {
          class: props.stackButtons === true ? 'items-end' : '',
          vertical: props.stackButtons,
          align: 'right'
        }, () => child)
      }

      function getCardContent () {
        const child = [];

        props.title && child.push(
          getSection('q-dialog__title', props.title)
        );

        props.progress !== false && child.push(
          vue.h(
            QCardSection,
            { class: 'q-dialog__progress' },
            () => vue.h(spinner.value.component, spinner.value.props)
          )
        );

        props.message && child.push(
          getSection('q-dialog__message', props.message)
        );

        if (props.prompt !== void 0) {
          child.push(
            vue.h(
              QCardSection,
              { class: 'scroll q-dialog-plugin__form' },
              getPrompt
            )
          );
        }
        else if (props.options !== void 0) {
          child.push(
            vue.h(QSeparator, { dark: isDark.value }),
            vue.h(
              QCardSection,
              { class: 'scroll q-dialog-plugin__form' },
              getOptions
            ),
            vue.h(QSeparator, { dark: isDark.value })
          );
        }

        if (props.ok || props.cancel) {
          child.push(getButtons());
        }

        return child
      }

      function getContent () {
        return [
          vue.h(QCard, {
            class: [
              classes.value,
              props.cardClass
            ],
            style: props.cardStyle,
            dark: isDark.value
          }, getCardContent)
        ]
      }

      // expose public methods
      Object.assign(proxy, { show, hide });

      return () => vue.h(QDialog, {
        ref: dialogRef,
        onHide: onDialogHide
      }, getContent)
    }
  });

  var Dialog = {
    install ({ $q, parentApp }) {
      if (this.__installed === true) {
        $q.dialog = globalDialog(DialogPlugin, true, parentApp);
      }
      else {
        this.create = $q.dialog = globalDialog(DialogPlugin, true, parentApp);
      }
    }
  };

  const reqProps = { ref: 'bar' };

  var LoadingBar = defineReactivePlugin({
    isActive: false
  }, {
    start: noop,
    stop: noop,
    increment: noop,
    setDefaults: noop,

    install ({ $q, parentApp }) {
      $q.loadingBar = this;

      if (this.__installed === true) {
        if ($q.config.loadingBar !== void 0) {
          this.setDefaults($q.config.loadingBar);
        }
        return
      }

      const props = vue.ref(
        $q.config.loadingBar !== void 0
          ? { ...$q.config.loadingBar, ...reqProps }
          : { ...reqProps }
      );

      const el = createGlobalNode('q-loading-bar');

      const vm = createChildApp({
        name: 'LoadingBar',
        setup: () => () => vue.h(QAjaxBar, props.value)
      }, parentApp).mount(el);

      Object.assign(this, {
        start: speed => {
          const bar = vm.$refs.bar;
          bar.start(speed);
          this.isActive = bar.calls > 0;
        },
        stop: () => {
          const bar = vm.$refs.bar;
          bar.stop();
          this.isActive = bar.calls > 0;
        },
        increment () {
          const bar = vm.$refs.bar;
          bar.increment.apply(null, arguments);
        },
        setDefaults: opts => {
          if (opts === Object(opts)) {
            props.value = { ...props.value, ...opts, ...reqProps };
          }
        }
      });
    }
  });

  let
    app,
    vm,
    uid$1 = 0,
    timeout,
    props = {};

  const originalDefaults = {
    delay: 0,
    message: false,
    html: false,
    spinnerSize: 80,
    spinnerColor: '',
    messageColor: '',
    backgroundColor: '',
    boxClass: '',
    spinner: QSpinner,
    customClass: ''
  };

  const defaults$1 = { ...originalDefaults };

  const Plugin$2 = defineReactivePlugin({
    isActive: false
  }, {
    show (opts) {

      props = opts === Object(opts) && opts.ignoreDefaults === true
        ? { ...originalDefaults, ...opts }
        : { ...defaults$1, ...opts };

      Plugin$2.isActive = true;

      if (app !== void 0) {
        props.uid = uid$1;
        vm.$forceUpdate();
        return
      }

      props.uid = ++uid$1;
      clearTimeout(timeout);

      timeout = setTimeout(() => {
        timeout = void 0;

        const el = createGlobalNode('q-loading');

        app = vue.createApp({
          name: 'QLoading',

          setup () {
            vue.onMounted(() => {
              preventScroll(true);
            });

            function onAfterLeave () {
              // might be called to finalize
              // previous leave, even if it was cancelled
              if (Plugin$2.isActive !== true && app !== void 0) {
                preventScroll(false);
                app.unmount(el);
                removeGlobalNode(el);
                app = void 0;
                vm = void 0;
              }
            }

            function getContent () {
              if (Plugin$2.isActive !== true) {
                return null
              }

              const content = [
                vue.h(props.spinner, {
                  class: 'q-loading__spinner',
                  color: props.spinnerColor,
                  size: props.spinnerSize
                })
              ];

              props.message && content.push(
                vue.h('div', {
                  class: 'q-loading__message'
                    + (props.messageColor ? ` text-${ props.messageColor }` : ''),
                  [ props.html === true ? 'innerHTML' : 'textContent' ]: props.message
                })
              );

              return vue.h('div', {
                class: 'q-loading fullscreen flex flex-center z-max ' + props.customClass.trim(),
                key: props.uid
              }, [
                vue.h('div', {
                  class: 'q-loading__backdrop'
                    + (props.backgroundColor ? ` bg-${ props.backgroundColor }` : '')
                }),

                vue.h('div', {
                  class: 'q-loading__box column items-center ' + props.boxClass
                }, content)
              ])
            }

            return () => vue.h(vue.Transition, {
              name: 'q-transition--fade',
              appear: true,
              onAfterLeave
            }, getContent)
          }
        });

        vm = app.mount(el);
      }, props.delay);
    },

    hide () {
      if (Plugin$2.isActive === true) {
        if (timeout !== void 0) {
          clearTimeout(timeout);
          timeout = void 0;
        }

        Plugin$2.isActive = false;
      }
    },

    setDefaults (opts) {
      {
        opts === Object(opts) && Object.assign(defaults$1, opts);
      }
    },

    install ({ $q }) {
      $q.loading = this;

      if ($q.config.loading !== void 0) {
        this.setDefaults($q.config.loading);
      }
    }
  });

  let updateId, currentClientMeta;
  const clientList = [];

  function normalize (meta) {
    if (meta.title) {
      meta.title = meta.titleTemplate
        ? meta.titleTemplate(meta.title)
        : meta.title;
      delete meta.titleTemplate;
    }
  [ [ 'meta', 'content' ], [ 'link', 'href' ] ].forEach(type => {
      const
        metaType = meta[ type[ 0 ] ],
        metaProp = type[ 1 ];

      for (const name in metaType) {
        const metaLink = metaType[ name ];

        if (metaLink.template) {
          if (Object.keys(metaLink).length === 1) {
            delete metaType[ name ];
          }
          else {
            metaLink[ metaProp ] = metaLink.template(metaLink[ metaProp ] || '');
            delete metaLink.template;
          }
        }
      }
    });
  }

  function changed (old, def) {
    if (Object.keys(old).length !== Object.keys(def).length) {
      return true
    }
    for (const key in old) {
      if (old[ key ] !== def[ key ]) {
        return true
      }
    }
  }

  function bodyFilter (name) {
    return [ 'class', 'style' ].includes(name) === false
  }

  function htmlFilter (name) {
    return [ 'lang', 'dir' ].includes(name) === false
  }

  function diff (meta, other) {
    const add = {}, remove = {};

    if (meta === void 0) {
      return { add: other, remove }
    }

    if (meta.title !== other.title) {
      add.title = other.title;
    }
  [ 'meta', 'link', 'script', 'htmlAttr', 'bodyAttr' ].forEach(type => {
      const old = meta[ type ], cur = other[ type ];
      remove[ type ] = [];

      if (old === void 0 || old === null) {
        add[ type ] = cur;
        return
      }

      add[ type ] = {};

      for (const key in old) {
        if (cur.hasOwnProperty(key) === false) {
          remove[ type ].push(key);
        }
      }
      for (const key in cur) {
        if (old.hasOwnProperty(key) === false) {
          add[ type ][ key ] = cur[ key ];
        }
        else if (changed(old[ key ], cur[ key ]) === true) {
          remove[ type ].push(key);
          add[ type ][ key ] = cur[ key ];
        }
      }
    });

    return { add, remove }
  }

  function apply ({ add, remove }) {
    if (add.title) {
      document.title = add.title;
    }

    if (Object.keys(remove).length > 0) {
      [ 'meta', 'link', 'script' ].forEach(type => {
        remove[ type ].forEach(name => {
          document.head.querySelector(`${ type }[data-qmeta="${ name }"]`).remove();
        });
      });
      remove.htmlAttr.filter(htmlFilter).forEach(name => {
        document.documentElement.removeAttribute(name);
      });
      remove.bodyAttr.filter(bodyFilter).forEach(name => {
        document.body.removeAttribute(name);
      });
    }
  [ 'meta', 'link', 'script' ].forEach(type => {
      const metaType = add[ type ];

      for (const name in metaType) {
        const tag = document.createElement(type);
        for (const att in metaType[ name ]) {
          if (att !== 'innerHTML') {
            tag.setAttribute(att, metaType[ name ][ att ]);
          }
        }
        tag.setAttribute('data-qmeta', name);
        if (type === 'script') {
          tag.innerHTML = metaType[ name ].innerHTML || '';
        }
        document.head.appendChild(tag);
      }
    });
    Object.keys(add.htmlAttr).filter(htmlFilter).forEach(name => {
      document.documentElement.setAttribute(name, add.htmlAttr[ name ] || '');
    });
    Object.keys(add.bodyAttr).filter(bodyFilter).forEach(name => {
      document.body.setAttribute(name, add.bodyAttr[ name ] || '');
    });
  }

  function updateClientMeta () {
    const data = {
      title: '',
      titleTemplate: null,
      meta: {},
      link: {},
      script: {},
      htmlAttr: {},
      bodyAttr: {}
    };

    for (let i = 0; i < clientList.length; i++) {
      const { active, val } = clientList[ i ];

      if (active === true) {
        extend(true, data, val);
      }
    }

    normalize(data);

    apply(diff(currentClientMeta, data));
    currentClientMeta = data;
  }

  function planClientUpdate () {
    clearTimeout(updateId);
    updateId = setTimeout(updateClientMeta, 50);
  }

  var Meta = {
    install (opts) {
      if (this.__installed !== true && isRuntimeSsrPreHydration.value === true) {
        currentClientMeta = window.__Q_META__;
        document.getElementById('qmeta-init').remove();
      }
    }
  };

  let uid = 0, addNotification;
  const defaults = {};

  const positionList = [
    'top-left', 'top-right',
    'bottom-left', 'bottom-right',
    'top', 'bottom', 'left', 'right', 'center'
  ];

  const badgePositions = [
    'top-left', 'top-right',
    'bottom-left', 'bottom-right'
  ];

  const notifTypes = {
    positive: {
      icon: $q => $q.iconSet.type.positive,
      color: 'positive'
    },

    negative: {
      icon: $q => $q.iconSet.type.negative,
      color: 'negative'
    },

    warning: {
      icon: $q => $q.iconSet.type.warning,
      color: 'warning',
      textColor: 'dark'
    },

    info: {
      icon: $q => $q.iconSet.type.info,
      color: 'info'
    },

    ongoing: {
      group: false,
      timeout: 0,
      spinner: true,
      color: 'grey-8'
    }
  };

  const groups = {};
  const positionClass = {};

  function logError (error, config) {
    console.error(`Notify: ${ error }`, config);
    return false
  }

  function getComponent ($q) {
    return vue.defineComponent({
      name: 'QNotifications',

      setup () {
        const notificationsList = {};
        const notifRefs = [];

        positionList.forEach(pos => {
          notificationsList[ pos ] = vue.ref([]);

          const
            vert = [ 'left', 'center', 'right' ].includes(pos) === true ? 'center' : (pos.indexOf('top') > -1 ? 'top' : 'bottom'),
            align = pos.indexOf('left') > -1 ? 'start' : (pos.indexOf('right') > -1 ? 'end' : 'center'),
            classes = [ 'left', 'right' ].includes(pos) ? `items-${ pos === 'left' ? 'start' : 'end' } justify-center` : (pos === 'center' ? 'flex-center' : `items-${ align }`);

          positionClass[ pos ] = `q-notifications__list q-notifications__list--${ vert } fixed column no-wrap ${ classes }`;
        });

        addNotification = (config, originalApi) => {
          if (!config) {
            return logError('parameter required')
          }

          let Api;
          const notif = { textColor: 'white' };

          if (config.ignoreDefaults !== true) {
            Object.assign(notif, defaults);
          }

          if (Object(config) !== config) {
            if (notif.type) {
              Object.assign(notif, notifTypes[ notif.type ]);
            }

            config = { message: config };
          }

          Object.assign(notif, notifTypes[ config.type || notif.type ], config);

          if (typeof notif.icon === 'function') {
            notif.icon = notif.icon($q);
          }

          if (!notif.spinner) {
            notif.spinner = false;
          }
          else {
            if (notif.spinner === true) {
              notif.spinner = QSpinner;
            }

            notif.spinner = vue.markRaw(notif.spinner);
          }

          notif.meta = {
            hasMedia: Boolean(notif.spinner !== false || notif.icon || notif.avatar)
          };

          if (notif.position) {
            if (positionList.includes(notif.position) === false) {
              return logError('wrong position', config)
            }
          }
          else {
            notif.position = 'bottom';
          }

          if (notif.timeout === void 0) {
            notif.timeout = 5000;
          }
          else {
            const t = parseInt(notif.timeout, 10);
            if (isNaN(t) || t < 0) {
              return logError('wrong timeout', config)
            }
            notif.timeout = t;
          }

          if (notif.timeout === 0) {
            notif.progress = false;
          }
          else if (notif.progress === true) {
            notif.meta.progressClass = 'q-notification__progress' + (
              notif.progressClass
                ? ` ${ notif.progressClass }`
                : ''
            );

            notif.meta.progressStyle = {
              animationDuration: `${ notif.timeout + 1000 }ms`
            };
          }

          const actions = (
            Array.isArray(config.actions) === true
              ? config.actions
              : []
          ).concat(
            config.ignoreDefaults !== true && Array.isArray(defaults.actions) === true
              ? defaults.actions
              : []
          ).concat(
            notifTypes[ config.type ] !== void 0 && Array.isArray(notifTypes[ config.type ].actions) === true
              ? notifTypes[ config.type ].actions
              : []
          );

          notif.closeBtn && actions.push({
            label: typeof notif.closeBtn === 'string'
              ? notif.closeBtn
              : $q.lang.label.close
          });

          notif.actions = actions.map(({ handler, noDismiss, ...item }) => ({
            flat: true,
            ...item,
            onClick: typeof handler === 'function'
              ? () => {
                  handler();
                  noDismiss !== true && dismiss();
                }
              : () => { dismiss(); }
          }));

          if (notif.multiLine === void 0) {
            notif.multiLine = notif.actions.length > 1;
          }

          Object.assign(notif.meta, {
            class: 'q-notification row items-stretch'
              + ` q-notification--${ notif.multiLine === true ? 'multi-line' : 'standard' }`
              + (notif.color !== void 0 ? ` bg-${ notif.color }` : '')
              + (notif.textColor !== void 0 ? ` text-${ notif.textColor }` : '')
              + (notif.classes !== void 0 ? ` ${ notif.classes }` : ''),

            wrapperClass: 'q-notification__wrapper col relative-position border-radius-inherit '
              + (notif.multiLine === true ? 'column no-wrap justify-center' : 'row items-center'),

            contentClass: 'q-notification__content row items-center'
              + (notif.multiLine === true ? '' : ' col'),

            attrs: {
              role: 'alert',
              ...notif.attrs
            }
          });

          if (notif.group === false) {
            notif.group = void 0;
            notif.meta.group = void 0;
          }
          else {
            if (notif.group === void 0 || notif.group === true) {
              // do not replace notifications with different buttons
              notif.group = [
                notif.message,
                notif.caption,
                notif.multiline
              ].concat(
                notif.actions.map(props => `${ props.label }*${ props.icon }`)
              ).join('|');
            }

            notif.meta.group = notif.group + '|' + notif.position;
          }

          if (notif.actions.length === 0) {
            notif.actions = void 0;
          }
          else {
            notif.meta.actionsClass = 'q-notification__actions row items-center '
              + (notif.multiLine === true ? 'justify-end' : 'col-auto')
              + (notif.meta.hasMedia === true ? ' q-notification__actions--with-media' : '');
          }

          if (originalApi !== void 0) {
            // reset timeout if any
            clearTimeout(originalApi.notif.meta.timer);

            // retain uid
            notif.meta.uid = originalApi.notif.meta.uid;

            // replace notif
            const index = notificationsList[ notif.position ].value.indexOf(originalApi.notif);
            notificationsList[ notif.position ].value[ index ] = notif;
          }
          else {
            const original = groups[ notif.meta.group ];

            // woohoo, it's a new notification
            if (original === void 0) {
              notif.meta.uid = uid++;
              notif.meta.badge = 1;

              if ([ 'left', 'right', 'center' ].indexOf(notif.position) !== -1) {
                notificationsList[ notif.position ].value.splice(
                  Math.floor(notificationsList[ notif.position ].value.length / 2),
                  0,
                  notif
                );
              }
              else {
                const action = notif.position.indexOf('top') > -1 ? 'unshift' : 'push';
                notificationsList[ notif.position ].value[ action ](notif);
              }

              if (notif.group !== void 0) {
                groups[ notif.meta.group ] = notif;
              }
            }
            // ok, so it's NOT a new one
            else {
              // reset timeout if any
              clearTimeout(original.meta.timer);

              if (notif.badgePosition !== void 0) {
                if (badgePositions.includes(notif.badgePosition) === false) {
                  return logError('wrong badgePosition', config)
                }
              }
              else {
                notif.badgePosition = `top-${ notif.position.indexOf('left') > -1 ? 'right' : 'left' }`;
              }

              notif.meta.uid = original.meta.uid;
              notif.meta.badge = original.meta.badge + 1;
              notif.meta.badgeClass = `q-notification__badge q-notification__badge--${ notif.badgePosition }`
                + (notif.badgeColor !== void 0 ? ` bg-${ notif.badgeColor }` : '')
                + (notif.badgeTextColor !== void 0 ? ` text-${ notif.badgeTextColor }` : '')
                + (notif.badgeClass ? ` ${ notif.badgeClass }` : '');

              const index = notificationsList[ notif.position ].value.indexOf(original);
              notificationsList[ notif.position ].value[ index ] = groups[ notif.meta.group ] = notif;
            }
          }

          const dismiss = () => {
            remove(notif);
            Api = void 0;
          };

          if (notif.timeout > 0) {
            notif.meta.timer = setTimeout(() => {
              dismiss();
            }, notif.timeout + /* show duration */ 1000);
          }

          // only non-groupable can be updated
          if (notif.group !== void 0) {
            return props => {
              if (props !== void 0) {
                logError('trying to update a grouped one which is forbidden', config);
              }
              else {
                dismiss();
              }
            }
          }

          Api = {
            dismiss,
            config,
            notif
          };

          if (originalApi !== void 0) {
            Object.assign(originalApi, Api);
            return
          }

          return props => {
            // if notification wasn't previously dismissed
            if (Api !== void 0) {
              // if no params, then we must dismiss the notification
              if (props === void 0) {
                Api.dismiss();
              }
              // otherwise we're updating it
              else {
                const newNotif = Object.assign({}, Api.config, props, {
                  group: false,
                  position: notif.position
                });

                addNotification(newNotif, Api);
              }
            }
          }
        };

        function remove (notif) {
          clearTimeout(notif.meta.timer);

          const index = notificationsList[ notif.position ].value.indexOf(notif);
          if (index !== -1) {
            if (notif.group !== void 0) {
              delete groups[ notif.meta.group ];
            }

            const el = notifRefs[ '' + notif.meta.uid ];

            if (el) {
              const { width, height } = getComputedStyle(el);

              el.style.left = `${ el.offsetLeft }px`;
              el.style.width = width;
              el.style.height = height;
            }

            notificationsList[ notif.position ].value.splice(index, 1);

            if (typeof notif.onDismiss === 'function') {
              notif.onDismiss();
            }
          }
        }

        return () => vue.h('div', { class: 'q-notifications' }, positionList.map(pos => {
          return vue.h(vue.TransitionGroup, {
            key: pos,
            class: positionClass[ pos ],
            tag: 'div',
            name: `q-notification--${ pos }`
          }, () => notificationsList[ pos ].value.map(notif => {
            let msgChild;

            const meta = notif.meta;
            const msgData = { class: 'q-notification__message col' };

            if (notif.html === true) {
              msgData.innerHTML = notif.caption
                ? `<div>${ notif.message }</div><div class="q-notification__caption">${ notif.caption }</div>`
                : notif.message;
            }
            else {
              const msgNode = [ notif.message ];
              msgChild = notif.caption
                ? [
                    vue.h('div', msgNode),
                    vue.h('div', { class: 'q-notification__caption' }, [ notif.caption ])
                  ]
                : msgNode;
            }

            const mainChild = [];

            if (meta.hasMedia === true) {
              if (notif.spinner !== false) {
                mainChild.push(
                  vue.h(notif.spinner, { class: 'q-notification__spinner' })
                );
              }
              else if (notif.icon) {
                mainChild.push(
                  vue.h(QIcon, {
                    class: 'q-notification__icon',
                    name: notif.icon,
                    role: 'img'
                  })
                );
              }
              else if (notif.avatar) {
                mainChild.push(
                  vue.h(QAvatar, {
                    class: 'q-notification__avatar'
                  }, () => vue.h('img', { src: notif.avatar, 'aria-hidden': 'true' }))
                );
              }
            }

            mainChild.push(
              vue.h('div', msgData, msgChild)
            );

            const child = [
              vue.h('div', { class: meta.contentClass }, mainChild)
            ];

            notif.progress === true && child.push(
              vue.h('div', {
                key: `${ meta.uid }|p|${ meta.badge }`,
                class: meta.progressClass,
                style: meta.progressStyle
              })
            );

            notif.actions !== void 0 && child.push(
              vue.h('div', {
                class: meta.actionsClass
              }, notif.actions.map(props => vue.h(QBtn, props)))
            );

            meta.badge > 1 && child.push(
              vue.h('div', {
                key: `${ meta.uid }|${ meta.badge }`,
                class: notif.meta.badgeClass,
                style: notif.badgeStyle
              }, [ meta.badge ])
            );

            return vue.h('div', {
              ref: el => { notifRefs[ '' + meta.uid ] = el; },
              key: meta.uid,
              class: meta.class,
              ...meta.attrs
            }, [
              vue.h('div', { class: meta.wrapperClass }, child)
            ])
          }))
        }))
      }
    })
  }

  var Notify = {
    create (opts) {
      return addNotification(opts)
    },

    setDefaults (opts) {
      {
        opts === Object(opts) && Object.assign(defaults, opts);
      }
    },

    registerType (typeName, typeOpts) {
      if (typeOpts === Object(typeOpts)) {
        notifTypes[ typeName ] = typeOpts;
      }
    },

    install ({ $q, parentApp }) {
      $q.notify = this.create;
      $q.notify.setDefaults = this.setDefaults;
      $q.notify.registerType = this.registerType;

      if ($q.config.notify !== void 0) {
        this.setDefaults($q.config.notify);
      }

      if (this.__installed !== true) {
        const el = createGlobalNode('q-notify');
        createChildApp(getComponent($q), parentApp).mount(el);
      }
    }
  };

  function encode (value) {
    if (Object.prototype.toString.call(value) === '[object Date]') {
      return '__q_date|' + value.toUTCString()
    }
    if (Object.prototype.toString.call(value) === '[object RegExp]') {
      return '__q_expr|' + value.source
    }
    if (typeof value === 'number') {
      return '__q_numb|' + value
    }
    if (typeof value === 'boolean') {
      return '__q_bool|' + (value ? '1' : '0')
    }
    if (typeof value === 'string') {
      return '__q_strn|' + value
    }
    if (typeof value === 'function') {
      return '__q_strn|' + value.toString()
    }
    if (value === Object(value)) {
      return '__q_objt|' + JSON.stringify(value)
    }

    // hmm, we don't know what to do with it,
    // so just return it as is
    return value
  }

  function decode (value) {
    const length = value.length;
    if (length < 9) {
      // then it wasn't encoded by us
      return value
    }

    const type = value.substr(0, 8);
    const source = value.substring(9);

    switch (type) {
      case '__q_date':
        return new Date(source)

      case '__q_expr':
        return new RegExp(source)

      case '__q_numb':
        return Number(source)

      case '__q_bool':
        return Boolean(source === '1')

      case '__q_strn':
        return '' + source

      case '__q_objt':
        return JSON.parse(source)

      default:
        // hmm, we reached here, we don't know the type,
        // then it means it wasn't encoded by us, so just
        // return whatever value it is
        return value
    }
  }

  function getEmptyStorage () {
    const getVal = () => null;

    return {
      has: () => false,
      getLength: () => 0,
      getItem: getVal,
      getIndex: getVal,
      getKey: getVal,
      getAll: () => {},
      getAllKeys: () => [],
      set: noop,
      remove: noop,
      clear: noop,
      isEmpty: () => true
    }
  }

  function getStorage (type) {
    const
      webStorage = window[ type + 'Storage' ],
      get = key => {
        const item = webStorage.getItem(key);
        return item
          ? decode(item)
          : null
      };

    return {
      has: key => webStorage.getItem(key) !== null,
      getLength: () => webStorage.length,
      getItem: get,
      getIndex: index => {
        return index < webStorage.length
          ? get(webStorage.key(index))
          : null
      },
      getKey: index => {
        return index < webStorage.length
          ? webStorage.key(index)
          : null
      },
      getAll: () => {
        let key;
        const result = {}, len = webStorage.length;

        for (let i = 0; i < len; i++) {
          key = webStorage.key(i);
          result[ key ] = get(key);
        }

        return result
      },
      getAllKeys: () => {
        const result = [], len = webStorage.length;

        for (let i = 0; i < len; i++) {
          result.push(webStorage.key(i));
        }

        return result
      },
      set: (key, value) => { webStorage.setItem(key, encode(value)); },
      remove: key => { webStorage.removeItem(key); },
      clear: () => { webStorage.clear(); },
      isEmpty: () => webStorage.length === 0
    }
  }

  const storage$1 = client.has.webStorage === false
    ? getEmptyStorage()
    : getStorage('local');

  const Plugin$1 = {
    install ({ $q }) {
      $q.localStorage = storage$1;
    }
  };

  Object.assign(Plugin$1, storage$1);

  const storage = client.has.webStorage === false
    ? getEmptyStorage()
    : getStorage('session');

  const Plugin = {
    install ({ $q }) {
      $q.sessionStorage = storage;
    }
  };

  Object.assign(Plugin, storage);

  var plugins = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AddressbarColor: AddressbarColor,
    AppFullscreen: Plugin$5,
    AppVisibility: Plugin$4,
    BottomSheet: BottomSheet,
    Cookies: Plugin$3,
    Dark: Plugin$8,
    Dialog: Dialog,
    LoadingBar: LoadingBar,
    Loading: Plugin$2,
    Meta: Meta,
    Notify: Notify,
    Platform: Platform,
    Screen: Screen,
    LocalStorage: Plugin$1,
    SessionStorage: Plugin
  });

  function fallback (text) {
    const area = document.createElement('textarea');
    area.value = text;
    area.contentEditable = true;
    area.style.position = 'fixed'; // avoid scrolling to bottom

    document.body.appendChild(area);
    area.focus();
    area.select();

    const res = document.execCommand('copy');

    area.remove();
    return res
  }

  function copyToClipboard (text) {
    return navigator.clipboard !== void 0
      ? navigator.clipboard.writeText(text)
      : new Promise((resolve, reject) => {
        const res = fallback(text);
        if (res) {
          resolve(true);
        }
        else {
          reject(res);
        }
      })
  }

  var createMetaMixin = metaOptions => {

    const mixin = {
      activated () {
        this.__qMeta.active = true;
        planClientUpdate();
      },

      deactivated () {
        this.__qMeta.active = false;
        planClientUpdate();
      },

      unmounted () {
        clientList.splice(clientList.indexOf(this.__qMeta), 1);
        planClientUpdate();
        this.__qMeta = void 0;
      }
    };

    if (typeof metaOptions === 'function') {
      Object.assign(mixin, {
        computed: {
          __qMetaOptions () {
            return metaOptions.call(this) || {}
          }
        },

        watch: {
          __qMetaOptions (val) {
            this.__qMeta.val = val;
            this.__qMeta.active === true && planClientUpdate();
          }
        },

        created () {
          this.__qMeta = { active: true, val: this.__qMetaOptions };
          clientList.push(this.__qMeta);
          planClientUpdate();
        }
      });
    }
    else {
      mixin.created = function () {
        this.__qMeta = { active: true, val: metaOptions };
        clientList.push(this.__qMeta);
        planClientUpdate();
      };
    }

    return mixin
  };

  function clean (link) {
    // allow time for iOS
    setTimeout(() => {
      window.URL.revokeObjectURL(link.href);
    }, 10000);

    link.remove();
  }

  /**
   * Forces browser to download file with specified content
   *
   * @param {*} fileName - String
   * @param {*} rawData - String | ArrayBuffer | ArrayBufferView | Blob
   * @param {*} opts - String (mimeType) or Object
   *                   Object form: { mimeType?: String, byteOrderMark?: String | Uint8Array, encoding?: String }
   * @returns Boolean | Error
   *
   * mimeType       - Examples: 'application/octect-stream' (default), 'text/plain', 'application/json',
   *                  'text/plain;charset=UTF-8', 'video/mp4', 'image/png', 'application/pdf'
   *                  https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types
   *
   * byteOrderMark  - (BOM) Example: '\uFEFF'
   *                  https://en.wikipedia.org/wiki/Byte_order_mark
   *
   * encoding       - Performs a TextEncoder.encode() over the rawData;
   *                  Example: 'windows-1252' (ANSI, a subset of ISO-8859-1)
   *                  https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder
   */
  function exportFile (fileName, rawData, opts = {}) {
    const { mimeType, byteOrderMark, encoding } = typeof opts === 'string'
      ? { mimeType: opts }
      : opts;

    const data = encoding !== void 0
      ? (new TextEncoder(encoding)).encode([ rawData ])
      : rawData;

    const blobData = byteOrderMark !== void 0 ? [ byteOrderMark, data ] : [ data ];
    const blob = new Blob(blobData, { type: mimeType || 'application/octet-stream' });
    const link = document.createElement('a');

    link.href = window.URL.createObjectURL(blob);
    link.setAttribute('download', fileName);

    // Check for "download" attribute support;
    // If not supported, open this in new window
    if (typeof link.download === 'undefined') {
      link.setAttribute('target', '_blank');
    }

    link.classList.add('hidden');
    link.style.position = 'fixed'; // avoid scrolling to bottom
    document.body.appendChild(link);

    try {
      link.click();
      clean(link);
      return true
    }
    catch (err) {
      clean(link);
      return err
    }
  }

  function parseFeatures (winFeatures) {
    const cfg = Object.assign({ noopener: true }, winFeatures);
    const feat = [];
    Object.keys(cfg).forEach(key => {
      if (cfg[ key ] === true) {
        feat.push(key);
      }
    });
    return feat.join(',')
  }

  function openWindow (url, reject, windowFeatures) {
    let open = window.open;

    if (Platform.is.cordova === true) {
      if (cordova !== void 0 && cordova.InAppBrowser !== void 0 && cordova.InAppBrowser.open !== void 0) {
        open = cordova.InAppBrowser.open;
      }
      else if (navigator !== void 0 && navigator.app !== void 0) {
        return navigator.app.loadUrl(url, {
          openExternal: true
        })
      }
    }

    const win = open(url, '_blank', parseFeatures(windowFeatures));

    if (win) {
      Platform.is.desktop && win.focus();
      return win
    }
    else {
      reject && reject();
    }
  }

  var openUrl = (url, reject, windowFeatures) => {
    if (
      Platform.is.ios === true
      && window.SafariViewController !== void 0
    ) {
      window.SafariViewController.isAvailable(available => {
        if (available) {
          window.SafariViewController.show(
            { url },
            noop,
            reject
          );
        }
        else {
          openWindow(url, reject, windowFeatures);
        }
      });
      return
    }

    return openWindow(url, reject, windowFeatures)
  };

  var utils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    clone: clone,
    colors: colors,
    copyToClipboard: copyToClipboard,
    createMetaMixin: createMetaMixin,
    createUploaderComponent: createUploaderComponent,
    date: date,
    debounce: debounce,
    dom: dom,
    event: event,
    exportFile: exportFile,
    extend: extend,
    format: format,
    frameDebounce: frameDebounce,
    getCssVar: getCssVar,
    noop: noop,
    morph: morph,
    openURL: openUrl,
    patterns: patterns,
    scroll: scroll,
    setCssVar: setCssVar,
    throttle: throttle,
    uid: uid$2
  });

  // To be used for the custom component
  // used on a Dialog plugin

  function useDialogPluginComponent () {
    const { emit, proxy } = vue.getCurrentInstance();

    // we need a Vue reference to the QDialog
    // component so we can handle it;
    // <q-dialog ref="dialogRef" ...
    // make sure that the setup() in which this
    // function is called returns dialogRef variable
    const dialogRef = vue.ref(null);

    function show () { dialogRef.value.show(); }
    function hide () { dialogRef.value.hide(); }

    function onDialogOK (payload) {
      emit('ok', payload);
      hide();
    }

    function onDialogHide () { emit('hide'); }

    // expose public methods required by Dialog plugin
    Object.assign(proxy, { show, hide });

    return {
      dialogRef,
      onDialogHide,
      onDialogOK,
      onDialogCancel: hide
    }
  }

  useDialogPluginComponent.emits = [ 'ok', 'hide' ];

  function useMeta (metaOptions) {
    {
      const meta = { active: true };

      if (typeof metaOptions === 'function') {
        const content = vue.computed(metaOptions);
        meta.val = content.value;

        vue.watch(content, val => {
          meta.val = val;
          meta.active === true && planClientUpdate();
        });
      }
      else {
        meta.val = metaOptions;
      }

      clientList.push(meta);
      planClientUpdate();

      vue.onActivated(() => {
        meta.active = true;
        planClientUpdate();
      });

      vue.onDeactivated(() => {
        meta.active = false;
        planClientUpdate();
      });

      vue.onUnmounted(() => {
        clientList.splice(clientList.indexOf(meta), 1);
        planClientUpdate();
      });
    }
  }

  /**
   * Returns the $q instance.
   * Equivalent to `this.$q` inside templates.
   */
  function useQuasar () {
    return vue.inject(quasarKey)
  }

  var composables = /*#__PURE__*/Object.freeze({
    __proto__: null,
    useDialogPluginComponent: useDialogPluginComponent,
    useFormChild: useFormChild,
    useMeta: useMeta,
    useQuasar: useQuasar
  });

  var index_umd = {
    version: '2.0.0-beta.19',
    install (app, opts) {
      installQuasar(app, {
        components,
        directives,
        plugins,
        ...opts
      });
    },
    lang: Plugin$7,
    iconSet: Plugin$6,
    ...components,
    ...directives,
    ...plugins,
    ...composables,
    ...utils
  };

  return index_umd;

})));
